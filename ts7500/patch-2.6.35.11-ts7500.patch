diff -Nur linux-2.6.35.11/arch/arm/boot/bootp/bootp.lds linux-2.6.35.11-ts7500//arch/arm/boot/bootp/bootp.lds
--- linux-2.6.35.11/arch/arm/boot/bootp/bootp.lds	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/bootp/bootp.lds	2011-02-26 20:32:46.000000000 -0500
@@ -17,6 +17,8 @@
    *(.start)
    *(.text)
    initrd_size = initrd_end - initrd_start;
+/* scott.kernel */
+   kernel_size = kernel_end - kernel_start;   
    _etext = .;
   }
 
diff -Nur linux-2.6.35.11/arch/arm/boot/bootp/init.S linux-2.6.35.11-ts7500//arch/arm/boot/bootp/init.S
--- linux-2.6.35.11/arch/arm/boot/bootp/init.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/bootp/init.S	2011-02-26 20:32:46.000000000 -0500
@@ -22,9 +22,13 @@
 
 _start:		add	lr, pc, #-0x8		@ lr = current load addr
 		adr	r13, data
-		ldmia	r13!, {r4-r6}		@ r5 = dest, r6 = length
+		ldmia	r13!, {r4-r6}		@ r5 = initrd_phys, r6 = initrd_size
 		add	r4, r4, lr		@ r4 = initrd_start + load addr
 		bl	move			@ move the initrd
+		ldmia	r13!, {r4-r6}		@ r5 = kernel_phys, r6 = kernel_size
+		add	r4, r4, lr		@ r4 = kernel_start + load addr
+		mov	r12, r5			@ save kernel_phys to r12
+		bl	move			@ move the kernel
 
 /*
  * Setup the initrd parameters to pass to the kernel.  This can only be
@@ -49,7 +53,7 @@
 /*
  * find the end of the tag list, and then add an INITRD tag on the end.
  * If there is already an INITRD tag, then we ignore it; the last INITRD
- * tag takes precedence.
+ * tag takes precidence.
  */
 taglist:	ldr	r10, [r9, #0]		@ tag length
 		teq	r10, #0			@ last tag (zero length)?
@@ -58,7 +62,11 @@
 
 		mov	r5, #4			@ Size of initrd tag (4 words)
 		stmia	r9, {r5, r6, r7, r8, r10}
+/* scott.kernel */
+		mov	pc, r12
+/* scott.kernel 
 		b	kernel_start		@ call kernel
+*/
 
 /*
  * Move the block of memory length r6 from address r4 to address r5
@@ -77,6 +85,10 @@
 data:		.word	initrd_start		@ source initrd address
 		.word	initrd_phys		@ destination initrd address
 		.word	initrd_size		@ initrd size
+/* scott.kernel */
+		.word	kernel_start		@ source kernel address
+		.word	kernel_phys		@ destination kernel address
+		.word	kernel_size		@ kernel size
 
 		.word	0x54410001		@ r5 = ATAG_CORE
 		.word	0x54420005		@ r6 = ATAG_INITRD2
diff -Nur linux-2.6.35.11/arch/arm/boot/bootp/init.S.old linux-2.6.35.11-ts7500//arch/arm/boot/bootp/init.S.old
--- linux-2.6.35.11/arch/arm/boot/bootp/init.S.old	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/bootp/init.S.old	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,86 @@
+/*
+ *  linux/arch/arm/boot/bootp/init.S
+ *
+ *  Copyright (C) 2000-2003 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  "Header" file for splitting kernel + initrd.  Note that we pass
+ *  r0 through to r3 straight through.
+ *
+ *  This demonstrates how to append code to the start of the kernel
+ *  zImage, and boot the kernel without copying it around.  This
+ *  example would be simpler; if we didn't have an object of unknown
+ *  size immediately following the kernel, we could build this into
+ *  a binary blob, and concatenate the zImage using the cat command.
+ */
+		.section .start,#alloc,#execinstr
+		.type	_start, #function
+		.globl	_start
+
+_start:		add	lr, pc, #-0x8		@ lr = current load addr
+		adr	r13, data
+		ldmia	r13!, {r4-r6}		@ r5 = dest, r6 = length
+		add	r4, r4, lr		@ r4 = initrd_start + load addr
+		bl	move			@ move the initrd
+
+/*
+ * Setup the initrd parameters to pass to the kernel.  This can only be
+ * passed in via the tagged list.
+ */
+		ldmia	r13, {r5-r9}		@ get size and addr of initrd
+						@ r5 = ATAG_CORE
+						@ r6 = ATAG_INITRD2
+						@ r7 = initrd start
+						@ r8 = initrd end
+						@ r9 = param_struct address
+
+		ldr	r10, [r9, #4]		@ get first tag
+		teq	r10, r5			@ is it ATAG_CORE?
+/*
+ * If we didn't find a valid tag list, create a dummy ATAG_CORE entry.
+ */
+		movne	r10, #0			@ terminator
+		movne	r4, #2			@ Size of this entry (2 words)
+		stmneia	r9, {r4, r5, r10}	@ Size, ATAG_CORE, terminator
+
+/*
+ * find the end of the tag list, and then add an INITRD tag on the end.
+ * If there is already an INITRD tag, then we ignore it; the last INITRD
+ * tag takes precedence.
+ */
+taglist:	ldr	r10, [r9, #0]		@ tag length
+		teq	r10, #0			@ last tag (zero length)?
+		addne	r9, r9, r10, lsl #2
+		bne	taglist
+
+		mov	r5, #4			@ Size of initrd tag (4 words)
+		stmia	r9, {r5, r6, r7, r8, r10}
+		b	kernel_start		@ call kernel
+
+/*
+ * Move the block of memory length r6 from address r4 to address r5
+ */
+move:		ldmia	r4!, {r7 - r10}		@ move 32-bytes at a time
+		stmia	r5!, {r7 - r10}
+		ldmia	r4!, {r7 - r10}
+		stmia	r5!, {r7 - r10}
+		subs	r6, r6, #8 * 4
+		bcs	move
+		mov	pc, lr
+
+		.size	_start, . - _start
+
+		.type	data,#object
+data:		.word	initrd_start		@ source initrd address
+		.word	initrd_phys		@ destination initrd address
+		.word	initrd_size		@ initrd size
+
+		.word	0x54410001		@ r5 = ATAG_CORE
+		.word	0x54420005		@ r6 = ATAG_INITRD2
+		.word	initrd_phys		@ r7
+		.word	initrd_size		@ r8
+		.word	params_phys		@ r9
+		.size	data, . - data
diff -Nur linux-2.6.35.11/arch/arm/boot/bootp/Makefile linux-2.6.35.11-ts7500//arch/arm/boot/bootp/Makefile
--- linux-2.6.35.11/arch/arm/boot/bootp/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/bootp/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -7,6 +7,7 @@
 
 LDFLAGS_bootp	:=-p --no-undefined -X \
 		 --defsym initrd_phys=$(INITRD_PHYS) \
+ 		 --defsym kernel_phys=$(KERNEL_PHYS) \
 		 --defsym params_phys=$(PARAMS_PHYS) -T
 AFLAGS_initrd.o :=-DINITRD=\"$(INITRD)\"
 
diff -Nur linux-2.6.35.11/arch/arm/boot/compressed/head.S linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head.S
--- linux-2.6.35.11/arch/arm/boot/compressed/head.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head.S	2011-02-26 20:32:46.000000000 -0500
@@ -71,6 +71,21 @@
 		mov	\rb, #0x50000000
 		add	\rb, \rb, #0x4000 * CONFIG_S3C_LOWLEVEL_UART_PORT
 		.endm
+#elif defined(CONFIG_ARCH_STR9100)
+		.macro	loadsp, rb
+		mov	\rb, #0x78000000
+		.endm
+		.macro	writeb, rb
+		strb	\rb, [r3, #0]
+		.endm
+#elif defined(CONFIG_ARCH_STR8100)
+		.macro	loadsp, rb
+		mov	\rb, #0x78000000		
+		.endm      
+		
+		.macro	writeb, rb
+		strb	\rb, [r3, #0]
+		.endm      
 #else
 		.macro	loadsp,	rb, tmp
 		addruart \rb, \tmp
@@ -444,6 +459,15 @@
 		mov	pc, lr
 ENDPROC(__setup_mmu)
 
+
+/* added by ivan wang for no cache support */
+__armv4_no_mmu_cache:
+		orr	r0,r0,#0
+		orr	r0,r0,#0
+		mov	pc,lr
+		orr	r0,r0,#0
+		orr	r0,r0,#0
+
 __armv4_mmu_cache_on:
 		mov	r12, lr
 #ifdef CONFIG_MMU
@@ -530,6 +554,13 @@
 		.align	5			@ cache line aligned
 1:		mcr	p15, 0, r0, c1, c0, 0	@ load control register
 		mrc	p15, 0, r0, c1, c0, 0	@ and read it back to
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+		/* FA520/FA526 need > 2 nops */
+		mov     r0,r0
+		mov     r0,r0
+      mov     r0,r0
+		mov     r0,r0
+#endif      
 		sub	pc, lr, r0, lsr #32	@ properly flush pipeline
 #endif
 
@@ -712,12 +743,13 @@
 		b	__armv5tej_mmu_cache_flush
 #endif
 
+#if (0)
 		.word	0x66015261		@ FA526
 		.word	0xff01fff1
 		W(b)	__fa526_cache_on
 		W(b)	__armv4_mmu_cache_off
 		W(b)	__fa526_cache_flush
-
+#endif
 		@ These match on the architecture ID
 
 		.word	0x00020000		@ ARMv4T
@@ -726,6 +758,18 @@
 		W(b)	__armv4_mmu_cache_off
 		W(b)	__armv4_mmu_cache_flush
 
+#if (1)      
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+		.word	0x66015261		@ FA526, ARMv4
+		.word	0xff01fff1
+		W(b)	__armv4_mmu_cache_on
+      @W(b)	__fa526_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
+      @W(b)	__fa526_cache_flush 
+#endif      
+#endif
+
 		.word	0x00050000		@ ARMv5TE
 		.word	0x000f0000
 		W(b)	__armv4_mmu_cache_on
@@ -801,6 +845,13 @@
 		mrc	p15, 0, r0, c1, c0
 		bic	r0, r0, #0x000d
 		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+		/* FA520/FA526 need > 2 nops */
+		mov	r0,r0
+		mov	r0,r0
+      mov     r0,r0
+		mov     r0,r0
+#endif      
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c7	@ invalidate whole cache v4
 		mcr	p15, 0, r0, c8, c7	@ invalidate whole TLB v4
@@ -970,6 +1021,10 @@
 		mov	r11, #8
 		mov	r11, r11, lsl r3	@ cache line size in bytes
 no_cache_id:
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+		mov	r1,#0
+		mcr	p15, 0, r1, c7, c10, 0	@ clean D cache
+#endif
 		mov	r1, pc
 		bic	r1, r1, #63		@ align to longest cache line
 		add	r2, r1, r2
diff -Nur linux-2.6.35.11/arch/arm/boot/compressed/head-str8100.S linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head-str8100.S
--- linux-2.6.35.11/arch/arm/boot/compressed/head-str8100.S	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head-str8100.S	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,7 @@
+#include <asm/mach-types.h>
+
+		.section	".start", "ax"
+
+__str8100_start:
+		mov	r7, #(MACH_TYPE_STR8100 & 0xFF00)
+		orr	r7, r7, #(MACH_TYPE_STR8100 & 0x00FF)
diff -Nur linux-2.6.35.11/arch/arm/boot/compressed/head-str9100.S linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head-str9100.S
--- linux-2.6.35.11/arch/arm/boot/compressed/head-str9100.S	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/compressed/head-str9100.S	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,7 @@
+#include <asm/mach-types.h>
+
+		.section	".start", "ax"
+
+__str9100_start:
+		mov	r7, #(MACH_TYPE_STR9100 & 0xFF00)
+		orr	r7, r7, #(MACH_TYPE_STR9100 & 0x00FF)
diff -Nur linux-2.6.35.11/arch/arm/boot/compressed/Makefile linux-2.6.35.11-ts7500//arch/arm/boot/compressed/Makefile
--- linux-2.6.35.11/arch/arm/boot/compressed/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/compressed/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -48,6 +48,14 @@
 endif
 endif
 
+ifeq ($(CONFIG_ARCH_STR9100),y)
+OBJS		+= head-str9100.o
+endif
+
+ifeq ($(CONFIG_ARCH_STR8100),y)
+OBJS		+= head-str8100.o
+endif
+
 #
 # We now have a PIC decompressor implementation.  Decompressors running
 # from RAM should not define ZTEXTADDR.  Decompressors running directly
diff -Nur linux-2.6.35.11/arch/arm/boot/compressed/misc.c linux-2.6.35.11-ts7500//arch/arm/boot/compressed/misc.c
--- linux-2.6.35.11/arch/arm/boot/compressed/misc.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/compressed/misc.c	2011-02-26 20:32:46.000000000 -0500
@@ -101,8 +101,11 @@
 #endif
 
 #define putc(ch)	icedcc_putc(ch)
+#define flush()	do { } while (0)
 #endif
 
+#if defined(CONFIG_ARCH_STR8100) || defined(CONFIG_ARCH_STR9100)
+#else
 static void putstr(const char *ptr)
 {
 	char c;
@@ -115,6 +118,7 @@
 
 	flush();
 }
+#endif
 
 #endif
 
@@ -188,24 +192,38 @@
 
 #ifndef STANDALONE_DEBUG
 
+
 unsigned long
 decompress_kernel(unsigned long output_start, unsigned long free_mem_ptr_p,
 		unsigned long free_mem_ptr_end_p,
 		int arch_id)
 {
+  extern void *foobar(int);
 	unsigned char *tmp;
 
 	output_data		= (unsigned char *)output_start;
 	free_mem_ptr		= free_mem_ptr_p;
 	free_mem_end_ptr	= free_mem_ptr_end_p;
 	__machine_arch_type	= arch_id;
-
+      
+     
+   //putstr("\n\rfree_mem_ptr =        0x"); ser_puts_hex32((unsigned long)free_mem_ptr);
+   //putstr("\n\rfree_mem_end_ptr =    0x"); ser_puts_hex32((unsigned long)free_mem_end_ptr);
+   //putstr("\n\r__machine_arch_type = 0x"); ser_puts_hex32((unsigned long)__machine_arch_type);
+   //putstr("\n\r");
+   
 	arch_decomp_setup();
 
 	tmp = (unsigned char *) (((unsigned long)input_data_end) - 4);
 	output_ptr = get_unaligned_le32(tmp);
 
 	putstr("Uncompressing Linux...");
+   
+   //putstr("\n\rinput_data =        0x"); ser_puts_hex32((unsigned long)input_data);
+   //putstr("\n\rinput_data_end =    0x"); ser_puts_hex32((unsigned long)input_data_end);
+   //putstr("\n\routput_data =       0x"); ser_puts_hex32((unsigned long)output_data);
+   //putstr("\n\r");
+   
 	do_decompress(input_data, input_data_end - input_data,
 			output_data, error);
 	putstr(" done, booting the kernel.\n");
diff -Nur linux-2.6.35.11/arch/arm/boot/Makefile linux-2.6.35.11-ts7500//arch/arm/boot/Makefile
--- linux-2.6.35.11/arch/arm/boot/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/boot/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -24,8 +24,10 @@
 ZRELADDR    := $(zreladdr-y)
 PARAMS_PHYS := $(params_phys-y)
 INITRD_PHYS := $(initrd_phys-y)
+# scott.kernel
+KERNEL_PHYS := $(kernel_phys-y)
 
-export ZRELADDR INITRD_PHYS PARAMS_PHYS
+export ZRELADDR INITRD_PHYS KERNEL_PHYS PARAMS_PHYS
 
 targets := Image zImage xipImage bootpImage uImage
 
diff -Nur linux-2.6.35.11/arch/arm/configs/ts7500_defconfig linux-2.6.35.11-ts7500//arch/arm/configs/ts7500_defconfig
--- linux-2.6.35.11/arch/arm/configs/ts7500_defconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/configs/ts7500_defconfig	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,1423 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.36
+# Wed Nov 10 09:28:19 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_STR9100 is not set
+CONFIG_ARCH_STR8100=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_S5PV310 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_CONSOLE_BAUD_RATE=115200
+
+#
+# STR8100 Options
+#
+CONFIG_VIC_INTERRUPT=y
+# CONFIG_STR8100_DRAM_16M is not set
+# CONFIG_STR8100_DRAM_32M is not set
+CONFIG_STR8100_DRAM_64M=y
+CONFIG_STR8100_PCI33M=y
+# CONFIG_STR8100_PCI66M is not set
+# CONFIG_STR8100_DMA is not set
+# CONFIG_STR8100_HSDMA is not set
+CONFIG_STR8100_INFO=y
+# CONFIG_STR8100_USBD_REBOOT_INTHANDLER is not set
+# CONFIG_STR8100_I2S is not set
+# CONFIG_STR8100_I2S_DEMO is not set
+# CONFIG_STR8100_I2S_WM8772_DEMO is not set
+# CONFIG_LE88221_CONTROL is not set
+# CONFIG_STR8100_PCM_LEGERITY_2PHONE_DEMO is not set
+# CONFIG_STR8100_RTC is not set
+CONFIG_STR8100_GPIO=y
+CONFIG_STR8100_GPIO_INTERRUPT=y
+# CONFIG_STR8100_GPIO_GENERIC_INTERFACE is not set
+
+#
+# Flash MAP
+#
+# CONFIG_STR8100_FLASH_PART is not set
+
+#
+# Third Party Support
+#
+# CONFIG_STR8100_EWC_SUPPORT is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_FA526=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_CACHE_FA=y
+CONFIG_CPU_COPY_FA=y
+CONFIG_CPU_TLB_FA=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+CONFIG_CPU_FA_BTB=y
+# CONFIG_CPU_FA_WB_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_SPARSE_IRQ is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram0 init=/linuxrc lpj=958464 console=null"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=m
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# The newer stack is recommended.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_FAST_BRIDGE is not set
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+CONFIG_CHELSIO_T3_DEPENDS=y
+# CONFIG_CHELSIO_T3 is not set
+CONFIG_CHELSIO_T4_DEPENDS=y
+# CONFIG_CHELSIO_T4 is not set
+CONFIG_CHELSIO_T4VF_DEPENDS=y
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+
+#
+# CNS2100 NIC support
+#
+CONFIG_STAR_NIC=y
+CONFIG_STAR_NIC_PHY_INTERNAL_PHY=y
+# CONFIG_STAR_NIC_PHY_VSC8601 is not set
+# CONFIG_STAR_NIC_PHY_IP101A is not set
+# CONFIG_STAR_NIC_PHY_IP1001 is not set
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=m
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=m
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=m
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=m
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=m
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_CTSRTS is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_STR8100=y
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_AB8500_CORE is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGA_ARB is not set
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX_FF is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CANDO is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EGALAX is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_SSB is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_R8A66597=y
+CONFIG_USB_R8A66597=m
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT2_FS_XIP=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_FS_XIP=y
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
diff -Nur linux-2.6.35.11/arch/arm/include/asm/page.h linux-2.6.35.11-ts7500//arch/arm/include/asm/page.h
--- linux-2.6.35.11/arch/arm/include/asm/page.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/include/asm/page.h	2011-02-26 20:32:46.000000000 -0500
@@ -84,6 +84,17 @@
 # endif
 #endif
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+#ifdef CONFIG_CPU_COPY_FA
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER fa
+# endif
+#endif
+#endif
+
+
 #ifdef CONFIG_CPU_SA1100
 # ifdef _USER
 #  define MULTI_USER 1
diff -Nur linux-2.6.35.11/arch/arm/include/asm/pci.h linux-2.6.35.11-ts7500//arch/arm/include/asm/pci.h
--- linux-2.6.35.11/arch/arm/include/asm/pci.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/include/asm/pci.h	2011-02-26 20:32:46.000000000 -0500
@@ -75,6 +75,16 @@
 	return 0;
 }
 
+
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+#define HAVE_ARCH_PCI_MWI
+static inline int pcibios_prep_mwi(struct pci_dev *dev)
+{
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x08);
+	return 0;
+}
+#endif
+
 #endif /* __KERNEL__ */
  
 #endif
diff -Nur linux-2.6.35.11/arch/arm/include/asm/tlbflush.h linux-2.6.35.11-ts7500//arch/arm/include/asm/tlbflush.h
--- linux-2.6.35.11/arch/arm/include/asm/tlbflush.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/include/asm/tlbflush.h	2011-02-26 20:32:46.000000000 -0500
@@ -39,7 +39,7 @@
 #define TLB_V6_D_ASID	(1 << 17)
 #define TLB_V6_I_ASID	(1 << 18)
 
-#define TLB_BTB		(1 << 28)
+//#define TLB_BTB		(1 << 28)
 
 /* Unified Inner Shareable TLB operations (ARMv7 MP extensions) */
 #define TLB_V7_UIS_PAGE	(1 << 19)
@@ -53,6 +53,12 @@
 #define TLB_DCLEAN	(1 << 30)
 #define TLB_WB		(1 << 31)
 
+
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+#define TLB_DINVAL	(1 << 28)
+#define TLB_BTB		(1 << 29)
+#endif
+
 /*
  *	MMU TLB Model
  *	=============
@@ -100,6 +106,29 @@
 # define v4_always_flags	(-1UL)
 #endif
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+#ifdef CONFIG_CPU_FA_BTB
+#define __TLB_BTB      TLB_BTB
+#else
+#define __TLB_BTB      0
+#endif
+
+#ifdef CONFIG_CPU_FA_WB_DISABLE
+#define __TLB_WB       0
+#else
+#define __TLB_WB       TLB_WB
+#endif
+
+/* Fix buggy CPU which doesn't invalidate Dcache properly */
+#ifdef CONFIG_CPU_FA520
+#define __TLB_DINVAL   TLB_DINVAL
+#elif defined(CONFIG_CPU_FA526)
+//#define __TLB_DINVAL   TLB_DINVAL
+#define __TLB_DINVAL   0
+#else
+#define __TLB_DINVAL   0
+#endif
+
 #define fa_tlb_flags	(TLB_WB | TLB_BTB | TLB_DCLEAN | \
 			 TLB_V4_U_FULL | TLB_V4_U_PAGE)
 
@@ -115,6 +144,7 @@
 # define fa_possible_flags	0
 # define fa_always_flags	(-1UL)
 #endif
+#endif
 
 #define v4wbi_tlb_flags	(TLB_WB | TLB_DCLEAN | \
 			 TLB_V4_I_FULL | TLB_V4_D_FULL | \
@@ -297,24 +327,36 @@
  * implemented the "%?" method, but this has been discontinued due to too
  * many people getting it wrong.
  */
-#define possible_tlb_flags	(v3_possible_flags | \
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+#define possible_tlb_flags      (v3_possible_flags | \
 				 v4_possible_flags | \
 				 v4wbi_possible_flags | \
-				 fr_possible_flags | \
 				 v4wb_possible_flags | \
 				 fa_possible_flags | \
-				 v6wbi_possible_flags | \
-				 v7wbi_possible_flags)
+				 v6wbi_possible_flags)
+#else
+#define possible_tlb_flags	(v3_possible_flags | \
+				 v4_possible_flags | \
+				 v4wbi_possible_flags | \
+				 v4wb_possible_flags | \
+				 v6wbi_possible_flags)
+#endif
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
 #define always_tlb_flags	(v3_always_flags & \
 				 v4_always_flags & \
 				 v4wbi_always_flags & \
-				 fr_always_flags & \
 				 v4wb_always_flags & \
 				 fa_always_flags & \
-				 v6wbi_always_flags & \
-				 v7wbi_always_flags)
-
+				 v6wbi_always_flags)
+#else
+#define always_tlb_flags	(v3_always_flags & \
+				 v4_always_flags & \
+				 v4wbi_always_flags & \
+				 v4wb_always_flags & \
+				 v6wbi_always_flags)
+#endif
+             
 #define tlb_flag(f)	((always_tlb_flags & (f)) || (__tlb_flag & possible_tlb_flags & (f)))
 
 static inline void local_flush_tlb_all(void)
@@ -322,6 +364,11 @@
 	const int zero = 0;
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_DINVAL))
+		asm("mcr%? p15, 0, %0, c7, c14, 0" : : "r" (zero) : "cc");
+#endif   
+   
 	if (tlb_flag(TLB_WB))
 		dsb();
 
@@ -333,9 +380,28 @@
 		asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
 	if (tlb_flag(TLB_V4_I_FULL | TLB_V6_I_FULL))
 		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
-	if (tlb_flag(TLB_V7_UIS_FULL))
-		asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_BTB)) {
+		asm("mcr%? p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		asm("mov r0, r0" : : );
+		asm("mov r0, r0" : : );
+	}
+#endif
+
+//	if (tlb_flag(TLB_V7_UIS_FULL))
+	//	asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
+   
+   if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+		isb();
+	}
+
+#if (0)   
 	if (tlb_flag(TLB_BTB)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
@@ -348,6 +414,7 @@
 		dsb();
 		isb();
 	}
+#endif   
 }
 
 static inline void local_flush_tlb_mm(struct mm_struct *mm)
@@ -356,6 +423,11 @@
 	const int asid = ASID(mm);
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_DINVAL))
+		asm("mcr%? p15, 0, %0, c7, c14, 0" : : "r" (zero) : "cc");
+#endif
+
 	if (tlb_flag(TLB_WB))
 		dsb();
 
@@ -395,6 +467,7 @@
 		dsb();
 		isb();
 	}
+
 }
 
 static inline void
@@ -404,7 +477,12 @@
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
 
 	uaddr = (uaddr & PAGE_MASK) | ASID(vma->vm_mm);
-
+   
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_DINVAL))
+		asm("mcr%? p15, 0, %0, c7, c14, 0" : : "r" (zero) : "cc"); // clean & invalidate data cache all
+#endif
+   
 	if (tlb_flag(TLB_WB))
 		dsb();
 
@@ -445,6 +523,7 @@
 		dsb();
 		isb();
 	}
+
 }
 
 static inline void local_flush_tlb_kernel_page(unsigned long kaddr)
@@ -454,6 +533,11 @@
 
 	kaddr &= PAGE_MASK;
 
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_DINVAL))
+		asm("mcr%? p15, 0, %0, c7, c14, 0" : : "r" (zero) : "cc");
+#endif
+
 	if (tlb_flag(TLB_WB))
 		dsb();
 
@@ -474,9 +558,28 @@
 		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (kaddr) : "cc");
 	if (tlb_flag(TLB_V6_I_PAGE))
 		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (kaddr) : "cc");
-	if (tlb_flag(TLB_V7_UIS_PAGE))
-		asm("mcr p15, 0, %0, c8, c3, 1" : : "r" (kaddr) : "cc");
+   
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_BTB)) {
+		asm("mcr%? p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		asm("mov r0, r0" : : );
+		asm("mov r0, r0" : : );
+	}
+#endif
 
+	//if (tlb_flag(TLB_V7_UIS_PAGE))
+		//asm("mcr p15, 0, %0, c8, c3, 1" : : "r" (kaddr) : "cc");
+      
+      if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+		isb();
+	}
+   
+#if (0)
 	if (tlb_flag(TLB_BTB)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
@@ -489,6 +592,7 @@
 		dsb();
 		isb();
 	}
+#endif   
 }
 
 /*
@@ -507,30 +611,53 @@
 static inline void flush_pmd_entry(pmd_t *pmd)
 {
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
+   const int zero = 0;
 
 	if (tlb_flag(TLB_DCLEAN))
 		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
 			: : "r" (pmd) : "cc");
 
+/*         
 	if (tlb_flag(TLB_L2CLEAN_FR))
 		asm("mcr	p15, 1, %0, c15, c9, 1  @ L2 flush_pmd"
 			: : "r" (pmd) : "cc");
-
+*/
 	if (tlb_flag(TLB_WB))
 		dsb();
+   
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_BTB)) {
+		asm("mcr%? p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		asm("mov r0, r0" : : );
+		asm("mov r0, r0" : : );
+	}
+#endif
+
 }
 
 static inline void clean_pmd_entry(pmd_t *pmd)
 {
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	const unsigned int zero = 0;
+#endif
 
 	if (tlb_flag(TLB_DCLEAN))
 		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
 			: : "r" (pmd) : "cc");
-
+/*
 	if (tlb_flag(TLB_L2CLEAN_FR))
 		asm("mcr	p15, 1, %0, c15, c9, 1  @ L2 flush_pmd"
 			: : "r" (pmd) : "cc");
+*/
+
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	if (tlb_flag(TLB_BTB)) {
+		asm("mcr%? p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		asm("mov r0, r0" : : );
+		asm("mov r0, r0" : : );
+	}
+#endif         
 }
 
 #undef tlb_flag
@@ -571,4 +698,5 @@
 
 #endif /* CONFIG_MMU */
 
-#endif
+#endif /* _ASMARM_TLBFLUSH_H */
+
diff -Nur linux-2.6.35.11/arch/arm/Kconfig linux-2.6.35.11-ts7500//arch/arm/Kconfig
--- linux-2.6.35.11/arch/arm/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -160,7 +160,8 @@
 
 config ZONE_DMA
 	bool
-
+   default y if !ARCH_STR8100
+	
 config NEED_DMA_MAP_STATE
        def_bool y
 
@@ -210,6 +211,20 @@
 	prompt "ARM system type"
 	default ARCH_VERSATILE
 
+config ARCH_STR9100
+	bool "Star-STR9100"
+	select PCI
+	help
+	  Star STR9100 is a platform based on Faraday's ARM9 compatible processor
+	  architecture.
+
+config ARCH_STR8100
+	bool "Star-STR8100"
+	select PCI
+	help
+	  Star STR8100 is a platform based on Faraday's ARM9 compatible processor
+	  architecture.
+     
 config ARCH_AAEC2000
 	bool "Agilent AAEC-2000 based"
 	select CPU_ARM920T
@@ -901,6 +916,14 @@
 
 source "arch/arm/mach-s5pc100/Kconfig"
 
+if ARCH_STR9100
+source "arch/arm/mach-str9100/Kconfig"
+endif
+
+if ARCH_STR8100
+source "arch/arm/mach-str8100/Kconfig"
+endif
+
 source "arch/arm/mach-s5pv210/Kconfig"
 
 source "arch/arm/mach-shmobile/Kconfig"
diff -Nur linux-2.6.35.11/arch/arm/kernel/bios32.c linux-2.6.35.11-ts7500//arch/arm/kernel/bios32.c
--- linux-2.6.35.11/arch/arm/kernel/bios32.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/bios32.c	2011-02-26 20:32:46.000000000 -0500
@@ -360,7 +360,7 @@
  * pcibios_fixup_bus - Called after each bus is probed,
  * but before its children are examined.
  */
-void pcibios_fixup_bus(struct pci_bus *bus)
+void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
 	struct pci_sys_data *root = bus->sysdata;
 	struct pci_dev *dev;
diff -Nur linux-2.6.35.11/arch/arm/kernel/entry-armv.S linux-2.6.35.11-ts7500//arch/arm/kernel/entry-armv.S
--- linux-2.6.35.11/arch/arm/kernel/entry-armv.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/entry-armv.S	2011-02-26 20:32:46.000000000 -0500
@@ -30,6 +30,11 @@
  */
 	.macro	irq_handler
 	get_irqnr_preamble r5, lr
+#ifdef CONFIG_VIC_INTERRUPT
+	get_irqnr_and_base r0, r6, r5, lr
+	mov	r1, sp
+	bl	asm_do_IRQ
+#else   
 1:	get_irqnr_and_base r0, r6, r5, lr
 	movne	r1, sp
 	@
@@ -37,6 +42,7 @@
 	@
 	adrne	lr, BSYM(1b)
 	bne	asm_do_IRQ
+#endif
 
 #ifdef CONFIG_SMP
 	/*
diff -Nur linux-2.6.35.11/arch/arm/kernel/head-common.S linux-2.6.35.11-ts7500//arch/arm/kernel/head-common.S
--- linux-2.6.35.11/arch/arm/kernel/head-common.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/head-common.S	2011-02-26 20:32:46.000000000 -0500
@@ -39,6 +39,16 @@
  *  r9  = processor ID
  */
 __mmap_switched:
+
+# We come here right after the MMU is enabled
+
+#ifdef CONFIG_DEBUG_LL
+@   stmfd sp!, {r0, r1, r2, r3, r9, lr}
+@   adr	r0, str_mmap_switched
+@	bl	printascii
+@   ldmfd sp!, {r0, r1, r2, r3, r9, lr}
+#endif
+
 	adr	r3, __switch_data + 4
 
 	ldmia	r3!, {r4, r5, r6, r7}
@@ -53,6 +63,7 @@
 	strcc	fp, [r6],#4
 	bcc	1b
 
+   
  ARM(	ldmia	r3, {r4, r5, r6, r7, sp})
  THUMB(	ldmia	r3, {r4, r5, r6, r7}	)
  THUMB(	ldr	sp, [r3, #16]		)
@@ -61,7 +72,23 @@
 	str	r2, [r6]			@ Save atags pointer
 	bic	r4, r0, #CR_A			@ Clear 'A' bit
 	stmia	r7, {r0, r4}			@ Save control register values
+   
+#ifdef CONFIG_DEBUG_LL
+   stmfd sp!, {r0, r1, r2, r3, r9, lr}
+   adr	r0, str_mmap_switched_done
+	bl	printascii
+   ldmfd sp!, {r0, r1, r2, r3, r9, lr}
+#endif
+
+
 	b	start_kernel
+
+#ifdef CONFIG_DEBUG_LL
+str_mmap_switched: .asciz "str_mmap_switched\n"   
+str_mmap_switched_done: .asciz "str_mmap_switched_done\n"
+.align 4
+#endif   
+   
 ENDPROC(__mmap_switched)
 
 /*
@@ -74,7 +101,7 @@
  * machine ID for example).
  */
 __error_p:
-#ifdef CONFIG_DEBUG_LL
+#ifdef CONFIG_DEBUG_LL   
 	adr	r0, str_p1
 	bl	printascii
 	mov	r0, r9
diff -Nur linux-2.6.35.11/arch/arm/kernel/head.S linux-2.6.35.11-ts7500//arch/arm/kernel/head.S
--- linux-2.6.35.11/arch/arm/kernel/head.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/head.S	2011-02-26 20:32:46.000000000 -0500
@@ -22,6 +22,10 @@
 #include <asm/thread_info.h>
 #include <asm/system.h>
 
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+//#define PROCINFO_INITFUNC	12
+#endif
+
 #if (PHYS_OFFSET & 0x001fffff)
 #error "PHYS_OFFSET must be at an even 2MiB boundary!"
 #endif
@@ -78,16 +82,75 @@
 ENTRY(stext)
 	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9 @ ensure svc mode
 						@ and irqs disabled
+
+                       
+#ifdef CONFIG_DEBUG_LL
+   stmfd sp!, {r0, r1, r2}
+   mov r6, r1   
+   adr	r0, str_kernel_start
+	bl	printascii
+   adr   r0, str_machine_id
+   bl	printascii
+   mov r0, r6
+   bl printhex8
+   mov r0, #'\n'
+   bl printch
+   ldmfd sp!, {r0, r1, r2}
+#endif
+                  
 	mrc	p15, 0, r9, c0, c0		@ get processor id
+   
+#ifdef CONFIG_DEBUG_LL
+   stmfd sp!, {r0, r1, r2}  
+   adr	r0, str_processor_id
+	bl	printascii
+   mov r0, r9
+   bl printhex8
+   mov r0, #'\n'
+   bl printch
+   ldmfd sp!, {r0, r1, r2}
+#endif   
+   
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
 	beq	__error_p			@ yes, error 'p'
 	bl	__lookup_machine_type		@ r5=machinfo
 	movs	r8, r5				@ invalid machine (r5=0)?
-	beq	__error_a			@ yes, error 'a'
+	beq	__error_a			@ yes, error 'a'   
 	bl	__vet_atags
 	bl	__create_page_tables
 
+   
+###########################
+
+	mov	ip, #0	
+	mcr	p15, 0, ip, c7,c14, 2		@ clean/flush D-cache
+	mcr	p15, 0, ip, c7, c10, 4		@ drain write buffer
+	mcr	p15, 0, ip, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+   nop 
+   nop
+   
+#################################
+   
+#ifdef CONFIG_DEBUG_LL
+   stmfd sp!, {r0, r1, r2}  
+   adr	r0, str_procinfo_at
+	bl	printascii
+   mov r0, r10
+   bl printhex8
+   mov r0, #'\n'   
+   bl printch
+   adr	r0, str_initfunc_offset
+	bl	printascii
+   mov r0, #PROCINFO_INITFUNC
+   bl printhex8
+   mov r0, #'\n'   
+   bl printch
+   ldmfd sp!, {r0, r1, r2}
+#endif      
+   
 	/*
 	 * The following calls CPU specific code in a position independent
 	 * manner.  See arch/arm/mm/proc-*.S for details.  r10 = base of
@@ -101,6 +164,15 @@
  ARM(	add	pc, r10, #PROCINFO_INITFUNC	)
  THUMB(	add	r12, r10, #PROCINFO_INITFUNC	)
  THUMB(	mov	pc, r12				)
+
+#ifdef CONFIG_DEBUG_LL
+str_kernel_start: .asciz "kernel_start\n"   
+str_machine_id: .asciz "machine ID: 0x"
+str_processor_id: .asciz "processor ID: 0x"
+str_procinfo_at:  .asciz "procinfo at:  0x"
+str_initfunc_offset:  .asciz "PROCINFO_INITFUNC:  0x"
+.align 4
+#endif   
 ENDPROC(stext)
 
 #if defined(CONFIG_SMP)
@@ -158,6 +230,13 @@
  * registers.
  */
 __enable_mmu:
+#ifdef CONFIG_DEBUG_LL
+@   stmfd sp!, {r0, r1, r2, r3, r6, r13, lr}
+@   adr	r0, str_enable_mmu
+@	bl	printascii
+@   ldmfd sp!, {r0, r1, r2, r3, r6, r13, lr}
+#endif
+
 #ifdef CONFIG_ALIGNMENT_TRAP
 	orr	r0, r0, #CR_A
 #else
@@ -179,6 +258,12 @@
 	mcr	p15, 0, r5, c3, c0, 0		@ load domain access register
 	mcr	p15, 0, r4, c2, c0, 0		@ load page table pointer
 	b	__turn_mmu_on
+   
+#ifdef CONFIG_DEBUG_LL   
+str_enable_mmu: .asciz "__enable_mmu\n"
+str_enable_mmu_done: .asciz "__enable_mmu done\n"
+.align 4
+#endif
 ENDPROC(__enable_mmu)
 
 /*
@@ -196,10 +281,19 @@
 __turn_mmu_on:
 	mov	r0, r0
 	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
+#if defined(CONFIG_CPU_FA520) || defined(CONFIG_CPU_FA526) || defined(CONFIG_CPU_FA626)
+	nop
+	nop
+	nop
+	nop
+#endif   
 	mrc	p15, 0, r3, c0, c0, 0		@ read id reg
+   
 	mov	r3, r3
-	mov	r3, r13
+   mov	r3, r3
+	mov	r3, r13   
 	mov	pc, r3
+   
 ENDPROC(__turn_mmu_on)
 
 
@@ -217,6 +311,12 @@
  *  r4 = physical page table address
  */
 __create_page_tables:
+#ifdef CONFIG_DEBUG_LL
+   mov r6, lr
+   adr	r0, str_create_page_tables
+	bl	printascii
+   mov lr, r6
+#endif
 	pgtbl	r4				@ page table address
 
 	/*
@@ -281,14 +381,15 @@
 	/*
 	 * Then map first 1MB of ram in case it contains our boot params.
 	 */
-	add	r0, r4, #PAGE_OFFSET >> 18
+	add	r0, r4, #PAGE_OFFSET >> 18   
 	orr	r6, r7, #(PHYS_OFFSET & 0xff000000)
 	.if	(PHYS_OFFSET & 0x00f00000)
 	orr	r6, r6, #(PHYS_OFFSET & 0x00f00000)
 	.endif
 	str	r6, [r0]
 
-#ifdef CONFIG_DEBUG_LL
+@#if defined(CONFIG_DEBUG_LL) || defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+#if defined(CONFIG_DEBUG_LL)
 	ldr	r7, [r10, #PROCINFO_IO_MMUFLAGS] @ io_mmuflags
 	/*
 	 * Map in IO space for serial debugging.
@@ -329,7 +430,20 @@
 	str	r3, [r0]
 #endif
 #endif
+
+#ifdef CONFIG_DEBUG_LL
+   mov r6, lr
+   adr	r0, str_create_page_tables_done
+	bl	printascii
+   mov lr, r6
+#endif
+
 	mov	pc, lr
+#ifdef CONFIG_DEBUG_LL
+str_create_page_tables: .asciz "create_page_tables\n"   
+str_create_page_tables_done: .asciz "create_page_tables_done\n"
+.align 4
+#endif
 ENDPROC(__create_page_tables)
 	.ltorg
 
diff -Nur linux-2.6.35.11/arch/arm/kernel/process.c linux-2.6.35.11-ts7500//arch/arm/kernel/process.c
--- linux-2.6.35.11/arch/arm/kernel/process.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/process.c	2011-02-26 20:32:46.000000000 -0500
@@ -126,9 +126,17 @@
  */
 static void default_idle(void)
 {
+#ifndef CONFIG_CPU_FA_IDLE
+                local_irq_disable();
+#endif
+
 	if (!need_resched())
 		arch_idle();
-	local_irq_enable();
+//	local_irq_enable();
+#ifndef CONFIG_CPU_FA_IDLE
+        local_irq_enable();
+#endif
+
 }
 
 void (*pm_idle)(void) = default_idle;
diff -Nur linux-2.6.35.11/arch/arm/kernel/setup.c linux-2.6.35.11-ts7500//arch/arm/kernel/setup.c
--- linux-2.6.35.11/arch/arm/kernel/setup.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/setup.c	2011-02-26 20:32:46.000000000 -0500
@@ -370,6 +370,7 @@
 {
 	struct machine_desc *list;
 
+   //printk("setup_machine()\n");
 	/*
 	 * locate machine in the list of supported machines.
 	 */
@@ -656,6 +657,7 @@
 
 static int __init customize_machine(void)
 {
+   printk("customize_machine(), calling init_machine()\n");
 	/* customizes platform devices, or adds new ones */
 	if (init_machine)
 		init_machine();
@@ -667,8 +669,10 @@
 {
 	struct tag *tags = (struct tag *)&init_tags;
 	struct machine_desc *mdesc;
-	char *from = default_command_line;
+	char *from = default_command_line;               
 
+   //printk("setup_arch()\n");
+   
 	unwind_init();
 
 	setup_processor();
@@ -726,6 +730,22 @@
 	cpu_init();
 	tcm_init();
 
+#ifdef CONFIG_ARCH_STR9100
+	{
+		extern void __init str9100_early_init(void);
+
+		str9100_early_init();
+	}
+#endif
+
+#ifdef CONFIG_ARCH_STR8100
+	{
+		extern void __init str8100_early_init(void);
+
+		str8100_early_init();
+	}
+#endif   
+   
 	/*
 	 * Set up various architecture-specific pointers
 	 */
@@ -760,9 +780,11 @@
 
 #ifdef CONFIG_HAVE_PROC_CPU
 static int __init proc_cpu_init(void)
-{
+{   
 	struct proc_dir_entry *res;
 
+   printk("proc_cpu_init()\n");
+   
 	res = proc_mkdir("cpu", NULL);
 	if (!res)
 		return -ENOMEM;
diff -Nur linux-2.6.35.11/arch/arm/kernel/traps.c linux-2.6.35.11-ts7500//arch/arm/kernel/traps.c
--- linux-2.6.35.11/arch/arm/kernel/traps.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/traps.c	2011-02-26 20:32:46.000000000 -0500
@@ -467,7 +467,7 @@
 {
 	struct thread_info *thread = current_thread_info();
 	siginfo_t info;
-
+	
 	if ((no >> 16) != (__ARM_NR_BASE>> 16))
 		return bad_syscall(no, regs);
 
diff -Nur linux-2.6.35.11/arch/arm/kernel/vmlinux.lds.S linux-2.6.35.11-ts7500//arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.35.11/arch/arm/kernel/vmlinux.lds.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/kernel/vmlinux.lds.S	2011-02-26 20:32:46.000000000 -0500
@@ -84,6 +84,12 @@
 
 	.text : {			/* Real text segment		*/
 		_text = .;		/* Text and read-only data	*/
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+			. = ALIGN(1024);
+			__ispad_begin = .;
+			*(.ispad)
+			__ispad_end = .;
+#endif      
 			__exception_text_start = .;
 			*(.exception.text)
 			__exception_text_end = .;
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/debug-macro.S linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/debug-macro.S
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/debug-macro.S	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/debug-macro.S	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,54 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//#include <linux/config.h>
+#include <linux/linkage.h>
+#include <mach/hardware.h>
+
+		.macro	addruart,rx,tmp
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1				@ MMU enabled ?
+		moveq	\rx, #(SYSPA_UART0_BASE_ADDR)	@ physical base address of UART0
+		movne	\rx, #(SYSVA_UART0_BASE_ADDR & 0xFF000000) @ virtual base address of UART0
+		orrne	\rx, \rx, #(SYSVA_UART0_BASE_ADDR & 0x00FF0000)
+		orrne	\rx, \rx, #(SYSVA_UART0_BASE_ADDR & 0x0000FF00)
+		orrne	\rx, \rx, #(SYSVA_UART0_BASE_ADDR & 0x000000FF)
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx, #0x00]
+		.endm
+
+		.macro	waituart,rd,rx
+		mov	\rd, #0xf000
+1001:		subs	\rd, \rd, #1
+		bne	1001b	
+		.endm
+
+		.macro	busyuart,rd,rx
+		nop
+		mov	\rd, #0xf000
+1010:		subs	\rd, \rd, #1
+		bne	1010b
+		.endm
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/dma.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/dma.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/dma.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/dma.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_DMA_H__
+#define __ASM_ARCH_DMA_H__
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/entry-macro.S linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/entry-macro.S
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/entry-macro.S	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/entry-macro.S	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//#include <mach/star_intc.h>
+#include <mach/star_intc.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
+
+
+#ifdef CONFIG_VIC_INTERRUPT
+	.macro	get_fiqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(SYSVA_VIC_BASE_ADDR + 0x140)
+	ldr	\irqnr, [\base]
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(SYSVA_VIC_BASE_ADDR + 0x140)
+	ldr	\irqnr, [\base]
+	.endm
+#else
+	.macro	get_fiqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(SYSVA_VIC_BASE_ADDR + 0x20)
+	ldr	\irqstat, [\base]
+	mov	\irqnr, #0
+9001:
+	tst	\irqstat, #1
+	bne	9002f
+	add	\irqnr, \irqnr, #1
+	mov	\irqstat, \irqstat, lsr #1
+	cmp	\irqnr, #32
+	bcc	9001b
+9002:
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(SYSVA_VIC_BASE_ADDR + 0x1C)
+	ldr	\irqstat, [\base]
+	mov	\irqnr, #0
+9003:
+	tst	\irqstat, #1
+	bne	9004f
+	add	\irqnr, \irqnr, #1
+	mov	\irqstat, \irqstat, lsr #1
+	cmp	\irqnr, #32
+	bcc	9003b
+9004:
+	.endm
+#endif
+
+	.macro	irq_prio_table
+	.endm
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/hardware.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/hardware.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/hardware.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#define __ASM_ARCH_HARDWARE_H__
+
+//#include <linux/config.h>
+#include <mach/param.h>
+
+#include <mach/star_sys_memory_map.h>
+#include <mach/star_intc.h>
+#include <mach/star_timer.h>
+#include <mach/star_uart.h>
+#include <mach/star_gpio.h>
+#include <mach/star_pci_bridge.h>
+#include <mach/star_misc.h>
+#include <mach/star_powermgt.h>
+#include <mach/star_rtc.h>
+#include <mach/star_wdtimer.h>
+#include <mach/star_smc.h>
+#include <mach/star_nic.h>
+#include <mach/star_ide.h>
+
+#if 1 // on ASIC
+#define SYS_CLK			(87500000) // 87.5MHz
+#define UART_CLK		(24000000) // 24MHz
+#define AHB_CLK			(SYS_CLK)
+#define APB_CLK			(AHB_CLK >> 1)
+#define TIMER_COUNTER		(APB_CLK / HZ)
+#else // on FPGA
+#define SYS_CLK			(13000000) // 13MHz
+#define UART_CLK		(13000000) // 13Mhz
+#define AHB_CLK			(SYS_CLK)
+#define APB_CLK			(AHB_CLK)
+#define TIMER_COUNTER		(APB_CLK / HZ)
+#endif
+
+#define DEBUG_CONSOLE		(0)
+
+#define FLASH_BASE_ADDR		SYSPA_FLASH_SRAM_BANK0_BASE_ADDR
+#define FLASH_SIZE		0x800000
+
+#define PCIBIOS_MIN_IO		0x00000000
+#define PCIBIOS_MIN_MEM		0x00000000
+#if 1
+#define pcibios_assign_all_busses()	0
+#else
+#define pcibios_assign_all_busses()	1
+#endif
+
+#endif /* __ASM_ARCH_HARDWARE_H__ */
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/io.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/io.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/io.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/io.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_IO_H__
+#define __ASM_ARCH_IO_H__
+
+//#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT		0xffffffff
+
+#define __io(p)			((void __iomem *)(p))
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/irqs.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/irqs.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/irqs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/irqs.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+
+//#include <mach/star_intc.h>
+#include <mach/star_intc.h>
+
+#define NR_IRQS (32)
+
+#ifdef CONFIG_VIC_INTERRUPT 
+#define irq_finish(irq) do { INTC_IRQ_VECTOR_ADDRESS_REG = 0; } while (0)
+#endif
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/memory.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/memory.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/memory.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/memory.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#if 0
+#define TASK_SIZE		(0xC0000000UL)	
+#define TASK_SIZE_26		(0x04000000UL)
+#define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#endif
+
+#define CONFIG_SYSTEM_DRAM_BASE	0x00000000
+#if defined(CONFIG_STR8100_DRAM_64M)
+#define CONFIG_SYSTEM_DRAM_SIZE 64
+#elif defined(CONFIG_STR8100_DRAM_32M)
+#define CONFIG_SYSTEM_DRAM_SIZE 32
+#elif defined(CONFIG_STR8100_DRAM_16M)
+#define CONFIG_SYSTEM_DRAM_SIZE 16
+#endif
+#define MEM_SIZE		(CONFIG_SYSTEM_DRAM_SIZE)
+#define END_MEM			(CONFIG_SYSTEM_DRAM_BASE + CONFIG_SYSTEM_DRAM_SIZE)
+#define DMA_SIZE		0xffffffff
+#define PHYS_OFFSET		(CONFIG_SYSTEM_DRAM_BASE) // physical start address of memory
+#if 0
+#define PAGE_OFFSET 		(0xC0000000UL)
+#endif
+
+/*
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+*/
+#if 0
+#define __virt_to_phys__is_a_macro
+#define __virt_to_phys(vpage)	((vpage) - PAGE_OFFSET)
+
+#define __phys_to_virt__is_a_macro
+#define __phys_to_virt(ppage)	((ppage) + PAGE_OFFSET)
+
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+#endif
+
+/*
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#define __pfn_to_bus(x) __pfn_to_phys(x)
+#define __bus_to_pfn(x) __phys_to_pfn(x)
+*/
+
+/*
+#define __pfn_to_bus(p)         __phys_to_bus(__pfn_to_phys(p))
+#define __bus_to_pfn(b)         __phys_to_pfn(__bus_to_phys(b))
+*/
+
+
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/param.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/param.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/param.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/param.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_PARAM_H__
+#define __ASM_ARCH_PARAM_H__
+
+// For timer, there will be HZ ticks per second
+/* scott.patch
+#define HZ	100
+*/
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_demo_dma.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_demo_dma.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_demo_dma.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_demo_dma.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,189 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __DEMO_DMA_H__
+#define __DEMO_DMA_H__
+#include <linux/types.h>	/* size_t */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <mach/star_dmac.h>
+
+/*
+ * defines for each channel
+ */
+#define DMAC_CH_DISABLE                0
+#define DMAC_CH_ENABLE                 1
+
+#define DMAC_CH_DST_SEL_M0             0
+#define DMAC_CH_DST_SEL_M1             1
+
+#define DMAC_CH_SRC_SEL_M0             0
+#define DMAC_CH_SRC_SEL_M1             1
+
+#define DMAC_CH_DSTAD_CTL_INC          0
+#define DMAC_CH_DSTAD_CTL_DEC          1
+#define DMAC_CH_DSTAD_CTL_FIX          2
+
+#define DMAC_CH_SRCAD_CTL_INC          0
+#define DMAC_CH_SRCAD_CTL_DEC          1
+#define DMAC_CH_SRCAD_CTL_FIX          2
+
+#define DMAC_CH_MODE_HW_HANDSHAKE      1
+
+#define DMAC_CH_SRC_WIDTH_8_BITS       0
+#define DMAC_CH_SRC_WIDTH_16_BITS      1
+#define DMAC_CH_SRC_WIDTH_32_BITS      2
+
+#define DMAC_CH_DST_WIDTH_8_BITS       0
+#define DMAC_CH_DST_WIDTH_16_BITS      1
+#define DMAC_CH_DST_WIDTH_32_BITS      2
+
+#define DMAC_CH_ABT_TRANSFER           1
+
+#define DMAC_CH_PROT1_PRIVILEGED_MODE  1
+#define DMAC_CH_PROT1_USER_MODE        0
+
+#define DMAC_CH_PROT2_BUFFERABLE       1
+#define DMAC_CH_PROT2_NON_BUFFERABLE   0
+
+#define DMAC_CH_PROT3_CACHEABLE        1
+#define DMAC_CH_PROT3_NON_CACHEABLE    0
+
+#define DMAC_CH_PRI_LEVEL_0            0
+#define DMAC_CH_PRI_LEVEL_1            1
+#define DMAC_CH_PRI_LEVEL_2            2
+#define DMAC_CH_PRI_LEVEL_3            3
+
+#define DMAC_CH_TC_MASK_DISABLE        0
+#define DMAC_CH_TC_MASK_ENABLE         1
+
+#define DMAC_MAX_CHANNEL_NUM           (8)
+
+
+#define DMAC_CH0_ID                    (1 << 0)
+#define DMAC_CH1_ID                    (1 << 1)
+#define DMAC_CH2_ID                    (1 << 2)
+#define DMAC_CH3_ID                    (1 << 3)
+#define DMAC_CH4_ID                    (1 << 4)
+#define DMAC_CH5_ID                    (1 << 5)
+#define DMAC_CH6_ID                    (1 << 6)
+#define DMAC_CH7_ID                    (1 << 7)
+#define DMAC_CH_ID(idx)                (1 << idx) 
+
+#define DMAC_LITTLE_ENDIAN             (0)
+#define DMAC_BIG_ENDIAN                (1)
+
+/* 
+ * DMAC LLP Descriptor
+ */
+typedef struct _DMAC_LLP_CONTROL_    DMAC_LLP_CONTROL_T;
+
+struct _DMAC_LLP_CONTROL_
+{
+//#if (ENDIAN_MODE == LITTLE_ENDIAN)
+#if 1
+    unsigned int    tot_size              : 12;//b11-0
+    unsigned int    reserved_1            : 4; //b15-12    
+    unsigned int    dst_sel               : 1; //b16
+    unsigned int    src_sel               : 1; //b17    
+    unsigned int    dstad_ctl             : 2; //b19-18        
+    unsigned int    srcad_ctl             : 2; //b21-20        
+    unsigned int    dst_width             : 3; //b24-22
+    unsigned int    src_width             : 3; //b27-25
+    unsigned int    tc_status_mask        : 1; //b28
+    unsigned int    reserved_0            : 3; //b31-29
+
+#else
+
+
+    unsigned int    reserved_0            : 3; //b31-29
+    unsigned int    tc_status_mask        : 1; //b28
+    unsigned int    src_width             : 3; //b27-25
+    unsigned int    dst_width             : 3; //b24-22
+    unsigned int    srcad_ctl             : 2; //b21-20
+    unsigned int    dstad_ctl             : 2; //b19-18    
+    unsigned int    src_sel               : 1; //b17
+    unsigned int    dst_sel               : 1; //b16
+    unsigned int    reserved_1            : 4; //b15-12
+    unsigned int    tot_size              : 12;//b11-0
+
+
+#endif
+}; 
+
+
+/* 
+ * DMAC LLP Descriptor object
+ */
+typedef struct _DMAC_LLP_    DMAC_LLP_T;
+struct _DMAC_LLP_
+{
+    unsigned int    SrcAddr;
+    
+    unsigned int    DstAddr;
+    
+    DMAC_LLP_T     *LLP;
+
+    DMAC_LLP_CONTROL_T    Ctrl_TotSize;    
+};
+
+typedef struct _DMAC_HARDWARE_HANDSHAKE_OBJ_    DMAC_HARDWARE_HANDSHAKE_OBJ_T;
+struct _DMAC_HARDWARE_HANDSHAKE_OBJ_
+{
+    unsigned int    src_addr;                     //Src address
+    unsigned int    dst_addr;                     //Dst address
+    unsigned int    src_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dst_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dstad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    srcad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    src_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    dst_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    transfer_bytes;               //Byte Count to be transferred
+    unsigned int    channel_id;                   //0~7 for Channel0-7 selection
+    unsigned int    channel_num;                   //0~7
+    unsigned int    target_select;                //target ID
+    unsigned int    src_burst_size;               //number of transfer 
+    unsigned int    llp_addr;                     //LLP address
+
+    void * private_data;
+    DMAC_LLP_T* llp_head;
+}; 
+
+
+extern void Hal_Dmac_Configure_DMA_Handshake(DMAC_HARDWARE_HANDSHAKE_OBJ_T *dmac_obj);
+extern irqreturn_t str8100_dma_err_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs);
+//extern int str8100_i2s_init(int sampling_rate);
+extern int str8100_i2s_init(int sampling_rate,u32 i2s_sdata_width, u32 i2s_mode,
+			u32 i2s_tranfer_timing_ctrl, u32 i2s_sclk_mode);
+extern u32 Hal_Dmac_Get_Channel_Transfer_Unit_Number(u32 byte_size, u32 src_width);
+
+extern u32 I2s_Gpio_SSP_Initialise(void);
+extern void I2s_Gpio_SSP_Write(u16);
+extern void I2s_Gpio_SSP_Switch_To_Record_Data(void);
+extern void I2s_Gpio_SSP_Switcg_To_Playback_Data(void);
+
+
+#endif //#ifndef __DEMO_DMA_H__
+
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_dmac.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_dmac.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_dmac.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_dmac.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,409 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_DMAC_H_
+#define	_STAR_DMAC_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	DMAC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_GDMAC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	DMAC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_GDMAC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	DMAC_INT_STATUS_REG			DMAC_MEM_MAP_VALUE(0x000)
+
+#define	DMAC_INT_TC_STATUS_REG			DMAC_MEM_MAP_VALUE(0x004)
+#define	DMAC_INT_TC_STATUS_CLR_REG		DMAC_MEM_MAP_VALUE(0x008)
+
+#define	DMAC_INT_ERR_STATUS_REG			DMAC_MEM_MAP_VALUE(0x00C)
+#define	DMAC_INT_ERR_STATUS_CLR_REG		DMAC_MEM_MAP_VALUE(0x010)
+
+#define	DMAC_TC_STATUS_REG			DMAC_MEM_MAP_VALUE(0x014)
+#define	DMAC_ERR_STATUS_REG			DMAC_MEM_MAP_VALUE(0x018)
+
+#define	DMAC_CH_ENABLE_STATUS_REG		DMAC_MEM_MAP_VALUE(0x01C)
+#define	DMAC_CH_BUSY_STATUS_REG			DMAC_MEM_MAP_VALUE(0x020)
+
+#define	DMAC_CSR_REG				DMAC_MEM_MAP_VALUE(0x024)
+#define	DMAC_SYNC_REG				DMAC_MEM_MAP_VALUE(0x028)
+
+#define	DMAC_CH0_CSR_REG			DMAC_MEM_MAP_VALUE(0x100)
+#define	DMAC_CH0_CFG_REG			DMAC_MEM_MAP_VALUE(0x104)
+#define	DMAC_CH0_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x108)
+#define	DMAC_CH0_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x10C)
+#define	DMAC_CH0_LLP_REG			DMAC_MEM_MAP_VALUE(0x110)
+#define	DMAC_CH0_SIZE_REG			DMAC_MEM_MAP_VALUE(0x114)
+
+#define	DMAC_CH1_CSR_REG			DMAC_MEM_MAP_VALUE(0x120)
+#define	DMAC_CH1_CFG_REG			DMAC_MEM_MAP_VALUE(0x124)
+#define	DMAC_CH1_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x128)
+#define	DMAC_CH1_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x12C)
+#define	DMAC_CH1_LLP_REG			DMAC_MEM_MAP_VALUE(0x130)
+#define	DMAC_CH1_SIZE_REG			DMAC_MEM_MAP_VALUE(0x134)
+
+#define	DMAC_CH2_CSR_REG			DMAC_MEM_MAP_VALUE(0x140)
+#define	DMAC_CH2_CFG_REG			DMAC_MEM_MAP_VALUE(0x144)
+#define	DMAC_CH2_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x148)
+#define	DMAC_CH2_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x14C)
+#define	DMAC_CH2_LLP_REG			DMAC_MEM_MAP_VALUE(0x150)
+#define	DMAC_CH2_SIZE_REG			DMAC_MEM_MAP_VALUE(0x154)
+
+#define	DMAC_CH3_CSR_REG			DMAC_MEM_MAP_VALUE(0x160)
+#define	DMAC_CH3_CFG_REG			DMAC_MEM_MAP_VALUE(0x164)
+#define	DMAC_CH3_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x168)
+#define	DMAC_CH3_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x16C)
+#define	DMAC_CH3_LLP_REG			DMAC_MEM_MAP_VALUE(0x170)
+#define	DMAC_CH3_SIZE_REG			DMAC_MEM_MAP_VALUE(0x174)
+
+#define	DMAC_CH4_CSR_REG			DMAC_MEM_MAP_VALUE(0x180)
+#define	DMAC_CH4_CFG_REG			DMAC_MEM_MAP_VALUE(0x184)
+#define	DMAC_CH4_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x188)
+#define	DMAC_CH4_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x18C)
+#define	DMAC_CH4_LLP_REG			DMAC_MEM_MAP_VALUE(0x190)
+#define	DMAC_CH4_SIZE_REG			DMAC_MEM_MAP_VALUE(0x194)
+
+#define	DMAC_CH5_CSR_REG			DMAC_MEM_MAP_VALUE(0x1A0)
+#define	DMAC_CH5_CFG_REG			DMAC_MEM_MAP_VALUE(0x1A4)
+#define	DMAC_CH5_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1A8)
+#define	DMAC_CH5_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1AC)
+#define	DMAC_CH5_LLP_REG			DMAC_MEM_MAP_VALUE(0x1B0)
+#define	DMAC_CH5_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1B4)
+
+#define	DMAC_CH6_CSR_REG			DMAC_MEM_MAP_VALUE(0x1C0)
+#define	DMAC_CH6_CFG_REG			DMAC_MEM_MAP_VALUE(0x1C4)
+#define	DMAC_CH6_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1C8)
+#define	DMAC_CH6_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1CC)
+#define	DMAC_CH6_LLP_REG			DMAC_MEM_MAP_VALUE(0x1D0)
+#define	DMAC_CH6_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1D4)
+
+#define	DMAC_CH7_CSR_REG			DMAC_MEM_MAP_VALUE(0x1E0)
+#define	DMAC_CH7_CFG_REG			DMAC_MEM_MAP_VALUE(0x1E4)
+#define	DMAC_CH7_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1E8)
+#define	DMAC_CH7_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1EC)
+#define	DMAC_CH7_LLP_REG			DMAC_MEM_MAP_VALUE(0x1F0)
+#define	DMAC_CH7_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1F4)
+
+
+#define DMAC_CH0_INT_BIT_INDEX			0
+#define DMAC_CH1_INT_BIT_INDEX			1
+#define DMAC_CH2_INT_BIT_INDEX			2
+#define DMAC_CH3_INT_BIT_INDEX			3
+#define DMAC_CH4_INT_BIT_INDEX			4
+#define DMAC_CH5_INT_BIT_INDEX			5
+#define DMAC_CH6_INT_BIT_INDEX			6
+#define DMAC_CH7_INT_BIT_INDEX			7
+
+#define DMAC_CH0_INT_TC_BIT_INDEX		0
+#define DMAC_CH1_INT_TC_BIT_INDEX		1
+#define DMAC_CH2_INT_TC_BIT_INDEX		2
+#define DMAC_CH3_INT_TC_BIT_INDEX		3
+#define DMAC_CH4_INT_TC_BIT_INDEX		4
+#define DMAC_CH5_INT_TC_BIT_INDEX		5
+#define DMAC_CH6_INT_TC_BIT_INDEX		6
+#define DMAC_CH7_INT_TC_BIT_INDEX		7
+
+#define DMAC_CH0_INT_TC_CLR_BIT_INDEX		0
+#define DMAC_CH1_INT_TC_CLR_BIT_INDEX		1
+#define DMAC_CH2_INT_TC_CLR_BIT_INDEX		2
+#define DMAC_CH3_INT_TC_CLR_BIT_INDEX		3
+#define DMAC_CH4_INT_TC_CLR_BIT_INDEX		4
+#define DMAC_CH5_INT_TC_CLR_BIT_INDEX		5
+#define DMAC_CH6_INT_TC_CLR_BIT_INDEX		6
+#define DMAC_CH7_INT_TC_CLR_BIT_INDEX		7
+
+#define DMAC_CH0_INT_ERR_BIT_INDEX		0
+#define DMAC_CH1_INT_ERR_BIT_INDEX		1
+#define DMAC_CH2_INT_ERR_BIT_INDEX		2
+#define DMAC_CH3_INT_ERR_BIT_INDEX		3
+#define DMAC_CH4_INT_ERR_BIT_INDEX		4
+#define DMAC_CH5_INT_ERR_BIT_INDEX		5
+#define DMAC_CH6_INT_ERR_BIT_INDEX		6
+#define DMAC_CH7_INT_ERR_BIT_INDEX		7
+
+#define DMAC_CH0_INT_ERR_CLR_BIT_INDEX		0
+#define DMAC_CH1_INT_ERR_CLR_BIT_INDEX		1
+#define DMAC_CH2_INT_ERR_CLR_BIT_INDEX		2
+#define DMAC_CH3_INT_ERR_CLR_BIT_INDEX		3
+#define DMAC_CH4_INT_ERR_CLR_BIT_INDEX		4
+#define DMAC_CH5_INT_ERR_CLR_BIT_INDEX		5
+#define DMAC_CH6_INT_ERR_CLR_BIT_INDEX		6
+#define DMAC_CH7_INT_ERR_CLR_BIT_INDEX		7
+
+#define DMAC_CH0_TC_STATUS_BIT_INDEX		0
+#define DMAC_CH1_TC_STATUS_BIT_INDEX		1
+#define DMAC_CH2_TC_STATUS_BIT_INDEX		2
+#define DMAC_CH3_TC_STATUS_BIT_INDEX		3
+#define DMAC_CH4_TC_STATUS_BIT_INDEX		4
+#define DMAC_CH5_TC_STATUS_BIT_INDEX		5
+#define DMAC_CH6_TC_STATUS_BIT_INDEX		6
+#define DMAC_CH7_TC_STATUS_BIT_INDEX		7
+
+#define DMAC_CH0_ERR_STATUS_BIT_INDEX		0
+#define DMAC_CH1_ERR_STATUS_BIT_INDEX		1
+#define DMAC_CH2_ERR_STATUS_BIT_INDEX		2
+#define DMAC_CH3_ERR_STATUS_BIT_INDEX		3
+#define DMAC_CH4_ERR_STATUS_BIT_INDEX		4
+#define DMAC_CH5_ERR_STATUS_BIT_INDEX		5
+#define DMAC_CH6_ERR_STATUS_BIT_INDEX		6
+#define DMAC_CH7_ERR_STATUS_BIT_INDEX		7
+
+#define DMAC_CH0_ENABLE_STATUS_BIT_INDEX	0
+#define DMAC_CH1_ENABLE_STATUS_BIT_INDEX	1
+#define DMAC_CH2_ENABLE_STATUS_BIT_INDEX	2
+#define DMAC_CH3_ENABLE_STATUS_BIT_INDEX	3
+#define DMAC_CH4_ENABLE_STATUS_BIT_INDEX	4
+#define DMAC_CH5_ENABLE_STATUS_BIT_INDEX	5
+#define DMAC_CH6_ENABLE_STATUS_BIT_INDEX	6
+#define DMAC_CH7_ENABLE_STATUS_BIT_INDEX	7
+
+#define DMAC_CH0_BUSY_STATUS_BIT_INDEX		0
+#define DMAC_CH1_BUSY_STATUS_BIT_INDEX		1
+#define DMAC_CH2_BUSY_STATUS_BIT_INDEX		2
+#define DMAC_CH3_BUSY_STATUS_BIT_INDEX		3
+#define DMAC_CH4_BUSY_STATUS_BIT_INDEX		4
+#define DMAC_CH5_BUSY_STATUS_BIT_INDEX		5
+#define DMAC_CH6_BUSY_STATUS_BIT_INDEX		6
+#define DMAC_CH7_BUSY_STATUS_BIT_INDEX		7
+
+#define DMAC_ENABLE_BIT_INDEX			0
+#define DMAC_MASTER0_ENDIAN_BIT_INDEX		1
+#define DMAC_MASTER1_ENDIAN_BIT_INDEX		2
+
+#define DMAC_CH0_SYNC_ENABLE_BIT_INDEX		0
+#define DMAC_CH1_SYNC_ENABLE_BIT_INDEX		1
+#define DMAC_CH2_SYNC_ENABLE_BIT_INDEX		2
+#define DMAC_CH3_SYNC_ENABLE_BIT_INDEX		3
+#define DMAC_CH4_SYNC_ENABLE_BIT_INDEX		4
+#define DMAC_CH5_SYNC_ENABLE_BIT_INDEX		5
+#define DMAC_CH6_SYNC_ENABLE_BIT_INDEX		6
+#define DMAC_CH7_SYNC_ENABLE_BIT_INDEX		7
+
+#define DMAC_CH_INT_TC_MASK_BIT_INDEX		0
+#define DMAC_CH_INT_ERR_MASK_BIT_INDEX		1
+#define DMAC_CH_INT_ABT_MASK_BIT_INDEX		2
+#define DMAC_CH_BUSY_BIT_INDEX			8
+
+#define DMAC_CH_ENABLE_BIT_INDEX		0
+#define DMAC_CH_DST_SEL_BIT_INDEX		1
+#define DMAC_CH_SRC_SEL_BIT_INDEX		2
+#define DMAC_CH_DST_ADDR_CTL_BIT_INDEX		3
+#define DMAC_CH_SRC_ADDR_CTL_BIT_INDEX		5
+#define DMAC_CH_MODE_BIT_INDEX			7
+#define DMAC_CH_DST_WIDTH_BIT_INDEX		8
+#define DMAC_CH_SRC_WIDTH_BIT_INDEX		11
+#define DMAC_CH_ABT_BIT_INDEX			15
+#define DMAC_CH_SRC_BURST_SIZE_BIT_INDEX	16
+#define DMAC_CH_PROTECT_MODE_BIT_INDEX		19
+#define DMAC_CH_PROTECT_BUFFERABLE_BIT_INDEX	20
+#define DMAC_CH_PROTECT_CACHEABLE_BIT_INDEX	21
+#define DMAC_CH_PRIORITY_BIT_INDEX		22
+#define DMAC_CH_HHST_SEL_BIT_INDEX		25
+
+#define DMAC_CH_DST_ADDR_CTL_MASK		0x3
+#define DMAC_CH_DST_ADDR_CTL_INC		0x0
+#define DMAC_CH_DST_ADDR_CTL_DEC		0x1
+#define DMAC_CH_DST_ADDR_CTL_FIXED		0x2
+
+#define DMAC_CH_SRC_ADDR_CTL_MASK		0x3
+#define DMAC_CH_SRC_ADDR_CTL_INC		0x0
+#define DMAC_CH_SRC_ADDR_CTL_DEC		0x1
+#define DMAC_CH_SRC_ADDR_CTL_FIXED		0x2
+
+#define DMAC_CH_MODE_NORMAL			0x0
+#define DMAC_CH_MODE_HANDSHAKE			0x1
+
+#define DMAC_CH_DST_WIDTH_MASK			0x3
+#define DMAC_CH_DST_WIDTH_8BIT			0x0
+#define DMAC_CH_DST_WIDTH_16BIT			0x1
+#define DMAC_CH_DST_WIDTH_32BIT			0x2
+
+#define DMAC_CH_SRC_WIDTH_MASK			0x3
+#define DMAC_CH_SRC_WIDTH_8BIT			0x0
+#define DMAC_CH_SRC_WIDTH_16BIT			0x1
+#define DMAC_CH_SRC_WIDTH_32BIT			0x2
+
+#define DMAC_CH_SRC_BURST_SIZE_MASK		0x8
+#define DMAC_CH_SRC_BURST_SIZE_1		0x0
+#define DMAC_CH_SRC_BURST_SIZE_4		0x1
+#define DMAC_CH_SRC_BURST_SIZE_8		0x2
+#define DMAC_CH_SRC_BURST_SIZE_16		0x3
+#define DMAC_CH_SRC_BURST_SIZE_32		0x4
+#define DMAC_CH_SRC_BURST_SIZE_64		0x5
+#define DMAC_CH_SRC_BURST_SIZE_128		0x6
+#define DMAC_CH_SRC_BURST_SIZE_256		0x7
+
+#define DMAC_CH_PRIORITY_MASK			0x4
+#define DMAC_CH_PRIORITY_0			0x0	/* lowest priority */
+#define DMAC_CH_PRIORITY_1			0x1
+#define DMAC_CH_PRIORITY_2			0x2
+#define DMAC_CH_PRIORITY_3			0x3	/* highest priority */
+
+
+#define	DMAC_CH_CSR_REG(idx)			DMAC_MEM_MAP_VALUE(0x100+0x20*(idx))
+#define	DMAC_CH_CFG_REG(idx)			DMAC_MEM_MAP_VALUE(0x104+0x20*(idx))
+#define	DMAC_CH_SRC_ADDR_REG(idx)		DMAC_MEM_MAP_VALUE(0x108+0x20*(idx))
+#define	DMAC_CH_DST_ADDR_REG(idx)		DMAC_MEM_MAP_VALUE(0x10C+0x20*(idx))
+#define	DMAC_CH_LLP_REG(idx)			DMAC_MEM_MAP_VALUE(0x110+0x20*(idx))
+#define	DMAC_CH_SIZE_REG(idx)			DMAC_MEM_MAP_VALUE(0x114+0x20*(idx))
+
+
+#define	HAL_DMAC_ENABLE_CHANNEL(idx)		((DMAC_CH_CSR_REG(idx)) |= (0x1))
+
+#define	HAL_DMAC_DISABLE_CHANNEL(idx)		((DMAC_CH_CSR_REG(idx)) &= ~(0x1))
+
+#define	HAL_GET_DMAC_CHANNEL_LLP_COUNTER(ch)	((DMAC_CH_CFG_REG(ch) >> 16) & 0xF)
+
+
+/*DMAC HW Hand-shake target ID*/
+#define	DMAC_HW_HAND_SHAKE_PCM_TX0_ID		0x0
+#define	DMAC_HW_HAND_SHAKE_PCM_RX0_ID		0x1
+
+#define	DMAC_HW_HAND_SHAKE_SPI_TX_ID		0x2
+#define	DMAC_HW_HAND_SHAKE_SPI_RX_ID		0x3
+
+#define	DMAC_HW_HAND_SHAKE_I2S_TX_LEFT_ID	0x4
+#define	DMAC_HW_HAND_SHAKE_I2S_TX_RIGHT_ID	0x5
+
+#define	DMAC_HW_HAND_SHAKE_UART0_TX_ID		0x6
+#define	DMAC_HW_HAND_SHAKE_UART0_RX_ID		0x7
+
+#define	DMAC_HW_HAND_SHAKE_UART1_TX_ID		0x8
+#define	DMAC_HW_HAND_SHAKE_UART1_RX_ID		0x9
+
+#define	DMAC_HW_HAND_SHAKE_USBDEV_ID		0xA
+
+#define	DMAC_HW_HAND_SHAKE_I2S_RX_LEFT_ID	0xB
+#define	DMAC_HW_HAND_SHAKE_I2S_RX_RIGHT_ID	0xC
+
+#define	DMAC_HW_HAND_SHAKE_PCM_TX1_ID		0xD
+#define	DMAC_HW_HAND_SHAKE_PCM_RX1_ID		0xE
+
+
+#define MAX_DMA_VEC				32
+
+#define DMAC_DST_SEL_MASTER0			0
+#define DMAC_DST_SEL_MASTER1			1
+#define DMAC_SRC_SEL_MASTER0			0
+#define DMAC_SRC_SEL_MASTER1			1
+
+#define DMAC_RESPONSE_OK			0
+#define DMAC_RESPONSE_ERR			-1
+
+struct dma_xfer;
+typedef struct dma_xfer dma_xfer_t;
+typedef void (*dma_end_io_t)(dma_xfer_t *dma_xfer, int err);
+typedef struct
+{
+	u32	src_addr;	// virtual addr
+	u32	dst_addr;	// virtual addr
+	u32	size;		// bytes
+	u8	dst_sel;
+	u8	src_sel;
+	u8	dst_addr_ctl;
+	u8	src_addr_ctl;
+	u8	dst_width;
+	u8	src_width;
+} dma_vec_t;
+
+struct dma_xfer
+{
+	u8		nr_vec;
+	dma_vec_t	vec[MAX_DMA_VEC];
+	dma_end_io_t	dma_end_io;
+	void		*private;
+};
+
+/*
+ * DMAC	LLP Descriptor
+ */
+typedef struct
+{
+	u32	src_addr;			// physical addr
+	u32	dst_addr;			// physical addr
+	u32	llp;
+	u32	tot_size	: 12;
+	u32	reserved0	: 4;
+	u32	dst_sel		: 1;
+	u32	src_sel		: 1;
+	u32	dst_addr_ctl	: 2;
+	u32	src_addr_ctl	: 2;
+	u32	dst_width	: 3;
+	u32	src_width	: 3;
+	u32	tc_mask		: 1;
+	u32	reserved1	: 3;
+} __attribute__((packed)) dma_llp_descr_t;
+
+#define HAL_DMAC_ENABLE() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_ENABLE_BIT_INDEX))
+
+
+#define HAL_DMAC_DISABLE() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_ENABLE_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER0_BIG_ENDIAN() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_MASTER0_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER0_LITTLE_ENDIAN() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_MASTER0_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER1_BIG_ENDIAN() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_MASTER1_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER1_LITTLE_ENDIAN() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_MASTER1_ENDIAN_BIT_INDEX))
+
+#define HAL_DMAC_READ_ERROR_ABORT_INTERRUPT_STATUS(err_abt_status) \
+	    ((err_abt_status) = (DMAC_INT_ERR_STATUS_REG))
+
+
+#define HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(err_abt_status) \
+	    ((DMAC_INT_ERR_STATUS_CLR_REG) = (err_abt_status))
+
+
+#define HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(tc_status) \
+	    ((tc_status) = (DMAC_INT_TC_STATUS_REG) & 0xFF)
+
+
+#define HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(tc_status) \
+	    ((DMAC_INT_TC_STATUS_CLR_REG) = (tc_status) & 0xFF)
+
+
+
+
+
+
+#endif	// end of #ifndef _STAR_DMAC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_gpio.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_gpio.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_gpio.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_gpio.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,327 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_GPIO_H_
+#define	_STAR_GPIO_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	GPIOA_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_GPIOA_BASE_ADDR + reg_offset)))
+#define	GPIOB_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_GPIOB_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	GPIOA_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_GPIOA_BASE_ADDR + reg_offset)))
+#define	GPIOB_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_GPIOB_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * For GPIO Set	A
+ */
+#define	GPIOA_DATA_OUTPUT_REG			GPIOA_MEM_MAP_VALUE(0x00)
+#define	GPIOA_DATA_INPUT_REG			GPIOA_MEM_MAP_VALUE(0x04)
+#define	GPIOA_DIRECTION_REG			GPIOA_MEM_MAP_VALUE(0x08)
+
+#define	GPIOA_DATA_BIT_SET_REG			GPIOA_MEM_MAP_VALUE(0x10)
+#define	GPIOA_DATA_BIT_CLEAR_REG		GPIOA_MEM_MAP_VALUE(0x14)
+
+#define	GPIOA_INTERRUPT_ENABLE_REG		GPIOA_MEM_MAP_VALUE(0x20)
+#define	GPIOA_INTERRUPT_RAW_STATUS_REG		GPIOA_MEM_MAP_VALUE(0x24)
+#define	GPIOA_INTERRUPT_MASKED_STATUS_REG	GPIOA_MEM_MAP_VALUE(0x28)
+#define	GPIOA_INTERRUPT_MASK_REG		GPIOA_MEM_MAP_VALUE(0x2C)
+#define	GPIOA_INTERRUPT_CLEAR_REG		GPIOA_MEM_MAP_VALUE(0x30)
+#define	GPIOA_INTERRUPT_TRIGGER_METHOD_REG	GPIOA_MEM_MAP_VALUE(0x34)
+#define	GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG	GPIOA_MEM_MAP_VALUE(0x38)
+#define	GPIOA_INTERRUPT_TRIGGER_TYPE_REG	GPIOA_MEM_MAP_VALUE(0x3C)
+
+#define	GPIOA_BOUNCE_ENABLE_REG			GPIOA_MEM_MAP_VALUE(0x40)
+#define	GPIOA_BOUNCE_CLOCK_PRESCALE_REG		GPIOA_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * For GPIO Set	B
+ */
+#define	GPIOB_DATA_OUTPUT_REG			GPIOB_MEM_MAP_VALUE(0x00)
+#define	GPIOB_DATA_INPUT_REG			GPIOB_MEM_MAP_VALUE(0x04)
+#define	GPIOB_DIRECTION_REG			GPIOB_MEM_MAP_VALUE(0x08)
+
+#define	GPIOB_DATA_BIT_SET_REG			GPIOB_MEM_MAP_VALUE(0x10)
+#define	GPIOB_DATA_BIT_CLEAR_REG		GPIOB_MEM_MAP_VALUE(0x14)
+
+#define	GPIOB_INTERRUPT_ENABLE_REG		GPIOB_MEM_MAP_VALUE(0x20)
+#define	GPIOB_INTERRUPT_RAW_STATUS_REG		GPIOB_MEM_MAP_VALUE(0x24)
+#define	GPIOB_INTERRUPT_MASKED_STATUS_REG	GPIOB_MEM_MAP_VALUE(0x28)
+#define	GPIOB_INTERRUPT_MASK_REG		GPIOB_MEM_MAP_VALUE(0x2C)
+#define	GPIOB_INTERRUPT_CLEAR_REG		GPIOB_MEM_MAP_VALUE(0x30)
+#define	GPIOB_INTERRUPT_TRIGGER_METHOD_REG	GPIOB_MEM_MAP_VALUE(0x34)
+#define	GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG	GPIOB_MEM_MAP_VALUE(0x38)
+#define	GPIOB_INTERRUPT_TRIGGER_TYPE_REG	GPIOB_MEM_MAP_VALUE(0x3C)
+
+#define	GPIOB_BOUNCE_ENABLE_REG			GPIOB_MEM_MAP_VALUE(0x40)
+#define	GPIOB_BOUNCE_CLOCK_PRESCALE_REG		GPIOB_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * define constant macros
+ */
+
+#define	MAX_GPIO_PINS		(32)
+
+#define	GPIO_0_MASK		(1 << 0)
+#define	GPIO_1_MASK		(1 << 1)
+#define	GPIO_2_MASK		(1 << 2)
+#define	GPIO_3_MASK		(1 << 3)
+#define	GPIO_4_MASK		(1 << 4)
+#define	GPIO_5_MASK		(1 << 5)
+#define	GPIO_6_MASK		(1 << 6)
+#define	GPIO_7_MASK		(1 << 7)
+#define	GPIO_8_MASK		(1 << 8)
+#define	GPIO_9_MASK		(1 << 9)
+#define	GPIO_10_MASK		(1 << 10)
+#define	GPIO_11_MASK		(1 << 11)
+#define	GPIO_12_MASK		(1 << 12)
+#define	GPIO_13_MASK		(1 << 13)
+#define	GPIO_14_MASK		(1 << 14)
+#define	GPIO_15_MASK		(1 << 15)
+#define	GPIO_16_MASK		(1 << 16)
+#define	GPIO_17_MASK		(1 << 17)
+#define	GPIO_18_MASK		(1 << 18)
+#define	GPIO_19_MASK		(1 << 19)
+#define	GPIO_20_MASK		(1 << 20)
+#define	GPIO_21_MASK		(1 << 21)
+#define	GPIO_22_MASK		(1 << 22)
+#define	GPIO_23_MASK		(1 << 23)
+#define	GPIO_24_MASK		(1 << 24)
+#define	GPIO_25_MASK		(1 << 25)
+#define	GPIO_26_MASK		(1 << 26)
+#define	GPIO_27_MASK		(1 << 27)
+#define	GPIO_28_MASK		(1 << 28)
+#define	GPIO_29_MASK		(1 << 29)
+#define	GPIO_30_MASK		(1 << 30)
+#define	GPIO_31_MASK		(1 << 31)
+
+
+/*
+ * macro declarations for GPIO Set A
+ */
+#define	HAL_GPIOA_READ_DATA_OUT_STATUS(data_out_state) \
+    ((data_out_state) =	(GPIOA_DATA_OUTPUT_REG))
+
+#define	HAL_GPIOA_READ_DATA_IN_STATUS(data_in_state) \
+    ((data_in_state) = (GPIOA_DATA_INPUT_REG))
+
+#define	HAL_GPIOA_SET_DIRECTION_OUTPUT(gpio_index) \
+    ((GPIOA_DIRECTION_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_SET_DIRECTION_INPUT(gpio_index) \
+    ((GPIOA_DIRECTION_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_SET_DATA_OUT_HIGH(gpio_index)	\
+    ((GPIOA_DATA_BIT_SET_REG) =	(gpio_index))
+
+#define	HAL_GPIOA_SET_DATA_OUT_LOW(gpio_index) \
+    ((GPIOA_DATA_BIT_CLEAR_REG)	= (gpio_index))
+
+#define	HAL_GPIOA_ENABLE_INTERRUPT(gpio_index) \
+    ((GPIOA_INTERRUPT_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_DISABLE_INTERRUPT(gpio_index)	\
+    ((GPIOA_INTERRUPT_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_READ_INTERRUPT_RAW_STATUS(raw_state) \
+    ((raw_state) = (GPIOA_INTERRUPT_RAW_STATUS_REG))
+
+#define	HAL_GPIOA_READ_INTERRUPT_MASKED_STATUS(masked_raw_state) \
+    ((masked_raw_state)	= (GPIOA_INTERRUPT_MASKED_STATUS_REG))
+
+#define	HAL_GPIOA_DISABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOA_INTERRUPT_MASK_REG)	&= ~(gpio_index))
+
+#define	HAL_GPIOA_ENABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOA_INTERRUPT_MASK_REG)	|= (gpio_index))
+
+#define	HAL_GPIOA_CLEAR_INTERRUPT(gpio_index) \
+    ((GPIOA_INTERRUPT_CLEAR_REG) = (gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_EDGE_TRIGGER_MODE(gpio_index) \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_LEVEL_TRIGGER_MODE(gpio_index) \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) |= (gpio_index));	\
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOA_ENABLE_BOUNCE(gpio_index) \
+    ((GPIOA_BOUNCE_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_DISABLE_BOUNCE(gpio_index) \
+    ((GPIOA_BOUNCE_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_READ_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((prescale_ratio) =	((GPIOA_BOUNCE_CLOCK_PRESCALE_REG) & 0x0000FFFF))
+
+#define	HAL_GPIOA_WRITE_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((GPIOA_BOUNCE_CLOCK_PRESCALE_REG) = (prescale_ratio & 0x0000FFFF))
+
+
+
+/*
+ * macro declarations for GPIO Set B
+ */
+#define	HAL_GPIOB_READ_DATA_OUT_STATUS(data_out_state) \
+    ((data_out_state) =	(GPIOB_DATA_OUTPUT_REG))
+
+#define	HAL_GPIOB_READ_DATA_IN_STATUS(data_in_state) \
+    ((data_in_state) = (GPIOB_DATA_INPUT_REG))
+
+#define	HAL_GPIOB_SET_DIRECTION_OUTPUT(gpio_index) \
+    ((GPIOB_DIRECTION_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_SET_DIRECTION_INPUT(gpio_index) \
+    ((GPIOB_DIRECTION_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_SET_DATA_OUT_HIGH(gpio_index)	\
+    ((GPIOB_DATA_BIT_SET_REG) =	(gpio_index))
+
+#define	HAL_GPIOB_SET_DATA_OUT_LOW(gpio_index) \
+    ((GPIOB_DATA_BIT_CLEAR_REG)	= (gpio_index))
+
+#define	HAL_GPIOB_ENABLE_INTERRUPT(gpio_index) \
+    ((GPIOB_INTERRUPT_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_DISABLE_INTERRUPT(gpio_index)	\
+    ((GPIOB_INTERRUPT_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_READ_INTERRUPT_RAW_STATUS(raw_state) \
+    ((raw_state) = (GPIOB_INTERRUPT_RAW_STATUS_REG))
+
+#define	HAL_GPIOB_READ_INTERRUPT_MASKED_STATUS(masked_raw_state) \
+    ((masked_raw_state)	= (GPIOB_INTERRUPT_MASKED_STATUS_REG))
+
+#define	HAL_GPIOB_DISABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOB_INTERRUPT_MASK_REG)	&= ~(gpio_index))
+
+#define	HAL_GPIOB_ENABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOB_INTERRUPT_MASK_REG)	|= (gpio_index))
+
+#define	HAL_GPIOB_CLEAR_INTERRUPT(gpio_index) \
+    ((GPIOB_INTERRUPT_CLEAR_REG) = (gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_EDGE_TRIGGER_MODE(gpio_index) \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_LEVEL_TRIGGER_MODE(gpio_index) \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) |= (gpio_index));	\
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOB_ENABLE_BOUNCE(gpio_index) \
+    ((GPIOB_BOUNCE_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_DISABLE_BOUNCE(gpio_index) \
+    ((GPIOB_BOUNCE_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_READ_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((prescale_ratio) =	((GPIOB_BOUNCE_CLOCK_PRESCALE_REG) & 0x0000FFFF))
+
+#define	HAL_GPIOB_WRITE_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((GPIOB_BOUNCE_CLOCK_PRESCALE_REG) = (prescale_ratio & 0x0000FFFF))
+
+
+#endif	// end of _STAR_GPIO_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_hsdmac.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_hsdmac.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_hsdmac.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_hsdmac.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,106 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_HSDMAC_H_
+#define	_STAR_HSDMAC_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	HSDMAC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_MISC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	HSDMAC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_MISC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	HSDMAC_CONTROL_STATUS_REG		HSDMAC_MEM_MAP_VALUE(0x040)
+
+#define	HSDMAC_MASTER0_ADDR_REG			HSDMAC_MEM_MAP_VALUE(0x050)
+
+#define	HSDMAC_MASTER1_ADDR_REG			HSDMAC_MEM_MAP_VALUE(0x054)
+
+#define	HSDMAC_LLP_REG				HSDMAC_MEM_MAP_VALUE(0x058)
+
+#define	HSDMAC_TOT_SIZE_REG			HSDMAC_MEM_MAP_VALUE(0x05C)
+
+
+#define	HAL_GET_HSDMAC_LLP_COUNTER		((HSDMAC_CONTROL_STATUS_REG >> 8) & 0xF)
+
+#define	HAL_HSDMAC_ENABLE()			((HSDMAC_CONTROL_STATUS_REG) |= (0x1))
+
+#define	HAL_HSDMAC_DISABLE()			((HSDMAC_CONTROL_STATUS_REG) &= ~(0x1))
+
+
+#define HSDMAC_MASTER0_TO_MASTER1		0
+#define HSDMAC_MASTER1_TO_MASTER0		1
+
+#define HSDMAC_RESPONSE_OK			0
+#define HSDMAC_RESPONSE_ERR			-1
+
+#define MAX_HSDMA_VEC 				32
+
+#define MAX_HSDMA_XFER_SIZE			(0xFFF << 2)
+
+struct hsdma_xfer;
+typedef struct hsdma_xfer hsdma_xfer_t;
+typedef void (*hsdma_end_io_t)(hsdma_xfer_t *hsdma_xfer, int err);
+typedef struct
+{
+	u8	data_direction;
+	u32	src_addr; // virtual
+	u32	dst_addr; // virtual
+	u32	size; // bytes
+} __attribute__((packed)) hsdma_vec_t;
+
+struct hsdma_xfer
+{
+	u8			nr_vec;
+	hsdma_vec_t		vec[MAX_HSDMA_VEC];
+	hsdma_end_io_t		hsdma_end_io;
+	void			*private;
+};
+
+/*
+ * HSDMAC LLP Descriptor object
+ */
+typedef struct
+{
+	u32	src_addr; // physical
+	u32	dst_addr; // physical
+	u32	llp;
+	u32	tot_size	: 16;//b15-b0
+	u32	reserved0	: 12;//b27-b16
+	u32	tc_mask		: 1; //b28
+	u32	data_direction	: 1; //b29
+	u32	reserved1	: 2; //b31-30
+} __attribute__((packed)) hsdma_llp_descr_t;
+
+
+#endif	// end of #ifndef _STAR_HSDMAC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_i2c.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_i2c.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_i2c.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_i2c.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_I2C_H_
+#define _STAR_I2C_H_
+
+#include <mach/star_sys_memory_map.h>
+
+#define I2C_MEM_MAP_ADDR(reg_offset)          (SYSVA_I2C_BASE_ADDR + reg_offset) 
+#define I2C_MEM_MAP_VALUE(reg_offset)         (*((unsigned int volatile *)I2C_MEM_MAP_ADDR(reg_offset)))
+
+#define I2C_CONTROLLER_REG_ADDR               I2C_MEM_MAP_ADDR(0x20)
+#define I2C_TIME_OUT_REG_ADDR                 I2C_MEM_MAP_ADDR(0x24)
+#define I2C_SLAVE_ADDRESS_REG_ADDR            I2C_MEM_MAP_ADDR(0x28)
+#define I2C_WRITE_DATA_REG_ADDR               I2C_MEM_MAP_ADDR(0x2C)
+#define I2C_READ_DATA_REG_ADDR                I2C_MEM_MAP_ADDR(0x30)
+#define I2C_INTERRUPT_STATUS_REG_ADDR         I2C_MEM_MAP_ADDR(0x34)
+#define I2C_INTERRUPT_ENABLE_REG_ADDR         I2C_MEM_MAP_ADDR(0x38)
+
+#define I2C_CONTROLLER_REG                    I2C_MEM_MAP_VALUE(0x20)
+#define I2C_TIME_OUT_REG                      I2C_MEM_MAP_VALUE(0x24)
+#define I2C_SLAVE_ADDRESS_REG                 I2C_MEM_MAP_VALUE(0x28)
+#define I2C_WRITE_DATA_REG                    I2C_MEM_MAP_VALUE(0x2C)
+#define I2C_READ_DATA_REG                     I2C_MEM_MAP_VALUE(0x30)
+#define I2C_INTERRUPT_STATUS_REG              I2C_MEM_MAP_VALUE(0x34)
+#define I2C_INTERRUPT_ENABLE_REG              I2C_MEM_MAP_VALUE(0x38)
+
+#define I2C_READ_ONLY_CMD      (0)
+#define I2C_WRITE_ONLY_CMD     (1)
+#define I2C_WRITE_READ_CMD     (2)
+#define I2C_READ_WRITE_CMD     (3)
+
+#define I2C_DATA_LEN_1_BYTE    (0)
+#define I2C_DATA_LEN_2_BYTE    (1)
+#define I2C_DATA_LEN_3_BYTE    (2)
+#define I2C_DATA_LEN_4_BYTE    (3)
+
+#define I2C_BUS_ERROR_FLAG     (0x1)
+#define I2C_ACTION_DONE_FLAG   (0x2)
+
+#define HAL_I2C_ENABLE_I2C()          (I2C_CONTROLLER_REG) |= ((unsigned int)0x1 << 31); 
+#define HAL_I2C_DISABLE_I2C()         (I2C_CONTROLLER_REG) &= ~((unsigned int)0x1 << 31);
+#define HAL_I2C_ENABLE_DATA_SWAP()    (I2C_CONTROLLER_REG) |= (0x1 << 24); 
+#define HAL_I2C_DISABLE_DATA_SWAP()   (I2C_CONTROLLER_REG) &= ~(0x1 << 24); 
+#define HAL_I2C_START_TRANSFER()      (I2C_CONTROLLER_REG) |= (0x1 << 6); 
+#define HAL_I2C_STOP_TRANSFER()       (I2C_CONTROLLER_REG) &= ~(0x1 << 6); 
+
+#endif
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_i2s.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_i2s.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_i2s.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_i2s.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,176 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_I2S_H_
+#define _STAR_I2S_H_
+
+/******************************************************************************
+ * MODULE NAME:    star_i2s.h
+ * PROJECT CODE:   Orion
+ * DESCRIPTION:    
+ * MAINTAINER:     MJLIU
+ * DATE:           15 September 2005
+ *
+ * SOURCE CONTROL: 
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  MJLIU	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include <mach/star_sys_memory_map.h>
+
+#define I2S_MEM_MAP_ADDR(reg_offset)          (SYSVA_I2S_BASE_ADDR + reg_offset) 
+#define I2S_MEM_MAP_VALUE(reg_offset)         (*((unsigned int volatile *)I2S_MEM_MAP_ADDR(reg_offset)))
+
+//#define I2S_BASE_ADDR                         (SYS_I2S_BASE_ADDR)
+
+
+/*
+ * define access macros
+ */
+#define I2S_CONFIGURATION_REG_ADDR            I2S_MEM_MAP_ADDR(0xC0)
+#define I2S_RIGHT_TRANSMIT_DATA_REG_ADDR      I2S_MEM_MAP_ADDR(0xC4)
+#define I2S_LEFT_TRANSMIT_DATA_REG_ADDR       I2S_MEM_MAP_ADDR(0xC8)
+#define I2S_RIGHT_RECEIVE_DATA_REG_ADDR       I2S_MEM_MAP_ADDR(0xCC)
+#define I2S_LEFT_RECEIVE_DATA_REG_ADDR        I2S_MEM_MAP_ADDR(0xD0)
+#define I2S_INTERRUPT_STATUS_REG_ADDR         I2S_MEM_MAP_ADDR(0xD4)
+#define I2S_INTERRUPT_ENABLE_REG_ADDR         I2S_MEM_MAP_ADDR(0xD8)
+
+#define I2S_CONFIGURATION_REG                 I2S_MEM_MAP_VALUE(0xC0)
+#define I2S_RIGHT_TRANSMIT_DATA_REG           I2S_MEM_MAP_VALUE(0xC4)
+#define I2S_LEFT_TRANSMIT_DATA_REG            I2S_MEM_MAP_VALUE(0xC8)
+#define I2S_RIGHT_RECEIVE_DATA_REG            I2S_MEM_MAP_VALUE(0xCC)
+#define I2S_LEFT_RECEIVE_DATA_REG             I2S_MEM_MAP_VALUE(0xD0)
+#define I2S_INTERRUPT_STATUS_REG              I2S_MEM_MAP_VALUE(0xD4)
+#define I2S_INTERRUPT_ENABLE_REG              I2S_MEM_MAP_VALUE(0xD8)
+
+
+/*
+ * define constants macros
+ */
+#define I2S_DATA_16_BIT             (0)
+#define I2S_DATA_32_BIT             (1)
+
+#define I2S_RXBF_R_FULL_FLAG        (0x01)
+#define I2S_TXBF_R_EMPTY_FLAG       (0x02)
+#define I2S_RXBF_L_FULL_FLAG        (0x04)
+#define I2S_TXBF_L_EMPTY_FLAG       (0x08)
+
+#define I2S_RXBF_R_OR_FLAG          (0x10)
+#define I2S_TXBF_R_UR_FLAG          (0x20)
+#define I2S_RXBF_L_OR_FLAG          (0x40)
+#define I2S_TXBF_L_UR_FLAG          (0x80)
+
+
+#define I2S_MASTER_MODE             (1)
+#define I2S_SLAVE_MODE              (0)
+
+#define I2S_I2S_MODE                (1)
+#define I2S_RJF_MODE                (2)
+#define I2S_LJF_MODE                (3)
+
+#define I2S_CLOCK_CONTINUOUS_MODE   (0)
+#define I2S_CLOCK_256S_MODE         (1)
+
+
+#define I2S_WS_RATE_32KHZ           (1)    /* 8.192 MHz */
+#define I2S_WS_RATE_44_1KHZ         (2)    /* 11.2896 MHz */
+#define I2S_WS_RATE_48KHZ           (3)    /* 12.288 MHz */
+
+
+/*
+ * define data structure
+ */
+#if 0
+typedef struct _I2S_OBJECT_    I2S_OBJECT_T;
+
+struct _I2S_OBJECT_
+{
+    u_int32          config;
+    u_int32          interrupt_config;
+
+
+    /* 
+     * For interrupt setting
+     */
+    INTC_OBJECT_T    intc_obj;
+};
+
+
+/*
+ * function declarations
+ */
+void    Hal_I2s_Initialize(I2S_OBJECT_T *);
+#endif
+
+
+/*
+ * macro declarations
+ */
+#define HAL_I2S_ENABLE_I2S() \
+{ \
+    (I2S_CONFIGURATION_REG) |= ((u32)0x1 << 31); \
+}
+
+#define HAL_I2S_DISABLE_I2S() \
+{ \
+    (I2S_CONFIGURATION_REG) &= ~((u32)0x1 << 31); \
+}
+
+#define HAL_I2S_ENABLE_DATA_SWAP() \
+{ \
+    (I2S_CONFIGURATION_REG) |= (0x1 << 24); \
+}
+
+#define HAL_I2S_DISABLE_DATA_SWAP() \
+{ \
+    (I2S_CONFIGURATION_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_I2S_DISABLE_LEFT_CHANNEL_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_TXBF_L_UR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_RIGHT_CHANNEL_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_TXBF_R_UR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_LEFT_CHANNEL_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_RXBF_L_OR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_RIGHT_CHANNEL_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_RXBF_R_OR_FLAG); \
+}
+
+
+#endif  // end of #ifndef _STAR_I2S_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_ide.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_ide.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_ide.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_ide.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,245 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_IDE_H_
+#define	_STAR_IDE_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	IDE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_IDE_CONTROLLER_BASE_ADDR + reg_offset)))
+#define	IDE_BUS_MEM_MAP_VALUE(reg_offset)	(*((u8 volatile *)(SYSPA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#define IDE_DATA_MEM_MAP_VALUE(reg_offset)	(*((u16 volatile *)(SYSPA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	IDE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_IDE_CONTROLLER_BASE_ADDR + reg_offset)))
+#define	IDE_BUS_MEM_MAP_VALUE(reg_offset)	(*((u8 volatile *)(SYSVA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#define IDE_DATA_MEM_MAP_VALUE(reg_offset)	(*((u16 volatile *)(SYSVA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * IDE Controller Registers
+ */
+#define IDE_PIO_CONTROL_REG			IDE_MEM_MAP_VALUE(0x00)
+#define IDE_DRIVE0_PIO_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x04)
+#define IDE_DRIVE1_PIO_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x08)
+#define IDE_DRIVE0_DMA_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x0C)
+#define IDE_DRIVE1_DMA_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x10)
+#define IDE_UDMA_TIMING_CONFIG_REG		IDE_MEM_MAP_VALUE(0x14)
+#define IDE_DMA_UDMA_CONTROL_REG		IDE_MEM_MAP_VALUE(0x18)
+#define IDE_STATUS_CONTROL_REG			IDE_MEM_MAP_VALUE(0x1C)
+#define IDE_BUS_MASTER_DTP_REG			IDE_MEM_MAP_VALUE(0x20)
+#define IDE_FAST_PATH_ACCESS_WINDOW_REG		IDE_MEM_MAP_VALUE(0x24)
+#define IDE_FAST_PATH_DMA_BURST_SIZE_REG	IDE_MEM_MAP_VALUE(0x28)
+
+
+/*
+ * IDE Command Block Registers
+ */
+#define _IDE_DATA_REG				IDE_DATA_MEM_MAP_VALUE(0x20)
+#define _IDE_ERROR_REG				IDE_BUS_MEM_MAP_VALUE(0x24)
+#define _IDE_FEATURES_REG			IDE_BUS_MEM_MAP_VALUE(0x24)
+#define _IDE_SECTOR_COUNT_REG			IDE_BUS_MEM_MAP_VALUE(0x28)
+#define _IDE_LBA_LOW_REG			IDE_BUS_MEM_MAP_VALUE(0x2C)
+#define _IDE_LBA_MID_REG			IDE_BUS_MEM_MAP_VALUE(0x30)
+#define _IDE_LBA_HIGH_REG			IDE_BUS_MEM_MAP_VALUE(0x34)
+#define _IDE_DEVICE_REG				IDE_BUS_MEM_MAP_VALUE(0x38)
+#define _IDE_COMMAND_REG			IDE_BUS_MEM_MAP_VALUE(0x3C)
+#define _IDE_STATUS_REG				IDE_BUS_MEM_MAP_VALUE(0x3C)
+
+
+/*
+ * IDE Control Block Registers
+ */
+#define IDE_DEVICE_CONTROL_REG			IDE_BUS_MEM_MAP_VALUE(0x40)
+#define IDE_ALTERNATE_STATUS_REG		IDE_BUS_MEM_MAP_VALUE(0x40)
+
+
+#define IDE_CD					(0x01)
+#define IDE_IO					(0x02)
+#define IDE_REL					(0x04)
+#define IDE_OVL					(0x02)
+#define IDE_BSY					(0x80)
+#define IDE_DRQ					(0x08)
+#define IDE_SERV				(0x10)
+#define IDE_DMRD				(0x20)
+#define IDE_ERR					(0x01)
+#define IDE_SRST				(0x04)
+
+/*
+ * macro declarations for IDE Controller
+ */
+#define HAL_IDE_DRIVE0_IORDY_SAMPLE_ENABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) |= (0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE0_IORDY_SAMPLE_DISABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE1_IORDY_SAMPLE_ENABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) |= (0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE1_IORDY_SAMPLE_DISABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE0_UDMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 0); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_IDE_DRIVE0_UDMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE1_UDMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 1); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_DRIVE1_UDMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE0_DMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 2); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE0_DMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_IDE_DRIVE1_DMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 3); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_TO_USB_FAST_PATH_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 4); \
+}
+
+#define HAL_IDE_TO_USB_FAST_PATH_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 4); \
+}
+
+#define HAL_IDE_DRIVE1_DMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_DMA_UDMA_START() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1); \
+}
+
+#define HAL_IDE_DMA_UDMA_STOP() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1); \
+}
+
+#define HAL_IDE_CLEAR_PRD_INTERRUPT_STATUS() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 2); \
+}
+
+#define HAL_IDE_CLEAR_INTRQ_INTERRUPT_STATUS() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 1); \
+}
+
+#define HAL_IDE_HOST_TRANSFER_WRITE_OUT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 3); \
+}
+
+#define HAL_IDE_HOST_TRANSFER_READ_IN() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_MASK_PRD_INTERRUPT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 6); \
+}
+
+#define HAL_IDE_UNMASK_PRD_INTERRUPT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1 << 6); \
+}
+
+#define HAL_IDE_SET_DESCRIPTOR_TABLE_POINTER(dtp) \
+{ \
+    (IDE_BUS_MASTER_DTP_REG) = (dtp); \
+}
+
+#define HAL_IDE_SET_FAST_PATH_ACCESS_WINDOW(fp_access_window) \
+{ \
+    (IDE_FAST_PATH_ACCESS_WINDOW_REG) = (fp_access_window); \
+}
+
+/*
+ * macro declarations for IDE Device
+ */
+#define HAL_IDE_SELECT_DEVICE_0() \
+{ \
+    (_IDE_DEVICE_REG) = 0; \
+}
+
+#define HAL_IDE_SELECT_DEVICE_1() \
+{ \
+    (_IDE_DEVICE_REG) = (0x1 << 4); \
+}
+
+#define HAL_IDE_ENABLE_DEVICE_INTRQ() \
+{ \
+    (IDE_DEVICE_CONTROL_REG) = (0); \
+}
+
+#define HAL_IDE_DISABLE_DEVICE_INTRQ() \
+{ \
+    (IDE_DEVICE_CONTROL_REG) = (0x2); \
+}
+
+
+#endif  // end of #ifndef _STAR_IDE_H_
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_intc.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_intc.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_intc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_intc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,328 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_INTC_H_
+#define	_STAR_INTC_H_
+
+
+//#include <mach/star_sys_memory_map.h>
+#include <mach/star_sys_memory_map.h>
+
+#if defined(__UBOOT__)
+#define	INTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_VIC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	INTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_VIC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	INTC_INTERRUPT_RAW_STATUS_REG		INTC_MEM_MAP_VALUE(0x000)
+#define	INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG	INTC_MEM_MAP_VALUE(0x004)
+#define	INTC_INTERRUPT_MASK_REG			INTC_MEM_MAP_VALUE(0x008)
+#define	INTC_INTERRUPT_MASK_CLEAR_REG		INTC_MEM_MAP_VALUE(0x00C)
+#define	INTC_INTERRUPT_TRIGGER_MODE_REG		INTC_MEM_MAP_VALUE(0x010)
+#define	INTC_INTERRUPT_TRIGGER_LEVEL_REG	INTC_MEM_MAP_VALUE(0x014)
+#define	INTC_FIQ_SELECT_REG			INTC_MEM_MAP_VALUE(0x018)
+#define	INTC_IRQ_STATUS_REG			INTC_MEM_MAP_VALUE(0x01C)
+#define	INTC_FIQ_STATUS_REG			INTC_MEM_MAP_VALUE(0x020)
+#define	INTC_SOFTWARE_INTERRUPT_REG		INTC_MEM_MAP_VALUE(0x024)
+#define	INTC_SOFTWARE_INTERRUPT_CLEAR_REG	INTC_MEM_MAP_VALUE(0x028)
+#define	INTC_SOFTWARE_PRIORITY_MASK_REG		INTC_MEM_MAP_VALUE(0x02C)
+#define	INTC_POWER_MANAGEMENT_INTERRUPT_REG	INTC_MEM_MAP_VALUE(0x034)
+
+#define	INTC_VECTOR_ADDRESS_0_REG		INTC_MEM_MAP_VALUE(0x040)
+#define	INTC_VECTOR_ADDRESS_1_REG		INTC_MEM_MAP_VALUE(0x044)
+#define	INTC_VECTOR_ADDRESS_2_REG		INTC_MEM_MAP_VALUE(0x048)
+#define	INTC_VECTOR_ADDRESS_3_REG		INTC_MEM_MAP_VALUE(0x04C)
+#define	INTC_VECTOR_ADDRESS_4_REG		INTC_MEM_MAP_VALUE(0x050)
+#define	INTC_VECTOR_ADDRESS_5_REG		INTC_MEM_MAP_VALUE(0x054)
+#define	INTC_VECTOR_ADDRESS_6_REG		INTC_MEM_MAP_VALUE(0x058)
+#define	INTC_VECTOR_ADDRESS_7_REG		INTC_MEM_MAP_VALUE(0x05C)
+#define	INTC_VECTOR_ADDRESS_8_REG		INTC_MEM_MAP_VALUE(0x060)
+#define	INTC_VECTOR_ADDRESS_9_REG		INTC_MEM_MAP_VALUE(0x064)
+#define	INTC_VECTOR_ADDRESS_10_REG		INTC_MEM_MAP_VALUE(0x068)
+#define	INTC_VECTOR_ADDRESS_11_REG		INTC_MEM_MAP_VALUE(0x06C)
+#define	INTC_VECTOR_ADDRESS_12_REG		INTC_MEM_MAP_VALUE(0x070)
+#define	INTC_VECTOR_ADDRESS_13_REG		INTC_MEM_MAP_VALUE(0x074)
+#define	INTC_VECTOR_ADDRESS_14_REG		INTC_MEM_MAP_VALUE(0x078)
+#define	INTC_VECTOR_ADDRESS_15_REG		INTC_MEM_MAP_VALUE(0x07C)
+#define	INTC_VECTOR_ADDRESS_16_REG		INTC_MEM_MAP_VALUE(0x080)
+#define	INTC_VECTOR_ADDRESS_17_REG		INTC_MEM_MAP_VALUE(0x084)
+#define	INTC_VECTOR_ADDRESS_18_REG		INTC_MEM_MAP_VALUE(0x088)
+#define	INTC_VECTOR_ADDRESS_19_REG		INTC_MEM_MAP_VALUE(0x08C)
+#define	INTC_VECTOR_ADDRESS_20_REG		INTC_MEM_MAP_VALUE(0x090)
+#define	INTC_VECTOR_ADDRESS_21_REG		INTC_MEM_MAP_VALUE(0x094)
+#define	INTC_VECTOR_ADDRESS_22_REG		INTC_MEM_MAP_VALUE(0x098)
+#define	INTC_VECTOR_ADDRESS_23_REG		INTC_MEM_MAP_VALUE(0x09C)
+#define	INTC_VECTOR_ADDRESS_24_REG		INTC_MEM_MAP_VALUE(0x0A0)
+#define	INTC_VECTOR_ADDRESS_25_REG		INTC_MEM_MAP_VALUE(0x0A4)
+#define	INTC_VECTOR_ADDRESS_26_REG		INTC_MEM_MAP_VALUE(0x0A8)
+#define	INTC_VECTOR_ADDRESS_27_REG		INTC_MEM_MAP_VALUE(0x0AC)
+#define	INTC_VECTOR_ADDRESS_28_REG		INTC_MEM_MAP_VALUE(0x0B0)
+#define	INTC_VECTOR_ADDRESS_29_REG		INTC_MEM_MAP_VALUE(0x0B4)
+#define	INTC_VECTOR_ADDRESS_30_REG		INTC_MEM_MAP_VALUE(0x0B8)
+#define	INTC_VECTOR_ADDRESS_31_REG		INTC_MEM_MAP_VALUE(0x0BC)
+
+#define	INTC_INTERRUPT_PRIORITY_0_REG		INTC_MEM_MAP_VALUE(0x0C0)
+#define	INTC_INTERRUPT_PRIORITY_1_REG		INTC_MEM_MAP_VALUE(0x0C4)
+#define	INTC_INTERRUPT_PRIORITY_2_REG		INTC_MEM_MAP_VALUE(0x0C8)
+#define	INTC_INTERRUPT_PRIORITY_3_REG		INTC_MEM_MAP_VALUE(0x0CC)
+#define	INTC_INTERRUPT_PRIORITY_4_REG		INTC_MEM_MAP_VALUE(0x0D0)
+#define	INTC_INTERRUPT_PRIORITY_5_REG		INTC_MEM_MAP_VALUE(0x0D4)
+#define	INTC_INTERRUPT_PRIORITY_6_REG		INTC_MEM_MAP_VALUE(0x0D8)
+#define	INTC_INTERRUPT_PRIORITY_7_REG		INTC_MEM_MAP_VALUE(0x0DC)
+#define	INTC_INTERRUPT_PRIORITY_8_REG		INTC_MEM_MAP_VALUE(0x0E0)
+#define	INTC_INTERRUPT_PRIORITY_9_REG		INTC_MEM_MAP_VALUE(0x0E4)
+#define	INTC_INTERRUPT_PRIORITY_10_REG		INTC_MEM_MAP_VALUE(0x0E8)
+#define	INTC_INTERRUPT_PRIORITY_11_REG		INTC_MEM_MAP_VALUE(0x0EC)
+#define	INTC_INTERRUPT_PRIORITY_12_REG		INTC_MEM_MAP_VALUE(0x0F0)
+#define	INTC_INTERRUPT_PRIORITY_13_REG		INTC_MEM_MAP_VALUE(0x0F4)
+#define	INTC_INTERRUPT_PRIORITY_14_REG		INTC_MEM_MAP_VALUE(0x0F8)
+#define	INTC_INTERRUPT_PRIORITY_15_REG		INTC_MEM_MAP_VALUE(0x0FC)
+#define	INTC_INTERRUPT_PRIORITY_16_REG		INTC_MEM_MAP_VALUE(0x100)
+#define	INTC_INTERRUPT_PRIORITY_17_REG		INTC_MEM_MAP_VALUE(0x104)
+#define	INTC_INTERRUPT_PRIORITY_18_REG		INTC_MEM_MAP_VALUE(0x108)
+#define	INTC_INTERRUPT_PRIORITY_19_REG		INTC_MEM_MAP_VALUE(0x10C)
+#define	INTC_INTERRUPT_PRIORITY_20_REG		INTC_MEM_MAP_VALUE(0x110)
+#define	INTC_INTERRUPT_PRIORITY_21_REG		INTC_MEM_MAP_VALUE(0x114)
+#define	INTC_INTERRUPT_PRIORITY_22_REG		INTC_MEM_MAP_VALUE(0x118)
+#define	INTC_INTERRUPT_PRIORITY_23_REG		INTC_MEM_MAP_VALUE(0x11C)
+#define	INTC_INTERRUPT_PRIORITY_24_REG		INTC_MEM_MAP_VALUE(0x120)
+#define	INTC_INTERRUPT_PRIORITY_25_REG		INTC_MEM_MAP_VALUE(0x124)
+#define	INTC_INTERRUPT_PRIORITY_26_REG		INTC_MEM_MAP_VALUE(0x128)
+#define	INTC_INTERRUPT_PRIORITY_27_REG		INTC_MEM_MAP_VALUE(0x12C)
+#define	INTC_INTERRUPT_PRIORITY_28_REG		INTC_MEM_MAP_VALUE(0x130)
+#define	INTC_INTERRUPT_PRIORITY_29_REG		INTC_MEM_MAP_VALUE(0x134)
+#define	INTC_INTERRUPT_PRIORITY_30_REG		INTC_MEM_MAP_VALUE(0x138)
+#define	INTC_INTERRUPT_PRIORITY_31_REG		INTC_MEM_MAP_VALUE(0x13C)
+
+#define	INTC_IRQ_VECTOR_ADDRESS_REG		INTC_MEM_MAP_VALUE(0x140)
+
+#define	INTC_VECTOR_INTERRUPT_ENABLE_REG	INTC_MEM_MAP_VALUE(0x144)
+
+
+
+/*
+ * define constants macros
+ */
+#define	INTC_TIMER1_BIT_INDEX			(0)
+#define	INTC_TIMER2_BIT_INDEX			(1)
+
+#define	INTC_CLOCK_SCALE_BIT_INDEX		(2)
+
+#define	INTC_WATCHDOG_TIMER_BIT_INDEX		(3)
+
+#define	INTC_GPIO_EXTERNAL_INT_BIT_INDEX	(4)
+
+#define	INTC_PCI_INTA_BIT_INDEX			(5)
+#define	INTC_PCI_INTB_BIT_INDEX			(6)
+#define	INTC_PCI_BROKEN_BIT_INDEX		(7)
+#define	INTC_PCI_AHB2BRIDGE_BIT_INDEX		(8)
+
+#define	INTC_UART0_BIT_INDEX			(9)
+#define	INTC_UART1_BIT_INDEX			(10)
+
+#define	INTC_GDMAC_TC_BIT_INDEX			(11)
+#define	INTC_GDMAC_ERROR_BIT_INDEX		(12)
+
+#define	INTC_PCMCIA_BRIDGE_BIT_INDEX		(13)
+
+#define	INTC_RTC_BIT_INDEX			(14)
+
+#define	INTC_PCM_BIT_INDEX			(15)
+
+#define	INTC_USB20_DEVICE_BIT_INDEX		(16)
+
+#define	INTC_IDE_BIT_INDEX			(17)
+
+#define	INTC_NIC_STATUS_BIT_INDEX		(18)
+#define	INTC_NIC_TXTC_BIT_INDEX			(19)
+#define	INTC_NIC_RXRC_BIT_INDEX			(20)
+#define	INTC_NIC_TXQE_BIT_INDEX			(21)
+#define	INTC_NIC_RXQF_BIT_INDEX			(22)
+
+#define	INTC_USB11_BIT_INDEX			(23)
+#define	INTC_USB20_BIT_INDEX			(24)
+
+#define	INTC_I2S_BIT_INDEX			(25)
+#define	INTC_SPI_BIT_INDEX			(26)
+#define	INTC_I2C_BIT_INDEX			(27)
+
+#define	INTC_USB_DEVICE_VBUS_BIT_INDEX		(28)
+
+#define	INTC_EXT_INT29_BIT_INDEX		(29)
+#define	INTC_EXT_INT30_BIT_INDEX		(30)
+#define	INTC_HSDMAC_BIT_INDEX			(31)
+
+
+/*
+ * define interrupt types
+ */
+#define	INTC_IRQ_INTERRUPT			(0)
+#define	INTC_FIQ_INTERRUPT			(1)
+
+/*
+ * define interrupt trigger mode
+ */
+#define	INTC_LEVEL_TRIGGER			(0)
+#define	INTC_EDGE_TRIGGER			(1)
+
+/*
+ * define rising/falling edge for edge trigger mode
+ */
+#define	INTC_RISING_EDGE			(0)
+#define	INTC_FALLING_EDGE			(1)
+
+/*
+ * define active High/Low for level trigger mode
+ */
+#define	INTC_ACTIVE_HIGH			(0)
+#define	INTC_ACTIVE_LOW				(1)
+
+/*
+ * macro declarations
+ */
+#define	HAL_INTC_READ_INTERRUPT_RAW_STATUS(int_raw_status) \
+{ \
+    (int_raw_status) = (INTC_INTERRUPT_RAW_STATUS_REG);	\
+}
+
+
+#define	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(source_bit_index)	\
+{ \
+    (INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG) = (1	<< source_bit_index); \
+}
+
+
+#define	HAL_INTC_READ_INTERRUPT_MASK(int_mask) \
+{ \
+    (int_mask) = (INTC_INTERRUPT_MASK_REG); \
+}
+
+
+#define	HAL_INTC_WRITE_INTERRUPT_MASK(int_mask)	\
+{ \
+    (INTC_INTERRUPT_MASK_REG) =	(int_mask); \
+}
+
+
+#define	HAL_INTC_DISABLE_INTERRUPT_SOURCE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_MASK_REG) =	(1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_ENABLE_INTERRUPT_SOURCE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_MASK_CLEAR_REG) = (1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_SET_EDGE_TRIGGER_MODE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_MODE_REG) |= (1 << source_bit_index);\
+}
+
+
+#define	HAL_INTC_SET_LEVEL_TRIGGER_MODE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_MODE_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_SET_RISING_EDGE_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_SET_FALLING_EDGE_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) |= (1 <<	source_bit_index); \
+}
+
+
+#define	HAL_INTC_SET_ACTIVE_HIGH_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) &= (~(1 << source_bit_index));\
+}
+
+
+#define	HAL_INTC_SET_ACTIVE_LOW_TRIGGER_LEVEL(source_bit_index)	\
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) |= ((1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_ASSIGN_INTERRUPT_TO_IRQ(source_bit_index) \
+{ \
+    (INTC_FIQ_SELECT_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_ASSIGN_INTERRUPT_TO_FIQ(source_bit_index) \
+{ \
+    (INTC_FIQ_SELECT_REG) |= (1	<< source_bit_index); \
+}
+
+
+#define	HAL_INTC_READ_IRQ_STATUS(int_irq_status) \
+{ \
+    (int_irq_status) = (INTC_IRQ_STATUS_REG); \
+}
+
+
+#define	HAL_INTC_READ_FIQ_STATUS(int_fiq_status) \
+{ \
+    (int_fiq_status) = (INTC_FIQ_STATUS_REG); \
+}
+
+
+#define	HAL_INTC_READ_SOFTWARE_INTERRUPT(software_interrupt) \
+{ \
+    (software_interrupt) = (INTC_SOFTWARE_INTERRUPT_REG); \
+}
+
+
+#define	HAL_INTC_ENABLE_SOFTWARE_INTERRUPT(source_bit_index) \
+{ \
+    (INTC_SOFTWARE_INTERRUPT_REG) = (1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_CLEAR_SOFTWARE_INTERRUPT(source_bit_index) \
+{ \
+    (INTC_SOFTWARE_INTERRUPT_CLEAR_REG)	= (1 <<	source_bit_index); \
+}
+
+
+#define	HAL_INTC_SELECT_INTERRUPT_SOURCE_FOR_SLEEP_WAKEUP(source_bit_index) \
+{ \
+    (INTC_POWER_MANAGEMENT_INTERRUPT_REG) = (1 << source_bit_index); \
+}
+
+#endif	// end of #ifndef _STAR_INTC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_misc.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_misc.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_misc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_misc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,402 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_MISC_H_
+#define	_STAR_MISC_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	MISC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_MISC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	MISC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_MISC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	MISC_MEMORY_REMAP_REG				MISC_MEM_MAP_VALUE(0x00)
+#define	MISC_CHIP_CONFIG_REG				MISC_MEM_MAP_VALUE(0x04)
+#define	MISC_DEBUG_PROBE_DATA_REG			MISC_MEM_MAP_VALUE(0x08)
+#define	MISC_DEBUG_PROBE_SELECTION_REG			MISC_MEM_MAP_VALUE(0x0C)
+#define	MISC_PCI_CONTROL_BROKEN_MASK_REG		MISC_MEM_MAP_VALUE(0x10)
+#define	MISC_PCI_BROKEN_STATUS_REG			MISC_MEM_MAP_VALUE(0x14)
+#define	MISC_PCI_DEVICE_VENDOR_ID_REG			MISC_MEM_MAP_VALUE(0x18)
+#define	MISC_USB_HOST_PHY_CONTROL_TEST_REG		MISC_MEM_MAP_VALUE(0x1C)
+#define	MISC_GPIOA_PIN_ENABLE_REG			MISC_MEM_MAP_VALUE(0x20)
+#define	MISC_GPIOB_PIN_ENABLE_REG			MISC_MEM_MAP_VALUE(0x24)
+#define	MISC_GPIOA_RESISTOR_CONFIG_REG			MISC_MEM_MAP_VALUE(0x28)
+#define	MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG		MISC_MEM_MAP_VALUE(0x2C)
+#define	MISC_FAST_ETHERNET_PHY_CONFIG_REG		MISC_MEM_MAP_VALUE(0x30)
+#define	MISC_SOFTWARE_TEST_1_REG			MISC_MEM_MAP_VALUE(0x38)
+#define	MISC_SOFTWARE_TEST_2_REG			MISC_MEM_MAP_VALUE(0x3C)
+
+#define	MISC_E_FUSE_0_REG				MISC_MEM_MAP_VALUE(0x60)
+#define	MISC_E_FUSE_1_REG				MISC_MEM_MAP_VALUE(0x64)
+
+
+/*
+ * define constants macros
+ */
+#define	MISC_PARALLEL_FLASH_BOOT		(0)
+#define	MISC_SPI_SERIAL_FLASH_BOOT		(1)
+
+#define	MISC_LITTLE_ENDIAN			(0)
+#define	MISC_BIG_ENDIAN				(1)
+
+#define	MISC_FARADAY_ICE			(0)
+#define	MISC_ARM_ICE				(1)
+
+#define	MISC_EXT_INT29_PINS			((0x1 << 0))
+#define	MISC_EXT_INT30_PINS			((0x1 << 1))
+#define	MISC_EXT_INT31_PINS			((0x1 << 2))
+#define	MISC_I2C_PINS				((0x1 << 13) | (0x1 << 14))
+#define	MISC_I2S_PINS				((0x1 << 15) | (0x1 << 16) | (0x1 << 17))
+#define	MISC_PCM_PINS				((0x1 << 18) | (0x1 << 19) | (0x1 << 20) | (0x1 << 21))
+#define	MISC_LED0_PINS				((0x1 << 22))
+#define	MISC_LED1_PINS				((0x1 << 23))
+#define	MISC_LED2_PINS				((0x1 << 24))
+#define	MISC_LED012_PINS			((0x1 << 22) | (0x1 << 23) | (0x1 << 24))
+#define	MISC_WDTIMER_RESET_PINS			((0x1 << 25))
+#define	MISC_SPI_PINS				((0x1 << 26) | (0x1 << 27) | (0x1 << 28) | (0x1 << 29) | (0x1 << 30) | (0x1 << 31))
+#define	MISC_MDC_MDIO_PINS			((0x1 << 0) | (0x1 << 1))
+#define	MISC_NIC_COL_PINS			((0x1 << 2))
+#define	MISC_IDE_PINS				((0xFF << 3))
+#define	MISC_SRAM_BANK1_PINS			((0x1 << 11) | (0x1 << 14))
+#define	MISC_SRAM_BANK2_PINS			((0x1 << 12) | (0x1 << 15))
+#define	MISC_SRAM_BANK3_PINS			((0x1 << 13) | (0x1 << 16))
+#define	MISC_PCMCIA_PINS			((0x1 << 17) | (0x1 << 18) | (0x1 << 19) | (0x1 << 20))
+#define	MISC_UART1_PINS				((0x1 << 21) | (0x1 << 22))
+#define	MISC_PCI_PINS				(((u32)0x1FF << 23))
+
+#define	MISC_UART0_ACT0_Pin			(0x1 << 2)
+#define	MISC_UART1_ACT1_Pin			(0x1 << 3)
+
+#define	MISC_GPIOA_PIN_0			(0)
+#define	MISC_GPIOA_PIN_1			(1)
+#define	MISC_GPIOA_PIN_2			(2)
+#define	MISC_GPIOA_PIN_3			(3)
+#define	MISC_GPIOA_PIN_4			(4)
+#define	MISC_GPIOA_PIN_5			(5)
+#define	MISC_GPIOA_PIN_6			(6)
+#define	MISC_GPIOA_PIN_7			(7)
+#define	MISC_GPIOA_PIN_8			(8)
+#define	MISC_GPIOA_PIN_9			(9)
+#define	MISC_GPIOA_PIN_10			(10)
+
+#define	MISC_GPIOA_75K_RESISTOR_PULL_DOWN	(1)
+#define	MISC_GPIOA_75K_RESISTOR_PULL_UP		(2)
+#define	MISC_GPIOA_75K_RESISTOR_PULL_KEEPER	(3)
+
+#define	MISC_GPIOA_DRIVE_STRENGTH_4MA		(0)
+#define	MISC_GPIOA_DRIVE_STRENGTH_8MA		(1)
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_MISC_ENABLE_SPI_SERIAL_FLASH_BANK_ACCESS() \
+{ \
+    (MISC_CHIP_CONFIG_REG) |= (0x1 << 4); \
+}
+
+#define	HAL_MISC_DISABLE_SPI_SERIAL_FLASH_BANK_ACCESS()	\
+{ \
+    (MISC_CHIP_CONFIG_REG) &= ~(0x1 << 4); \
+}
+
+
+/*
+ * Macro defines for GPIOA and GPIOB Pin Enable	Register
+ */
+#define	HAL_MISC_ENABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT29_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT29_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT30_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT30_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2C_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2C_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2S_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2S_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_PCM_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCM_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED0_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED0_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED2_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED2_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED012_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED012_PINS);	\
+}
+
+#define	HAL_MISC_ENABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_WDTIMER_RESET_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_WDTIMER_RESET_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPI_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPI_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART0_ACT0_Pin); \
+}
+
+#define	HAL_MISC_DISABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART0_ACT0_Pin); \
+}
+
+#define	HAL_MISC_ENABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART1_ACT1_Pin); \
+}
+
+#define	HAL_MISC_DISABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART1_ACT1_Pin); \
+}
+
+#define	HAL_MISC_ENABLE_MDC_MDIO_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_MDC_MDIO_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_MDC_MDIO_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_MDC_MDIO_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_NIC_COL_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_NIC_COL_PINS);	\
+}
+
+#define	HAL_MISC_DISABLE_NIC_COL_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_NIC_COL_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_IDE_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_IDE_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK2_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK2_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK3_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK3_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCMCIA_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCMCIA_PINS);	\
+}
+
+#define	HAL_MISC_ENABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_UART1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_UART1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCI_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCI_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_ALL_SHARED_GPIO_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0x0); \
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0x0); \
+}
+
+#define	HAL_MISC_DISABLE_ALL_SHARED_GPIO_PINS()	\
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+}
+
+#define	HAL_MISC_CONFIGURE_GPIOA_RESISTOR(pin_index, value) \
+{ \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) &=	~(0x3 << (2 * pin_index)); \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) |=	((value	& 0x3) << (2 * pin_index)); \
+}
+
+#define	HAL_MISC_CONFIGURE_GPIOA_DRIVE_STRENGTH(pin_index, value) \
+{ \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) &= ~(0x1 << pin_index); \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) |= (value <<	pin_index); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE0() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x0); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE1() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x1); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE2() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x2); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE3() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x3); \
+}
+
+
+#endif	// end of #ifndef _STAR_MISC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_nic.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_nic.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_nic.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_nic.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,346 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_NIC_H_
+#define	_STAR_NIC_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_NIC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_NIC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	NIC_PHY_CONTROL_REG0			NIC_MEM_MAP_VALUE(0x000)
+#define	NIC_PHY_CONTROL_REG1			NIC_MEM_MAP_VALUE(0x004)
+
+#define	NIC_MAC_CONTROL_REG			NIC_MEM_MAP_VALUE(0x008)
+#define	NIC_FLOW_CONTROL_CONFIG_REG		NIC_MEM_MAP_VALUE(0x00C)
+
+#define	NIC_ARL_CONFIG_REG			NIC_MEM_MAP_VALUE(0x010)
+
+#define	NIC_MY_MAC_HIGH_BYTE_REG		NIC_MEM_MAP_VALUE(0x014)
+#define	NIC_MY_MAC_LOW_BYTE_REG			NIC_MEM_MAP_VALUE(0x018)
+
+#define	NIC_HASH_TABLE_CONTROL_REG		NIC_MEM_MAP_VALUE(0x01C)
+
+#define	NIC_MY_VLANID_CONTROL_REG		NIC_MEM_MAP_VALUE(0x020)
+
+#define	NIC_MY_VLANID_0_1			NIC_MEM_MAP_VALUE(0x024)
+#define	NIC_MY_VLANID_2_3			NIC_MEM_MAP_VALUE(0x028)
+
+#define	NIC_DMA_CONFIG_REG			NIC_MEM_MAP_VALUE(0x030)
+#define	NIC_TX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x034)
+#define	NIC_RX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x038)
+#define	NIC_TX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x03C)
+#define	NIC_RX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x040)
+
+#define	NIC_TX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x044)
+#define	NIC_RX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x048)
+#define	NIC_DELAYED_INT_CONFIG_REG		NIC_MEM_MAP_VALUE(0x04C)
+
+#define	NIC_INT_STATUS_REG			NIC_MEM_MAP_VALUE(0x050)
+#define	NIC_INT_MASK_REG			NIC_MEM_MAP_VALUE(0x054)
+
+#define	NIC_TEST_0_REG				NIC_MEM_MAP_VALUE(0x058)
+#define	NIC_TEST_1_REG				NIC_MEM_MAP_VALUE(0x05C)
+
+#define	NIC_MIB_RX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x100)
+#define	NIC_MIB_RX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x104)
+#define	NIC_MIB_RX_RUNT_BYTE_CNTR		NIC_MEM_MAP_VALUE(0x108)
+#define	NIC_MIB_RX_OSIZE_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x10C)
+
+#define	NIC_MIB_RX_NO_BUF_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x110)
+
+#define	NIC_MIB_RX_CRC_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x114)
+
+#define	NIC_MIB_RX_ARL_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x118)
+
+#define	NIC_MIB_MYVLANID_MISMATCH_DROP_PKT_CNTR	NIC_MEM_MAP_VALUE(0x11C)
+
+#define	NIC_MIB_RX_CHKSUM_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x120)
+
+#define	NIC_MIB_RX_PAUSE_FRAME_PKT_CNTR		NIC_MEM_MAP_VALUE(0x124)
+
+#define	NIC_MIB_TX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x128)
+#define	NIC_MIB_TX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x12C)
+
+#define	NIC_MIB_TX_COLLISION_CNTR		NIC_MEM_MAP_VALUE(0x130)
+#define	NIC_MIB_TX_PAUSE_FRAME_CNTR		NIC_MEM_MAP_VALUE(0x130)
+
+#define	NIC_MIB_TX_FIFO_UNDERRUN_RETX_CNTR	NIC_MEM_MAP_VALUE(0x134)
+
+
+
+
+/*
+ * define constants macros
+ */
+
+#define	NIC_PHY_ADDRESS		1 //the phy addr const	value
+#define	NIC_PHY_ID		0x0243	//the phy id
+
+#define	GW_NIC_MAX_TFD_NUM	(32)
+#define	GW_NIC_MAX_RFD_NUM	(32)
+#define	MAX_BUFFERS		(64)
+
+
+
+#define	MMU_OFF			(0)
+#define	MMU_ON			(1)
+#define	OS_NULL			(0)
+
+
+#define	NET_BUFFER_PACKET_SIZE		(512)
+#define	NET_BUFFER_SHIFT_BIT_NUM	(9)	// 2*n9=512
+
+#define	MAX_PACKET_LEN		(1536)
+
+#define	INTERNAL_LOOPBACK_MODE	(1)
+#define	SOFTWARE_REPEATER_MODE	(2)
+
+#define	TXTC_INT_BIT		(0x08000000)
+#define	TX_INSV_BIT		(0x04000000)
+
+#define	LS_BIT			(0x10000000)
+#define	FS_BIT			(0x20000000)
+#define	EOR_BIT			(0x40000000)
+#define	FS_LS_BIT		(0x30000000)
+#define	C_BIT			(0x80000000)
+#define	FS_LS_C_BIT		(0xB0000000)
+#define	FS_LS_INT_BIT		(0x38000000)
+
+
+
+// HASH	TABLE CONTROL REGISTER
+#define	NIC_HASH_TABLE_BIST_DONE_BIT	(0x1 <<	17)
+#define	NIC_HASH_TABLE_BIST_OK_BIT	(0x1 <<	16)
+#define	NIC_HASH_COMMAND_START_BIT	(0x1 <<	14)
+#define	NIC_HASH_COMMAND_BIT		(0x1 <<	13)
+#define	NIC_HASH_BIT_DATA		(0x1 <<	12)
+#define	NIC_HASH_BIT_ADDRESS_BIT	(0x1ff)
+
+
+#define	NIC_REG_CNT			((0x48 << 2) + 1)
+
+/*
+ * macro access
+ */
+
+#define	GW_NIC_TX_TFD_NEXT(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ (((u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) + 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_TX_TFD_PREVIOUS(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ ((GW_NIC_MAX_TFD_NUM + (u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) - 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_NEXT(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ (((u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) + 1) % GW_NIC_MAX_RFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_PREVIOUS(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ ((GW_NIC_MAX_RFD_NUM + (u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) - 1) % GW_NIC_MAX_RFD_NUM)
+
+
+/*
+ * PHY register	defines
+ */
+#define	PHY_MII_CONTROL_REG_ADDR		0x00
+#define	PHY_MII_STATUS_REG_ADDR			0x01
+#define	PHY_ID1_REG_ADDR			0x02
+#define	PHY_ID2_REG_ADDR			0x03
+#define	PHY_AN_ADVERTISEMENT_REG_ADDR		0x04
+#define	PHY_AN_REAMOTE_CAP_REG_ADDR		0x05
+
+
+#define	PHY_RESERVED1_REG_ADDR			0x10
+#define	PHY_RESERVED2_REG_ADDR			0x11
+#define	PHY_CH_STATUS_OUTPUT_REG_ADDR		0x12
+#define	PHY_RESERVED3_REG_ADDR			0x13
+#define	PHY_RESERVED4_REG_ADDR			0x14
+
+
+#define	PHY_SPEC_CONTROL_REG_ADDR		0x16
+#define	PHY_INTC_CONTROL_STATUS_REG_ADDR	0x17
+
+/*
+ * NIC registers access	macros defines
+ */
+
+//0x004
+#define	HAL_NIC_WRITE_PHY_CONTROL1(config_value) \
+    ((NIC_PHY_CONTROL_REG1) = (config_value))
+
+#define	HAL_NIC_READ_PHY_CONTROL1(config_value)	\
+    ((config_value) = (NIC_PHY_CONTROL_REG1))
+
+//0x008
+#define	HAL_NIC_WRITE_MAC_CONFIGURATION(config_value) \
+    ((NIC_MAC_CONTROL_REG) = (config_value))
+
+#define	HAL_NIC_READ_MAC_CONFIGURATION(config_value) \
+    ((config_value) = (NIC_MAC_CONTROL_REG))
+
+//0x00C
+#define	HAL_NIC_WRITE_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((NIC_FLOW_CONTROL_CONFIG_REG) = (fc_cfg))
+
+#define	HAL_NIC_READ_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((fc_cfg) =	(NIC_FLOW_CONTROL_CONFIG_REG))
+
+//0x010
+#define	HAL_NIC_WRITE_ARL_CONFIGURATION(cfg) \
+    ((NIC_ARL_CONFIG_REG) = (cfg))
+
+#define	HAL_NIC_READ_ARL_CONFIGURATION(cfg) \
+    ((cfg) = (NIC_ARL_CONFIG_REG))
+
+//0x014,
+#define	HAL_NIC_WRITE_MY_MAC_HIGH_BYTE(cfg) \
+    ((NIC_MY_MAC_HIGH_BYTE_REG)	= (cfg & 0x0000FFFF ) )
+
+#define	HAL_NIC_READ_MY_MAC_HIGH_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_HIGH_BYTE_REG & 0x0000FFFF ))
+
+//0x018
+#define	HAL_NIC_WRITE_MY_MAC_LOW_BYTE(cfg) \
+    ((NIC_MY_MAC_LOW_BYTE_REG) = (cfg))
+
+#define	HAL_NIC_READ_MY_MAC_LOW_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_LOW_BYTE_REG))
+
+//0x03C
+#define	HAL_NIC_READ_INTERRUPT_STATUS(int_status) \
+    ((int_status) = (NIC_INT_STATUS_REG))
+
+#define	HAL_NIC_CLEAR_ALL_INTERRUPT_STATUS_SOURCES()\
+    ((NIC_INT_STATUS_REG) = (0xFFFFFFFF))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCES(source) \
+    ((NIC_INT_STATUS_REG) |= (source))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_STATUS_REG) |= (1	<< (source_bit_index)))
+
+//0x040
+#define	HAL_NIC_DISABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0xFFFFFFFF))
+
+#define	HAL_NIC_ENABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0x00000000))
+
+#define	HAL_NIC_DISABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	|= (1 << (source_bit_index)))
+
+#define	HAL_NIC_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	&= ~(1 << (source_bit_index)))
+
+//0x44
+#define	HAL_NIC_WRITE_TEST0_REG(cfg) \
+    ((NIC_TEST_0_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST0_REG(cfg) \
+    ((cfg) = (NIC_TEST_0_REG))
+
+//0x48
+#define	HAL_NIC_WRITE_TEST1_REG(cfg) \
+    ((NIC_TEST_1_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST1_REG(cfg) \
+    ((cfg) = (NIC_TEST_1_REG))
+
+
+
+/*
+ * NIC's DMA macros defines
+ */
+#define	HAL_NIC_TX_DMA_START() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_TX_DMA_STOP() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_READ_TX_DMA_STATE(state) \
+    ((state) = (NIC_TX_DMA_CONTROL_REG))
+
+
+#define	HAL_NIC_RX_DMA_START() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_RX_DMA_STOP() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_WRITE_TXSD(tssd_value) \
+    ((NIC_TX_DESC_PTR_REG) = (tssd_value))
+
+
+#define	HAL_NIC_READ_TXSD(tssd_value) \
+    ((tssd_value) = (NIC_TX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_RXSD(fssd_value) \
+    ((NIC_RX_DESC_PTR_REG) = (fssd_value))
+
+
+#define	HAL_NIC_READ_RXSD(fssd_value) \
+    ((fssd_value) = (NIC_RX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_TX_BASE(ts_base_value) \
+    ((NIC_TX_DESC_BASE_ADDR_REG) = (ts_base_value))
+
+
+#define	HAL_NIC_READ_TX_BASE(ts_base_value) \
+    ((ts_base_value) = (NIC_TX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_RX_BASE(fs_base_value) \
+    ((NIC_RX_DESC_BASE_ADDR_REG) = (fs_base_value))
+
+
+#define	HAL_NIC_READ_RX_BASE(fs_base_value) \
+    ((fs_base_value) = (NIC_RX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config) \
+    ((NIC_DELAYED_INT_CONFIG_REG) = (delayed_interrupt_config))
+
+
+#define	HAL_NIC_READ_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config)	\
+    ((delayed_interrupt_config)	= (NIC_DELAYED_INT_CONFIG_REG))
+
+#endif	// end of #ifndef _STAR_NIC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pci_bridge.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pci_bridge.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pci_bridge.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pci_bridge.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,132 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_PCI_DRIDGE_H_
+#define	_STAR_PCI_DRIDGE_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#define	PCI_IO_SPACE_BASE_ADDR			(SYSPA_PCI_IO_SPACE_BASE_ADDR)
+#define PCI_IO_SPACE_SIZE			0x08000000 /* 64MB */
+#define PCI_IO_SPACE_START			PCI_IO_SPACE_BASE_ADDR
+#define PCI_IO_SPACE_END			(PCI_IO_SPACE_BASE_ADDR + PCI_IO_SPACE_SIZE - 1)
+#define	PCI_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCI_MEMORY_SPACE_BASE_ADDR)
+#define PCI_MEMORY_SPACE_SIZE			0x10000000 /* 256MB */
+#define PCI_NPREFETCH_MEMORY_SPACE_START	PCI_MEMORY_SPACE_BASE_ADDR
+#define PCI_NPREFETCH_MEMORY_SPACE_SIZE		0x00800000 /* 8MB */
+#define PCI_NPREFETCH_MEMORY_SPACE_END		(PCI_NPREFETCH_MEMORY_SPACE_START + PCI_NPREFETCH_MEMORY_SPACE_SIZE - 1)
+#define PCI_PREFETCH_MEMORY_SPACE_START		(PCI_NPREFETCH_MEMORY_SPACE_START + PCI_NPREFETCH_MEMORY_SPACE_SIZE)
+#define PCI_PREFETCH_MEMORY_SPACE_SIZE		0x00800000 /* 8MB */
+#define PCI_PREFETCH_MEMORY_SPACE_END		(PCI_PREFETCH_MEMORY_SPACE_START + PCI_PREFETCH_MEMORY_SPACE_SIZE - 1)
+
+
+#if defined(__UBOOT__)
+#define	PCIB_MEM_MAP_VALUE(base, reg_offset)	(*((u32 volatile *)(SYSPA_PCI_##base##_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PCIB_MEM_MAP_VALUE(base, reg_offset)	(*((u32 volatile *)(SYSVA_PCI_##base##_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PCI_BRIDGE_CONFIG_DATA			PCIB_MEM_MAP_VALUE(CONFIG_DATA_BASE, 0x2C)
+#define	PCI_BRIDGE_CONFIG_ADDR			PCIB_MEM_MAP_VALUE(CONFIG_ADDR_BASE, 0x28)
+
+#define PCI_BRIDGE_CONFIG_DATA_REG_OFFSET	0x2C
+#define PCI_BRIDGE_CONFIG_ADDR_REG_OFFSET	0x28
+
+/*
+ * define constants macros
+ */
+#define	PCIB_BUS_CLOCK_33M			1
+
+#define	PCIB_BUS_CLOCK_66M			2
+
+#define	PCIB_DEVICE_ID				0x8131
+
+#define	PCIB_VENDOR_ID				0xEEEE
+
+#define	PCIB_CLASS_CODE				0xFF0000
+
+#define	PCIB_REVISION_ID			0x00
+
+#define	PCIB_BAR0_MEMORY_SPACE_BASE		0x20000000
+
+#define	PCIB_BAR1_IO_SPACE_BASE			0x20000000
+
+
+#define	PCI_MEMORY_SPACE_BASE			0xB0000000
+
+#define	PCI_IO_SPACE_BASE			0xA8000000
+
+
+#define	PCI_MAX_BUS_NUM				0x01
+#define	PCI_MAX_DEVICE_NUM			0x14
+#define	PCI_MAX_FUNCTION_NUM			0x01
+#define	PCI_MAX_REG_NUM				0x3C
+
+
+#define	PCI_MAX_DEVICE_TYPE_NUM			0x13
+#define	PCI_MAX_BAR_NUM				0x06
+
+
+#define	PCI_CSH_VENDOR_ID_REG_ADDR		0x00
+#define	PCI_CSH_DEVICE_ID_REG_ADDR		0x02
+#define	PCI_CSH_COMMAND_REG_ADDR		0x04
+#define	PCI_CSH_STATUS_REG_ADDR			0x06
+#define	PCI_CSH_REVISION_CLASS_REG_ADDR		0x08
+#define	PCI_CSH_CACHE_LINE_SIZE_REG_ADDR	0x0C
+#define	PCI_CSH_LATENCY_TIMER_REG_ADDR		0x0D
+#define	PCI_CSH_HEADER_TYPE_REG_ADDR		0x0E
+#define	PCI_CSH_BIST_REG_ADDR			0x0F
+#define	PCI_CSH_BAR_REG_ADDR			0x10
+
+
+#define	PCI_IO_SPACE_SIZE_1M			0x00
+#define	PCI_IO_SPACE_SIZE_2M			0x01
+#define	PCI_IO_SPACE_SIZE_4M			0x02
+#define	PCI_IO_SPACE_SIZE_8M			0x03
+#define	PCI_IO_SPACE_SIZE_16M			0x04
+#define	PCI_IO_SPACE_SIZE_32M			0x05
+#define	PCI_IO_SPACE_SIZE_64M			0x06
+#define	PCI_IO_SPACE_SIZE_128M			0x07
+#define	PCI_IO_SPACE_SIZE_256M			0x08
+#define	PCI_IO_SPACE_SIZE_512M			0x09
+#define	PCI_IO_SPACE_SIZE_1G			0x0A
+#define	PCI_IO_SPACE_SIZE_2G			0x0B
+
+
+#define	PCI_MEMORY_SPACE_TYPE			0
+#define	PCI_IO_SPACE_TYPE			1
+
+#define	PCI_BROKEN_FLAG				1
+#define	PCI_AHB2PCIB_FLAG			2
+
+
+#endif	// end of #ifndef _STAR_PCI_DRIDGE_H_
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pcmcia_bridge.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pcmcia_bridge.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pcmcia_bridge.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pcmcia_bridge.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,231 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_PCMCIA_DRIDGE_H_
+#define	_STAR_PCMCIA_DRIDGE_H_
+
+/******************************************************************************
+ * MODULE NAME:	   star_pcmcia_bridge.h
+ * PROJECT CODE:   Equuleus
+ * DESCRIPTION:
+ * MAINTAINER:	   Eric	Yang
+ * DATE:	   15 September	2005
+ *
+ * SOURCE CONTROL:
+ *
+ * LICENSE:
+ *     This source code	is copyright (c) 2005 Star Semi	Inc.
+ *     All rights reserved.
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  Eric Yang	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	PCMCIA_BRIDGE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_PCMCIA_CONTROL_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PCMCIA_BRIDGE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_PCMCIA_CONTROL_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PCMCIA_CONFIGURATION_REG			PCMCIA_BRIDGE_MEM_MAP_VALUE(0x20)
+#define	PCMCIA_MEMORY_ACCESS_TIMING_PARAM_REG		PCMCIA_BRIDGE_MEM_MAP_VALUE(0x24)
+#define	PCMCIA_IO_ACCESS_TIMING_PARAM_REG		PCMCIA_BRIDGE_MEM_MAP_VALUE(0x28)
+
+
+#define	PCMCIA_ATTRIBUTE_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCMCIA_ATTRIBUTE_MEMORY_BASE_ADDR)
+#define	PCMCIA_COMMOM_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCMCIA_COMMON_MEMORY_BASE_ADDR)
+#define	PCMCIA_IO_SPACE_BASE_ADDR			(SYSPA_PCMCIA_IO_SPACE_BASE_ADDR)
+
+
+
+/*
+ * define constants macros
+ */
+#define	PCMCIA_DATA_BUS_WIDTH_8		(0)
+
+#define	PCMCIA_DATA_BUS_WIDTH_16	(1)
+
+
+/*
+ * Flags for PCMCIA_STATUS
+ */
+#define	FLAG_STATUS_BVD1		0x01
+#define	FLAG_STATUS_STSCHG		0x01
+#define	FLAG_STATUS_BVD2		0x02
+#define	FLAG_STATUS_SPKR		0x02
+#define	FLAG_STATUS_DETECT		0xf3	  /* bit 2=0,3=0 ,0x0c bit 2=1,3=1 */
+#define	FLAG_STATUS_WRPROT		0x10
+#define	FLAG_STATUS_READY		0x20
+#define	FLAG_STATUS_INPACK		0x40
+
+
+/*
+ * Flags for PCMCIA_CSC
+ */
+#define	FLAG_CSC_BVD1			0x01
+#define	FLAG_CSC_BVD2			0x02
+#define	FLAG_CSC_READY			0x04
+#define	FLAG_CSC_INPACK			0x08
+#define	FLAG_CSC_STSCHG			0x10
+#define	FLAG_CSC_CARDINT		0x20
+#define	FLAG_CSC_DETECT			0x40
+#define	FLAG_CSC_SWCDC			0x80
+
+
+/*
+ * Flags for PCMCIA_POWER
+ */
+#define	FLAG_POWER_OFF			0x00	  /* Turn off the socket */
+#define	FLAG_POWER_3V			0x01	  /* 1:Vcc = 3.3v 0:Vcc	= 5.0v */
+#define	FLAG_POWER_SWH			0x02	  /* Direct 5V/3V switch enable	*/
+#define	FLAG_POWER_CTL			0x10	  /* Socket power control */
+#define	FLAG_POWER_AUTO			0x20	  /* Auto power	switch enable */
+#define	FLAG_POWER_OUTENA		0x40	  /* Output enable */
+
+
+/*
+ * Flags for PCMCIA_GBLCTL
+ */
+#define	FLAG_GBLCTL_PWRDOWN		0x01
+#define	FLAG_GBLCTL_WBACK		0x02
+#define	FLAG_GBLCTL_16BITS		0x04
+#define	FLAG_GBLCTL_IOCARD		0x08
+#define	FLAG_GBLCTL_SWCDINT		0x10
+#define	FLAG_GBLCTL_RESET		0x20
+
+
+/*
+ * Flags for PCMCIA_INTCFG
+ */
+#define	FLAG_INTCFG_BDEAD		0x01
+#define	FLAG_INTCFG_BWARN		0x02
+#define	FLAG_INTCFG_READY		0x04
+#define	FLAG_INTCFG_INPACK		0x08
+#define	FLAG_INTCFG_LEVEL		0x10
+#define	FLAG_INTCFG_FEDGE		0x20
+#define	FLAG_INTCFG_REDGE		0x30
+#define	FLAG_INTCFG_DETECT		0x40
+#define	FLAG_INTCFG_STSCHG		0x80
+
+
+/*
+ * Definitions for Card	Status flags for GetStatus
+ */
+#define	STATUS_BATDEAD			0x0001
+#define	STATUS_BATWARN			0x0002
+#define	STATUS_DETECT			0x0004
+#define	STATUS_WRPROT			0x0008
+#define	STATUS_READY			0x0010
+#define	STATUS_INPACK			0x0020
+#define	STATUS_STSCHG			0x0040    /* just for	CSC */
+#define	SOFTWARE_STATUS_DETECT		0x0040    /* just for	CSC */
+
+
+/*
+ * Set Socket configuration flags
+ */
+#define	SS_PWR_AUTO			0x0001
+#define	SS_PWR_SWH			0x0002
+#define	SS_PWR_SEL			0x0004
+#define	SS_POWER_ON			0x0008
+#define	SS_OUTPUT_ENA			0x0010
+#define	SS_IOCARD			0x0020
+#define	SS_RESET			0x0040
+#define	SS_WBACK			0x0080
+#define	SS_16BITS			0x0100
+#define	SS_PWR_DOWN_MODE		0x0200
+#define	SS_SWCDINT			0x0400
+
+
+/*
+ * Set Interrupt Configuration flags
+ */
+#define	INTR_BATDEAD			0x0001
+#define	INTR_BATWARN			0x0002
+#define	INTR_READY			0x0004
+#define	INTR_INPACK			0x0008
+#define	INTR_CARDINT			0x0010
+#define	INTR_DETECT			0x0020
+#define	INTR_STSCHG			0x0040
+
+
+/*
+ * tuple code
+ */
+#define	CISTPL_NULL			0x00
+#define	CISTPL_DEVICE			0x01
+#define	CISTPL_NO_LINK			0x14
+#define	CISTPL_VERS_1			0x15
+#define	CISTPL_CONFIG			0x1a
+#define	CISTPL_CFTABLE_ENTRY		0x1b
+#define	CISTPL_MANFID			0x20
+#define	CISTPL_END			0xff
+
+
+/*
+ * Return codes
+ */
+#define	CS_SUCCESS			0x00
+#define	CS_UNSUPPORTED_FUNCTION		0x15
+#define	CS_NO_MORE_ITEMS		0x1f
+#define	CS_BAD_TUPLE			0x40
+
+
+/*
+ * Attributes for tuple	calls
+ */
+#define	TUPLE_RETURN_LINK		0x01
+#define	TUPLE_RETURN_COMMON		0x02
+
+#define	RETURN_FIRST_TUPLE		0xff
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_PCMCIA_ENABLE_PCMCIA_CONTROLLER() \
+{ \
+    (PCMCIA_CONFIGURATION_REG) |= (0x1 << 1); \
+}
+
+#define	HAL_PCMCIA_DISABLE_PCMCIA_CONTROLLER() \
+{ \
+    (PCMCIA_CONFIGURATION_REG) &= ~(0x1	<< 1); \
+}
+
+
+#endif	// end of #ifndef _STAR_PCMCIA_DRIDGE_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pcm.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pcm.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_pcm.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_pcm.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,277 @@
+/******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_PCM_H_
+#define _STAR_PCM_H_
+
+/******************************************************************************
+ * MODULE NAME:    star_pcm.h
+ * PROJECT CODE:   Orion
+ * DESCRIPTION:    
+ * MAINTAINER:     MJLIU
+ * DATE:           15 September 2005
+ *
+ * SOURCE CONTROL: 
+ *
+ * LICENSE:
+ *     This source code is copyright (c) 2005 Star Semi Inc.
+ *     All rights reserved.
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  MJLIU	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include <mach/star_sys_memory_map.h>
+
+#define PCM_BASE_ADDR                         (SYSVA_PCM_BASE_ADDR)
+#define PCM_MEM_MAP_ADDR(reg_offset)          (PCM_BASE_ADDR + reg_offset)
+#define PCM_MEM_MAP_VALUE(reg_offset)         (*((u32 volatile *)PCM_MEM_MAP_ADDR(reg_offset)))
+
+
+/*
+ * define access macros
+ */
+#define PCM_CONFIGURATION_0_REG               PCM_MEM_MAP_VALUE(0x80)
+#define PCM_CONFIGURATION_1_REG               PCM_MEM_MAP_VALUE(0x84)
+
+#define PCM_CHANNEL_0_CONFIG_REG              PCM_MEM_MAP_VALUE(0x88)
+#define PCM_CHANNEL_1_CONFIG_REG              PCM_MEM_MAP_VALUE(0x8C)
+#define PCM_CHANNEL_2_CONFIG_REG              PCM_MEM_MAP_VALUE(0x90)
+#define PCM_CHANNEL_3_CONFIG_REG              PCM_MEM_MAP_VALUE(0x94)
+
+#define PCM_TX_DATA_31_0_REG                  PCM_MEM_MAP_VALUE(0x98)
+#define PCM_TX_DATA_63_32_REG                 PCM_MEM_MAP_VALUE(0x9C)
+
+#define PCM_RX_DATA_31_0_REG                  PCM_MEM_MAP_VALUE(0xA0)
+#define PCM_RX_DATA_63_32_REG                 PCM_MEM_MAP_VALUE(0xA4)
+
+#define PCM_INTERRUPT_STATUS_REG              PCM_MEM_MAP_VALUE(0xA8)
+#define PCM_INTERRUPT_ENABLE_REG              PCM_MEM_MAP_VALUE(0xAC)
+
+
+
+/*
+ * define constants macros
+ */
+#define CH0_BIT_INDEX                         (0x1)
+#define CH1_BIT_INDEX                         (0x2)
+#define CH2_BIT_INDEX                         (0x4)
+#define CH3_BIT_INDEX                         (0x8)
+
+#define PCM_RXBUF_FULL_FG                     (0x1)
+#define PCM_TXBUF_EMPTY_FG                    (0x2)
+#define PCM_RXBUF_OVERRUN_FG                  (0x4)
+#define PCM_TXBUF_UNDERRUN_FG                 (0x8)
+
+#define PCM_ENABLE_FG                         (0x1 << 23)
+
+#define PCM_IDL_MODE                          (0)
+#define PCM_GCI_MODE                          (1)
+
+#define PCM_DATA_BIT_8                        (0)
+#define PCM_DATA_BIT_16                       (1)
+
+
+/*
+ * Set Commands Variables
+ */
+#define        Software_Reset                               (0x02)
+#define        Hardware_Reset                               (0x04)
+#define        Write_Transmit_Time_Slot                     (0x40)
+#define        Read_Transmit_Time_Slot                      (0x41)
+#define        Write_Receive_Time_Slot                      (0x42)
+#define        Read_Receive_Time_Slot                       (0x43)
+#define        Write_Tx_Rx_CLK_Slot_Tx_CLK_Edge             (0x44)
+#define        Read_Tx_Rx_CLK_Slot_Tx_CLK_Edge              (0x45)
+#define        Write_Device_Configure_Reg                   (0x46)
+#define        Read_Device_Configure_Reg                    (0x47)
+#define        Write_Channel_Enable_Operating_Mode_Reg      (0x4A)
+#define        Read_Channel_Enable_Operating_Mode_Reg       (0x4B)
+#define        Read_Signal_Reg                              (0x4D)
+#define        Input_Data_Reg                               (0x52)
+#define        Output_Data_Reg                              (0x53)
+#define        Input_Direction_Reg                          (0x54)
+#define        Output_Direction_Reg                         (0x55)
+#define        Write_System_State                           (0x56)
+#define        Read_System_State                            (0x57)
+#define        Write_Operating_Functon                      (0x60)
+#define        Read_Operating_Functon                       (0x61)
+#define        Write_System_State_Config                    (0x68)
+#define        Read_System_State_Config                     (0x69)
+#define        Write_Interrupt_Mask_Reg                     (0x6C)
+#define        Read_Interrupt_Mask_Reg                      (0x6D)
+#define        Write_Operating_Condition                    (0x70)
+#define        Write_Loop_Supervision_Parameter             (0xC2)
+#define        Write_DC_Feed_Parameter                      (0xC6)
+#define        Write_Signal_A_B_Parameter                   (0xD2)
+#define        Write_Switching_Reg_Parameter                (0xE4)
+#define        Write_Switching_Reg_Control                  (0xE6)
+
+
+/*
+ * define data structure
+ */
+typedef struct _PCM_CHANNEL_OBJECT_    PCM_CHANNEL_OBJECT_T;
+
+struct _PCM_CHANNEL_OBJECT_
+{
+    u16          channel_0_tx_data;
+    u16          channel_0_rx_data;
+    u32          channel_0_data_width;     /* 0 : 8-bit, 1 : 16-bit */
+
+    u16          channel_1_tx_data;
+    u16          channel_1_rx_data;
+    u32          channel_1_data_width;
+
+    u16          channel_2_tx_data;
+    u16          channel_2_rx_data;
+    u32          channel_2_data_width;
+
+    u16          channel_3_tx_data;
+    u16          channel_3_rx_data;
+    u32          channel_3_data_width;
+    
+    u32          channel_enable_config;    /* bit[0] = 0 : channel 0 disabled
+                                                     [0] = 1 : channel 0 enabled
+                                                  bit[1] = 0 : channel 1 disabled
+                                                     [1] = 1 : channel 1 enabled
+                                                  bit[2] = 0 : channel 2 disabled
+                                                     [2] = 1 : channel 2 enabled
+                                                  bit[3] = 0 : channel 3 disabled
+                                                     [3] = 1 : channel 3 enabled */
+};
+
+
+typedef struct _PCM_OBJECT_    PCM_OBJECT_T;
+
+struct _PCM_OBJECT_
+{
+    u32          config_0;
+    u32          config_1; 
+    
+    u32          channel_0_config;
+    u32          channel_1_config;
+    u32          channel_2_config;
+    u32          channel_3_config;
+    
+    u32          interrupt_config;
+    
+    /* 
+     * For interrupt setting
+     */
+//    INTC_OBJECT_T    intc_obj;
+};
+
+
+
+/*
+ * function declarations
+ */
+void       Hal_Pcm_Initialize(PCM_OBJECT_T *);
+
+                                                                           
+/*
+ * macro declarations
+ */
+#define HAL_PCM_ENABLE_PCM() \
+{ \
+    (PCM_CONFIGURATION_0_REG) |= ((u32)0x1 << 31); \
+}
+
+#define HAL_PCM_DISABLE_PCM() \
+{ \
+    (PCM_CONFIGURATION_0_REG) &= ~((u32)0x1 << 31); \
+}
+
+#define HAL_PCM_ENABLE_DATA_SWAP() \
+{ \
+    (PCM_CONFIGURATION_0_REG) |= (0x1 << 24); \
+}
+
+#define HAL_PCM_DISABLE_DATA_SWAP() \
+{ \
+    (PCM_CONFIGURATION_0_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_PCM_WRITE_TX_DATA_0(tx_data_0) \
+{ \
+    (PCM_TX_DATA_31_0_REG) = tx_data_0; \
+}
+
+#define HAL_PCM_WRITE_TX_DATA_1(tx_data_1) \
+{ \
+    (PCM_TX_DATA_63_32_REG) = tx_data_1; \
+}
+
+#define HAL_PCM_READ_RX_DATA_0(rx_data_0) \
+{ \
+    (rx_data_0) = PCM_RX_DATA_31_0_REG; \
+}
+
+#define HAL_PCM_READ_RX_DATA_1(rx_data_1) \
+{ \
+    (rx_data_1) = PCM_RX_DATA_63_32_REG; \
+}
+
+#define HAL_PCM_READ_INTERRUPT_STATUS(status) \
+{ \
+    (status) = PCM_INTERRUPT_STATUS_REG; \
+}
+
+#define HAL_PCM_CLEAR_INTERRUPT_STATUS(status) \
+{ \
+    (PCM_INTERRUPT_STATUS_REG) = (status & 0xC0); \
+}
+
+#define HAL_PCM_DISABLE_RECEIVE_BUFFER_FULL_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_PCM_DISABLE_TRANSMIT_BUFFER_EMPTY_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_PCM_DISABLE_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_PCM_DISABLE_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_PCM_DISABLE_ALL_INTERRUPT_SOURCES() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) = 0; \
+}
+
+#endif  // end of #ifndef _STAR_PCM_H_
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_powermgt.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_powermgt.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_powermgt.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_powermgt.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,616 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_POWERMGT_H_
+#define	_STAR_POWERMGT_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	PWRMGT_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_POWER_MANAGEMENT_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PWRMGT_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_POWER_MANAGEMENT_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PWRMGT_CLOCK_GATE_CONTROL0_REG			PWRMGT_MEM_MAP_VALUE(0x00)
+#define	PWRMGT_CLOCK_GATE_CONTROL1_REG			PWRMGT_MEM_MAP_VALUE(0x04)
+#define	PWRMGT_SOFTWARE_RESET_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x08)
+#define	PWRMGT_SYSTEM_CLOCK_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x0C)
+#define	PWRMGT_PLL_POWER_DOWN_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x10)
+#define	PWRMGT_CPU_INITIALIZATION_REG			PWRMGT_MEM_MAP_VALUE(0x14)
+#define	PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x1C)
+#define	PWRMGT_USB_DEVICE_POWERMGT_REG			PWRMGT_MEM_MAP_VALUE(0x20)
+#define	PWRMGT_REGULATOR_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x24)
+#define	PWRMGT_RTC_XTAL_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x28)
+#define	PWRMGT_PLL250_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x2C)
+
+
+/*
+ * define constants macros
+ */
+#define	PWRMGT_PCMCIA_SOFTWARE_RESET_BIT_INDEX			(1)
+#define	PWRMGT_IDE_SOFTWARE_RESET_BIT_INDEX			(2)
+#define	PWRMGT_VIC_SOFTWARE_RESET_BIT_INDEX			(3)
+#define	PWRMGT_DMA_SOFTWARE_RESET_BIT_INDEX			(4)
+#define	PWRMGT_NIC_SOFTWARE_RESET_BIT_INDEX			(5)
+#define	PWRMGT_USB_HOST_SOFTWARE_RESET_BIT_INDEX		(6)
+#define	PWRMGT_PCI_BRIDGE_SOFTWARE_RESET_BIT_INDEX		(7)
+#define	PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX			(8)
+#define	PWRMGT_UART0_SOFTWARE_RESET_BIT_INDEX			(9)
+#define	PWRMGT_UART1_SOFTWARE_RESET_BIT_INDEX			(10)
+#define	PWRMGT_TIMER_SOFTWARE_RESET_BIT_INDEX			(11)
+#define	PWRMGT_WDTIMER_SOFTWARE_RESET_BIT_INDEX			(12)
+#define	PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX			(13)
+#define	PWRMGT_USB_DEVICE_SOFTWARE_RESET_BIT_INDEX		(14)
+#define	PWRMGT_FAST_ETHERNET_PHY_SOFTWARE_RESET_BIT_INDEX	(15)
+#define	PWRMGT_HSDMA_SOFTWARE_RESET_BIT_INDEX			(16)
+
+
+#define	PWRMGT_PLL_FREQUENCY_175MHZ			(0 << 0)
+#define	PWRMGT_PLL_FREQUENCY_200MHZ			(1 << 0)
+#define	PWRMGT_PLL_FREQUENCY_225MHZ			(2 << 0)
+#define	PWRMGT_PLL_FREQUENCY_250MHZ			(3 << 0)
+
+#define	PWRMGT_CPUCLK_DIVIDER_BY_1			(0 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_2			(1 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_3			(2 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_4			(3 << 2)
+
+#define	PWRMGT_HCLK_DIVIDER_BY_1			(0 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_2			(1 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_3			(2 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_4			(3 << 4)
+
+#define	PWRMGT_HCLK_SOURCE_FCLK				(0 << 6)
+#define	PWRMGT_HCLK_SOURCE_125MHZ			(1 << 6)
+
+#define	PWRMGT_PCLK_DIVIDER_BY_1			(0 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_2			(1 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_3			(2 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_4			(3 << 8)
+
+#define	PWRMGT_PCICLK_DIVIDER_BY_1			(0 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_2			(1 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_3			(2 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_4			(3 << 10)
+
+
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_1		(1)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_2		(2)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_3		(3)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_4		(4)
+
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_1		(1)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_2		(2)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_3		(3)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_4		(4)
+
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_1			(1)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_2			(2)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_3			(3)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_4			(4)
+
+/*
+ * Macro defines for Clock Gate	Control
+ */
+#define	HAL_PWRMGT_DISABLE_DRAMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x0F << 20); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x0F <<	20); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define	HAL_PWRMGT_ENABLE_PCI_BRIDGE_66M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	28) | (0x1 << 30)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_USB_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0xF << 1); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 28); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 6) | (0x1 << 14); \
+}
+
+#define	HAL_PWRMGT_DISABLE_USB_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 28); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 16); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 4); \
+}
+
+#define	HAL_PWRMGT_DISABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 16); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 8) | (0x1	<< 9); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_DISABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	8) | (0x1 << 9)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_UART0_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 1) |	(0x1 <<	2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 12); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 9); \
+}
+
+#define	HAL_PWRMGT_DISABLE_UART0_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_UART1_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 1) |	(0x1 <<	2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 13); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 10); \
+}
+
+#define	HAL_PWRMGT_DISABLE_UART1_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 13); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1	<< 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	4) | (0x1 << 5)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_GPIO_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 25); \
+}
+
+#define	HAL_PWRMGT_DISABLE_GPIO_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 25); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 21) | (0x1 << 22); \
+}
+
+#define	HAL_PWRMGT_DISABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	21) | (0x1 << 22)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 23); \
+}
+
+#define	HAL_PWRMGT_DISABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 23); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_TIMER_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 17) | (0x1 << 18)	| (0x1 << 19); \
+}
+
+#define	HAL_PWRMGT_DISABLE_TIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	17) | (0x1 << 18) | (0x1 << 19)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1); \
+}
+
+#define	HAL_PWRMGT_DISABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 1); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 5) |	(0x1 <<	6)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1	<< 10);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define	HAL_PWRMGT_DISABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	1) | (0x1 << 10)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1	<< 6); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	1) | (0x1 << 6)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 0) | (0x1	<< 1); \
+}
+
+#define	HAL_PWRMGT_DISABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	0) | (0x1 << 1)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 12); \
+}
+
+#define	HAL_PWRMGT_DISABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1	<< 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	4) | (0x1 << 5)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_HSDMA_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 29); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 16); \
+}
+
+#define	HAL_PWRMGT_DISABLE_HSDMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 29); \
+}
+
+
+
+/*
+ * Macro defines for Reset Control
+ */
+#define	HAL_PWRMGT_GLOBAL_SOFTWARE_RESET() \
+{ \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1); \
+}
+
+
+/*
+ * Macro defines for System Clock Control
+ */
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_175MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_200MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x1; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_225MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x2; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_250MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x3; \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_PLLCLK_TO_CPUCLK_RATIO(ratio)	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	2); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 2); \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_CPUCLK_TO_HCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	4); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 4); \
+}
+
+
+#define	HAL_PWRMGT_HCLK_SOURCE_FCLK() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 <<	6); \
+}
+
+
+#define	HAL_PWRMGT_HCLK_SOURCE_125MHZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 6); \
+}
+
+
+#define	HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_HCLK()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 <<	7); \
+}
+
+
+#define	HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_62_5MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 7); \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_HCLK_TO_PCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	8); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 8); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_8192000HZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 12); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_11289600HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_12288000HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x2 << 12); \
+}
+
+
+#define	HAL_PWRMGT_CONFIGURE_MDC_CLOCK_DIVIDER(divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	14); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 14); \
+}
+
+
+#define	HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(pin_source_select, divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3F << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((pin_source_select & 0xF) << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 20); \
+}
+
+
+/*
+ * Macro defines for PLL Power Down Control
+ */
+#define	HAL_PWRMGT_POWER_DOWN_SYSTEM_XTAL_PAD()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 7)
+
+#define	HAL_PWRMGT_POWER_ON_SYSTEM_XTAL_PAD() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 7)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 0)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 1)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 2)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 2)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 3)
+
+#define	HAL_PWRMGT_POWER_ON_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 3)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 4)
+
+#define	HAL_PWRMGT_POWER_ON_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 4)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X2250() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 5)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X2250()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 6)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 6)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_ALL_PLL()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0x7F;
+
+#define	HAL_PWRMGT_POWER_ON_ALL_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0;
+
+
+/*
+ * Macro defines for Pad Drive Strength	Control
+ */
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCMCIA_CARDBUS_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCI_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 0); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_MII_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_RGMII_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_ENABLE_MII_PAD_SIGNAL_NOT_BOUNDED() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 3); \
+}
+
+#define	HAL_PWRMGT_DISABLE_MII_PAD_SIGNAL_NOT_BOUNDED()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 3); \
+}
+
+
+/*
+ * Macro defines for USB Device	Power Management
+ */
+#define	HAL_PWRMGT_REMOTE_WAKEUP_USB_HOST() \
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 4); \
+}
+
+#define	HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_EXTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG &= ~(0x1 << 5); \
+}
+
+#define	HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_INTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 5); \
+}
+
+
+/*
+ * Macro defines for Regulator Control
+ */
+
+
+#endif	// end of #ifndef _STAR_POWERMGT_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_rtc.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_rtc.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_rtc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_rtc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_RTC_H_
+#define	_STAR_RTC_H_
+
+#include <mach/star_sys_memory_map.h>
+
+#define	RTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_RTC_BASE_ADDR + reg_offset)))
+
+#define	RTC_SECOND_REG				RTC_MEM_MAP_VALUE(0x00)
+#define	RTC_MINUTE_REG				RTC_MEM_MAP_VALUE(0x04)
+#define	RTC_HOUR_REG				RTC_MEM_MAP_VALUE(0x08)
+#define	RTC_DAY_REG				RTC_MEM_MAP_VALUE(0x0C)
+#define	RTC_SECOND_ALARM_REG			RTC_MEM_MAP_VALUE(0x10)
+#define	RTC_MINUTE_ALARM_REG			RTC_MEM_MAP_VALUE(0x14)
+#define	RTC_HOUR_ALARM_REG			RTC_MEM_MAP_VALUE(0x18)
+#define	RTC_RECORD_REG				RTC_MEM_MAP_VALUE(0x1C)
+#define	RTC_CONTROL_REG				RTC_MEM_MAP_VALUE(0x20)
+#define	RTC_INTERRUPT_STATUS_REG		RTC_MEM_MAP_VALUE(0x34)
+
+#define	RTC_ENABLE_BIT				(1 << 0)
+#define	RTC_AUTO_SECOND_ALARM_ENABLE_BIT	(1 << 1)
+#define	RTC_AUTO_MINUTE_ALARM_ENABLE_BIT	(1 << 2)
+#define	RTC_AUTO_HOUR_ALARM_ENABLE_BIT		(1 << 3)
+#define	RTC_AUTO_DAY_ALARM_ENABLE_BIT		(1 << 4)
+#define	RTC_MATCH_ALARM_ENABLE_BIT		(1 << 5)
+#define	RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT	(1 << 6)
+
+#define RTC_AUTO_SECOND_ALARM_INTR_BIT      (1 << 0)
+#define RTC_AUTO_MINUTE_ALARM_INTR_BIT      (1 << 1)
+#define RTC_AUTO_HOUR_ALARM_INTR_BIT        (1 << 2)
+#define RTC_AUTO_DAY_ALARM_INTR_BIT         (1 << 3)
+#define RTC_MATCH_ALARM_INTR_BIT            (1 << 4)
+#define RTC_BATTERY_LOW_VOLTAGE_INTR_BIT    (1 << 5)
+
+#define	HAL_RTC_READ_SECOND(second)         ((second) = (RTC_SECOND_REG) & 0x3F);
+#define	HAL_RTC_READ_MINUTE(minute)         ((minute) = (RTC_MINUTE_REG) & 0x3F);
+#define	HAL_RTC_READ_HOUR(hour)	            ((hour) = (RTC_HOUR_REG) & 0x1F);
+#define	HAL_RTC_READ_DAY(day)               ((day) = (RTC_DAY_REG) & 0xFFFF);
+#define	HAL_RTC_ENABLE()                    ((RTC_CONTROL_REG) |= (RTC_ENABLE_BIT));
+#define	HAL_RTC_DISABLE()                   ((RTC_CONTROL_REG) &= ~(RTC_ENABLE_BIT));
+#define	HAL_RTC_AUTO_SECOND_ALARM_ENABLE()  ((RTC_CONTROL_REG) |= (RTC_AUTO_SECOND_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_SECOND_ALARM_DISABLE() ((RTC_CONTROL_REG) &= ~(RTC_AUTO_SECOND_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_MINUTE_ALARM_ENABLE()  ((RTC_CONTROL_REG) |= (RTC_AUTO_MINUTE_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_MINUTE_ALARM_DISABLE() ((RTC_CONTROL_REG) &= ~(RTC_AUTO_MINUTE_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_HOUR_ALARM_ENABLE()    ((RTC_CONTROL_REG) |= (RTC_AUTO_HOUR_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_HOUR_ALARM_DISABLE()   ((RTC_CONTROL_REG) &= ~(RTC_AUTO_HOUR_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_DAY_ALARM_ENABLE()	    ((RTC_CONTROL_REG) |= (RTC_AUTO_DAY_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_DAY_ALARM_DISABLE()    ((RTC_CONTROL_REG) &= ~(RTC_AUTO_DAY_ALARM_ENABLE_BIT));
+#define	HAL_RTC_MATCH_ALARM_ENABLE()        ((RTC_CONTROL_REG) |= (RTC_MATCH_ALARM_ENABLE_BIT));
+#define	HAL_RTC_MATCH_ALARM_DISABLE()       ((RTC_CONTROL_REG) &= ~(RTC_MATCH_ALARM_ENABLE_BIT));
+#define	HAL_RTC_BATTERY_LOW_VOLTAGE_INTERRUPT_ENABLE()   ((RTC_CONTROL_REG) |= (RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT));
+#define	HAL_RTC_BATTERY_LOW_VOLTAGE_INTERRUPT_DISABLE()	 ((RTC_CONTROL_REG) &= ~(RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT));
+#define	HAL_RTC_WRITE_RECORD(record)        ((RTC_RECORD_REG) =	(record));
+#define	HAL_RTC_READ_RECORD(record)         ((record) =	(RTC_RECORD_REG)); 
+#define	HAL_RTC_WRITE_MATCHED_ALARM_SECOND(second)  ((RTC_SECOND_ALARM_REG) = (second &	0x3F));
+#define	HAL_RTC_READ_MATCHED_ALARM_SECOND(second)   ((second) =	(RTC_SECOND_ALARM_REG) & 0x3F);
+#define	HAL_RTC_WRITE_MATCHED_ALARM_MINUTE(minute)  ((RTC_MINUTE_ALARM_REG) = (minute &	0x3F));
+#define	HAL_RTC_READ_MATCHED_ALARM_MINUTE(minute)   ((minute) =	(RTC_MINUTE_ALARM_REG) & 0x3F);
+#define	HAL_RTC_WRITE_MATCHED_ALARM_HOUR(hour)      ((RTC_HOUR_ALARM_REG) = (hour & 0x1F));
+#define	HAL_RTC_READ_MATCHED_ALARM_HOUR(hour)       ((hour) = (RTC_HOUR_ALARM_REG) & 0x1F);
+#define	HAL_RTC_READ_INTERRUPT_STATUS(status)       ((status) =	(RTC_INTERRUPT_STATUS_REG) & 0x3F);
+#define	HAL_RTC_WRITE_INTERRUPT_STATUS(status)      ((RTC_INTERRUPT_STATUS_REG)	= (status) & 0x3F);
+
+#endif
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_smc.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_smc.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_smc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_smc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_SMC_H_
+#define	_STAR_SMC_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	SMC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_SMC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	SMC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_SMC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+
+/*
+ * Static Memory Controller Registers
+ */
+#define	SMC_MEM_BANK0_CONFIG_REG	SMC_MEM_MAP_VALUE(0x00)
+#define	SMC_MEM_BANK0_TIMING_REG	SMC_MEM_MAP_VALUE(0x04)
+#define	SMC_MEM_BANK1_CONFIG_REG	SMC_MEM_MAP_VALUE(0x08)
+#define	SMC_MEM_BANK1_TIMING_REG	SMC_MEM_MAP_VALUE(0x0C)
+#define	SMC_MEM_BANK2_CONFIG_REG	SMC_MEM_MAP_VALUE(0x10)
+#define	SMC_MEM_BANK2_TIMING_REG	SMC_MEM_MAP_VALUE(0x14)
+#define	SMC_MEM_BANK3_CONFIG_REG	SMC_MEM_MAP_VALUE(0x18)
+#define	SMC_MEM_BANK3_TIMING_REG	SMC_MEM_MAP_VALUE(0x1C)
+
+/*
+ * macros declarations
+ */
+
+#endif	// end of #ifndef _STAR_SMC_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_spi.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_spi.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_spi.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_spi.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,169 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_SPI_H_
+#define _STAR_SPI_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define SPI_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_SPI_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define SPI_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_SPI_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define SPI_CONFIGURATION_REG			SPI_MEM_MAP_VALUE(0x40)
+#define SPI_SERVICE_STATUS_REG			SPI_MEM_MAP_VALUE(0x44)
+#define SPI_BIT_RATE_CONTROL_REG		SPI_MEM_MAP_VALUE(0x48)
+#define SPI_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x4C)
+#define SPI_TRANSMIT_BUFFER_REG			SPI_MEM_MAP_VALUE(0x50)
+#define SPI_RECEIVE_CONTROL_REG			SPI_MEM_MAP_VALUE(0x54)
+#define SPI_RECEIVE_BUFFER_REG			SPI_MEM_MAP_VALUE(0x58)
+#define SPI_FIFO_TRANSMIT_CONFIG_REG		SPI_MEM_MAP_VALUE(0x5C)
+#define SPI_FIFO_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x60)
+#define SPI_FIFO_RECEIVE_CONFIG_REG		SPI_MEM_MAP_VALUE(0x64)
+#define SPI_INTERRUPT_STATUS_REG		SPI_MEM_MAP_VALUE(0x68)
+#define SPI_INTERRUPT_ENABLE_REG		SPI_MEM_MAP_VALUE(0x6C)
+
+
+/*
+ * define constants macros
+ */
+#define SPI_TX_RX_FIFO_DEPTH			(8)
+
+#define SPI_CH0					(0)
+#define SPI_CH1					(1)
+#define SPI_CH2					(2)
+#define SPI_CH3					(3)
+
+
+#define SPI_RXFIFO_OT_FG			(0x01)
+#define SPI_TXFIFO_UT_FG			(0x02)
+#define SPI_RXBUF_FULL_FG			(0x04)
+#define SPI_TXBUF_EMPTY_FG			(0x08)
+
+#define SPI_RXFIFO_OR_FG			(0x10)
+#define SPI_TXFIFO_UR_FG			(0x20)
+#define SPI_RXBUF_OR_FG				(0x40)
+#define SPI_TXBUF_UR_FG				(0x80)
+
+/*
+ * define Character Length Control
+ */
+#define SPI_LEN_BIT_8				(0)
+#define SPI_LEN_BIT_16				(1)
+#define SPI_LEN_BIT_24				(2)
+#define SPI_LEN_BIT_32				(3)
+
+
+/*
+ * macro declarations
+ */
+#define HAL_SPI_ENABLE_SPI() \
+{ \
+    (SPI_CONFIGURATION_REG) |= ((u_int32)0x1 << 31); \
+}
+
+#define HAL_SPI_DISABLE_SPI() \
+{ \
+    (SPI_CONFIGURATION_REG) &= ~((u_int32)0x1 << 31); \
+}
+
+#define HAL_SPI_ENABLE_DATA_SWAP() \
+{ \
+    (SPI_CONFIGURATION_REG) |= (0x1 << 24); \
+}
+
+#define HAL_SPI_DISABLE_DATA_SWAP() \
+{ \
+    (SPI_CONFIGURATION_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_SPI_TRANSMIT_DATA(tx_data) \
+{ \
+    (SPI_TRANSMIT_BUFFER_REG) = tx_data; \
+}
+
+#define HAL_SPI_RECEIVE_DATA(rx_data) \
+{ \
+    (rx_data) = SPI_RECEIVE_BUFFER_REG; \
+}
+
+#define HAL_SPI_GET_TRANSMIT_FIFO_WORDS_NUMBER(tx_fifo_words_num) \
+{ \
+    (tx_fifo_words_num) = SPI_FIFO_TRANSMIT_CONFIG_REG & 0xF; \
+}
+
+#define HAL_SPI_GET_RECEIVE_FIFO_WORDS_NUMBER(rx_fifo_words_num) \
+{ \
+    (rx_fifo_words_num) = SPI_FIFO_RECEIVE_CONFIG_REG & 0xF; \
+}
+
+#define HAL_SPI_DISABLE_ALL_INTERRUPT_SOURCES() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) = 0; \
+}
+
+#define HAL_SPI_DISABLE_TX_FIFO_THRESHOLD_INTERRUPT() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_SPI_DISABLE_RX_FIFO_THRESHOLD_INTERRUPT() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_SPI_READ_INTERRUPT_STATUS(status) \
+{ \
+    (status) = SPI_INTERRUPT_STATUS_REG; \
+}
+
+#define HAL_SPI_CLEAR_INTERRUPT_STATUS(status) \
+{ \
+    (SPI_INTERRUPT_STATUS_REG) = (status & 0xF0); \
+}
+
+#define HAL_SPI_SET_FIFO_TRANSMIT_DELAY(delay) \
+{ \
+    (SPI_FIFO_TRANSMIT_CONTROL_REG) = (delay & 0x1F); \
+}
+
+#define STR8100_SPI_SERIAL_MODE_GENERAL              0x0
+#define STR8100_SPI_SERIAL_MODE_MICROPROCESSOR       0x1
+ 
+struct str8100_spi_dev_attr
+{ 
+	int spi_serial_mode;
+};
+
+#endif // end of #ifndef _STAR_SPI_H_
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_sys_memory_map.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_sys_memory_map.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_sys_memory_map.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_sys_memory_map.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_SYS_MEMORY_MAP_H_
+#define	_STAR_SYS_MEMORY_MAP_H_
+
+
+#if 0
+#define __UBOOT__
+#else
+#define __LINUX__
+#endif
+
+
+/*
+ * sytem memory	mapping	after reset
+ */
+#define SYSPA_FLASH_SRAM_BANK0_BASE_ADDR	0x10000000
+#define SYSPA_FLASH_SRAM_BANK1_BASE_ADDR	0x11000000
+#define SYSPA_FLASH_SRAM_BANK2_BASE_ADDR	0x12000000
+#define SYSPA_FLASH_SRAM_BANK3_BASE_ADDR	0x13000000
+#define	SYSPA_PCMCIA_ATTRIBUTE_MEMORY_BASE_ADDR	0x14000000
+#define	SYSPA_PCMCIA_COMMON_MEMORY_BASE_ADDR	0x15000000
+#define	SYSPA_PCMCIA_IO_SPACE_BASE_ADDR		0x16000000
+#define	SYSPA_IDE_DEVICE_BASE_ADDR		0x18000000
+#define	SYSPA_SDRAM_MEMORY_BASE_ADDR		0x20000000
+#define	SYSPA_GDMAC_BASE_ADDR			0x60000000
+#define	SYSPA_NIC_BASE_ADDR			0x70000000
+#define	SYSPA_SPI_BASE_ADDR			0x71000000
+#define	SYSPA_PCM_BASE_ADDR			0x71000000
+#define	SYSPA_I2C_BASE_ADDR			0x71000000
+#define	SYSPA_I2S_BASE_ADDR			0x71000000
+#define	SYSPA_DDRC_SDRC_BASE_ADDR		0x72000000
+#define	SYSPA_SMC_BASE_ADDR			0x73000000
+#define	SYSPA_PCMCIA_CONTROL_BASE_ADDR		0x73000000
+#define	SYSPA_IDE_CONTROLLER_BASE_ADDR		0x74000000
+#define	SYSPA_MISC_BASE_ADDR			0x76000000
+#define	SYSPA_POWER_MANAGEMENT_BASE_ADDR	0x77000000
+#define	SYSPA_UART0_BASE_ADDR			0x78000000
+#define	SYSPA_UART1_BASE_ADDR			0x78800000
+#define	SYSPA_TIMER_BASE_ADDR			0x79000000
+#define	SYSPA_WATCHDOG_TIMER_BASE_ADDR		0x7A000000
+#define	SYSPA_RTC_BASE_ADDR			0x7B000000
+#define	SYSPA_GPIOA_BASE_ADDR			0x7C000000
+#define	SYSPA_GPIOB_BASE_ADDR			0x7C800000
+#define	SYSPA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR	0xA0000000
+#define	SYSPA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR	0xA4000000
+#define	SYSPA_PCI_IO_SPACE_BASE_ADDR		0xA8000000
+#define	SYSPA_PCI_MEMORY_SPACE_BASE_ADDR	0xB0000000
+#define	SYSPA_USB11_CONFIG_BASE_ADDR		0xC0000000
+#define	SYSPA_USB11_OPERATION_BASE_ADDR		0xC4000000
+#define	SYSPA_USB20_CONFIG_BASE_ADDR		0xC8000000
+#define	SYSPA_USB20_OPERATION_BASE_ADDR		0xCC000000
+#define	SYSPA_USB20_DEVICE_BASE_ADDR		0xD0000000
+#define	SYSPA_VIC_BASE_ADDR			0xFFFFF000
+
+#if defined(__LINUX__)
+#define	SYSVA_FLASH_BASE_ADDR				0xFF000000
+#define SYSVA_IDE_DEVICE_BASE_ADDR		0xFFF00000
+#define SYSVA_GDMAC_BASE_ADDR			0xFFF01000
+#define SYSVA_NIC_BASE_ADDR			0xFFF02000
+#define SYSVA_SPI_BASE_ADDR			0xFFF03000
+#define SYSVA_PCM_BASE_ADDR			0xFFF04000
+#define SYSVA_I2C_BASE_ADDR			0xFFF05000
+#define SYSVA_I2S_BASE_ADDR			0xFFF06000
+#define SYSVA_DDRC_SDRC_BASE_ADDR		0xFFF07000
+#define SYSVA_SMC_BASE_ADDR			0xFFF08000
+#define SYSVA_PCMCIA_CONTROL_BASE_ADDR		0xFFF09000
+#define SYSVA_IDE_CONTROLLER_BASE_ADDR		0xFFF0A000
+#define SYSVA_MISC_BASE_ADDR			0xFFF0B000
+#define SYSVA_POWER_MANAGEMENT_BASE_ADDR	0xFFF0C000
+#define SYSVA_UART0_BASE_ADDR			0xFFF0D000
+#define SYSVA_UART1_BASE_ADDR			0xFFF0E000
+#define SYSVA_TIMER_BASE_ADDR			0xFFF0F000
+#define SYSVA_WATCHDOG_TIMER_BASE_ADDR		0xFFF10000
+#define SYSVA_RTC_BASE_ADDR			0xFFF11000
+#define SYSVA_GPIOA_BASE_ADDR			0xFFF12000
+#define SYSVA_GPIOB_BASE_ADDR			0xFFF13000
+#define SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR	0xFFF14000
+#define SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR	0xFFF15000
+#define SYSVA_USB11_CONFIG_BASE_ADDR		0xFFF16000
+#define SYSVA_USB11_OPERATION_BASE_ADDR		0xFFF17000
+#define SYSVA_USB20_CONFIG_BASE_ADDR		0xFFF18000
+#define SYSVA_USB20_OPERATION_BASE_ADDR		0xFFF19000
+#define SYSVA_USB20_DEVICE_BASE_ADDR		0xFFF1A000
+#define SYSVA_VIC_BASE_ADDR			0xFFF1B000
+#endif //__LINUX__
+
+#endif // end of #ifndef _STAR_SYS_MEMORY_MAP_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_timer.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_timer.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_timer.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_timer.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,312 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_TIMER_H_
+#define	_STAR_TIMER_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	TIMER_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_TIMER_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	TIMER_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_TIMER_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	TIMER1_COUNTER_REG			TIMER_MEM_MAP_VALUE(0x00)
+#define	TIMER1_AUTO_RELOAD_VALUE_REG		TIMER_MEM_MAP_VALUE(0x04)
+#define	TIMER1_MATCH_VALUE1_REG			TIMER_MEM_MAP_VALUE(0x08)
+#define	TIMER1_MATCH_VALUE2_REG			TIMER_MEM_MAP_VALUE(0x0C)
+
+#define	TIMER2_COUNTER_REG			TIMER_MEM_MAP_VALUE(0x10)
+#define	TIMER2_AUTO_RELOAD_VALUE_REG		TIMER_MEM_MAP_VALUE(0x14)
+#define	TIMER2_MATCH_VALUE1_REG			TIMER_MEM_MAP_VALUE(0x18)
+#define	TIMER2_MATCH_VALUE2_REG			TIMER_MEM_MAP_VALUE(0x1C)
+
+#define	TIMER1_TIMER2_CONTROL_REG		TIMER_MEM_MAP_VALUE(0x30)
+#define	TIMER1_TIMER2_INTERRUPT_STATUS_REG	TIMER_MEM_MAP_VALUE(0x34)
+#define	TIMER1_TIMER2_INTERRUPT_MASK_REG	TIMER_MEM_MAP_VALUE(0x38)
+
+#define	TIMER3_COUNTER_LOW_REG			TIMER_MEM_MAP_VALUE(0x40)
+#define	TIMER3_CONTROL_REG			TIMER_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * define constants macros
+ */
+#define	TIMER1_ENABLE_BIT_INDEX			0
+#define	TIMER1_CLOCK_SOURCE_BIT_INDEX		1
+#define	TIMER1_OVERFLOW_ENABLE_BIT_INDEX	2
+
+#define	TIMER2_ENABLE_BIT_INDEX			3
+#define	TIMER2_CLOCK_SOURCE_BIT_INDEX		4
+#define	TIMER2_OVERFLOW_ENABLE_BIT_INDEX	5
+
+#define	TIMER1_UP_DOWN_COUNT_BIT_INDEX		9
+#define	TIMER2_UP_DOWN_COUNT_BIT_INDEX		10
+
+#define	TIMER1_MATCH1_INTERRUPT_BIT_INDEX	0
+#define	TIMER1_MATCH2_INTERRUPT_BIT_INDEX	1
+#define	TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX	2
+
+#define	TIMER2_MATCH1_INTERRUPT_BIT_INDEX	3
+#define	TIMER2_MATCH2_INTERRUPT_BIT_INDEX	4
+#define	TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX	5
+
+#define TIMER3_ENABLE_BIT_INDEX			17
+#define TIMER3_RESET_BIT_INDEX			16
+
+#define	TIMER_CLOCK_SOURCE_PCLK			0
+#define	TIMER_CLOCK_SOURCE_EXT_CLK		1
+
+
+#define	TIMER_OVERFLOW_MODE_DISABLE		0
+#define	TIMER_OVERFLOW_MODE_ENABLE		1
+
+
+#define	TIMER_COUNTER_MODE_UP			0
+#define	TIMER_COUNTER_MODE_DOWN			1
+
+
+#define	MATCH1_MASK_ENABLE			(1 << 0)
+
+#define	MATCH2_MASK_ENABLE			(1 << 1)
+
+#define	OVERFLOW_MASK_ENABLE			(1 << 2)
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_TIMER_ENABLE_TIMER1() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER1() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER2() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER2() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER1_OVERFLOW_MODE()	\
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER1_OVERFLOW_MODE() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER2_OVERFLOW_MODE()	\
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER2_OVERFLOW_MODE() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER1_DOWNCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER1_UPCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER2_DOWNCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER2_UPCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_READ_INTERRUPT_STATUS(interrupt_status) \
+{ \
+    ((interrupt_status)	= (TIMER1_TIMER2_INTERRUPT_STATUS_REG)); \
+}
+
+
+#define	HAL_TIMER_WRITE_INTERRUPT_STATUS(interrupt_status) \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_STATUS_REG) = (interrupt_status)); \
+}
+
+
+#define	HAL_TIMER_READ_INTERRUPT_MASK(interrupt_mask) \
+{ \
+    ((interrupt_mask) =	(TIMER1_TIMER2_INTERRUPT_MASK_REG)); \
+}
+
+
+#define	HAL_TIMER_WRITE_INTERRUPT_MASK(interrupt_mask) \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	= (interrupt_mask)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_TIMER2_ALL_INTERRUPTS() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	= (0x3F));\
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = 0); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = (1 << TIMER3_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_RESET_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = (1 << TIMER3_RESET_BIT_INDEX)); \
+}
+
+#ifndef __ASSEMBLY__
+static inline unsigned long long HAL_TIMER_GET_TIMER3_COUNTER(void)
+{
+	unsigned long h;
+	unsigned long l;
+
+	h = TIMER3_CONTROL_REG & 0xFFFF;
+	l = TIMER3_COUNTER_LOW_REG;
+
+	return ((((unsigned long long)h) << 32) | l);
+}
+#endif
+
+#endif	// end of #ifndef _STAR_TIMER_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_uart.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_uart.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_uart.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_uart.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,350 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_UART_H_
+#define	_STAR_UART_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#define	UART_MEM_MAP_VALUE_PHY(reg_offset)	(*((u32	volatile *)(SYSPA_UART0_BASE_ADDR + reg_offset)))
+#define	UART_MEM_MAP_VALUE_VIR(reg_offset)	(*((u32	volatile *)(SYSVA_UART0_BASE_ADDR + reg_offset)))
+
+
+#define	UART1_OFFSET		0x800000  //SYS_UART1_BASE_ADDR	= 0x78800000 = (UART1_OFFSET+ SYS_UART0_BASE_ADDR)
+
+#define	__UART_RBR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	__UART_THR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	__UART_DLL(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+
+#define	__UART_IER(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+#define	__UART_DLM(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+
+#define	__UART_IIR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	__UART_FCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	__UART_PSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+
+#define	__UART_LCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x0C)
+#define	__UART_MCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	__UART_LSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x14)
+#define	__UART_SPR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x1C)
+
+#if defined(__UBOOT__)
+#define	_UART_RBR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	_UART_THR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	_UART_DLL(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+
+#define	_UART_IER(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+#define	_UART_DLM(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+
+#define	_UART_IIR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	_UART_FCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	_UART_PSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+
+#define	_UART_LCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x0C)
+#define	_UART_MCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	_UART_LSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x14)
+#define	_UART_SPR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x1C)
+#elif defined(__LINUX__)
+#define	_UART_RBR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+#define	_UART_THR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+#define	_UART_DLL(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+
+#define	_UART_IER(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x04)
+#define	_UART_DLM(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x04)
+
+#define	_UART_IIR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+#define	_UART_FCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+#define	_UART_PSR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+
+#define	_UART_LCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x0C)
+#define	_UART_MCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	_UART_LSR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x14)
+#define	_UART_SPR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x1C)
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define constants macros
+ */
+#define	UART_INPUT_CLOCK		(13000000)
+
+
+#define	UART_FIFO_DEPTH			16
+
+
+#define	RX_DATA_READY_INT		(1 << 0)
+#define	THR_EMPTY_INT			(1 << 1)
+#define	RX_LINE_STATUS_INT		(1 << 2)
+#define	MODEM_STATUS_INT		(1 << 3)
+
+
+#define	NO_INT_PENDING_MASK		(0x1)
+#define	RX_LINE_STATUS_INT_MASK		(0x6)
+#define	RX_DATA_READY_INT_MASK		(0x4)
+#define	RX_DATA_TIMEOUT_INT_MASK	(0xC)
+#define	THR_EMPTY_INT_MASK		(0x2)
+#define	MODEM_STATUS_CHANGE_MASK	(0x0)
+
+
+/* FCR Register	*/
+#define	FIFO_ENABLE			(1 << 0)
+#define	RX_FIFO_RESET			(1 << 1)
+#define	TX_FIFO_RESET			(1 << 2)
+#define	DMA_MODE			(1 << 3)
+
+
+#define	RX_FIFO_TRIGGER_LEVEL_1		(0 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_4		(1 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_8		(2 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_14	(3 << 6)
+
+
+#define	TX_FIFO_TRIGGER_LEVEL_1		(0 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_3		(1 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_9		(2 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_13	(3 << 4)
+
+
+
+/* LCR Register	*/
+#define	WORD_LENGTH_5			(0 << 0)
+#define	WORD_LENGTH_6			(1 << 0)
+#define	WORD_LENGTH_7			(2 << 0)
+#define	WORD_LENGTH_8			(3 << 0)
+
+#define	STOP_BIT_1			(0 << 2)
+#define	STOP_BIT_1_5			(1 << 2)
+#define	STOP_BIT_2			(1 << 2)
+
+#define	PARITY_CHECK_NONE		(0 << 3)
+#define	PARITY_CHECK_EVEN		(3 << 3)
+#define	PARITY_CHECK_ODD		(1 << 3)
+#define	PARITY_CHECK_STICK_ONE		(5 << 3)
+#define	PARITY_CHECK_STICK_ZERO		(7 << 3)
+
+#define	SET_BREAK			(1 << 6)
+
+#define	DLAB_ENABLE			(1 << 7)
+
+/* MCR Register	*/
+//#define UART_MCR_DTR			0x1		/* Data	Terminal Ready */
+//#define UART_MCR_RTS			0x2		/* Request to Send */
+//#define UART_MCR_OUT1			0x4		/* output1 */
+//#define UART_MCR_OUT2			0x8		/* output2 or global interrupt enable */
+#define	UART_MCR_LPBK			0x10		/* loopback mode */
+
+
+/* LSR Register	*/
+#define	_DATA_READY			(1 << 0)
+#define	OVERRUN_ERROR			(1 << 1)
+#define	PARITY_ERROR			(1 << 2)
+#define	FRAMING_ERROR			(1 << 3)
+#define	BREAK_INTERRUPT			(1 << 4)
+#define	THR_EMPTY			(1 << 5)
+#define	TRANSMITTER_EMPTY		(1 << 6)
+#define	FIFO_DATA_ERROR			(1 << 7)
+
+#define	TEST_PARITY_ERROR		(1 << 0)
+#define	TEST_FRAMING_ERROR		(1 << 1)
+#define	TEST_BAUD_GEN			(1 << 2)
+#define	TEST_LOOPBACK_ENABLE		(1 << 3)
+
+
+#define	WORD_FIVE_BITS			5
+#define	WORD_SIX_BITS			6
+#define	WORD_SEVEN_BITS			7
+#define	WORD_EIGHT_BITS			8
+
+#define	NONE_PARITY			1
+#define	EVEN_PARITY			2
+#define	ODD_PARITY			3
+#define	ONE_PARITY			4
+#define	ZERO_PARITY			5
+
+#define	ONE_STOP_BIT			1
+#define	ONE_HALF_STOP_BIT		2
+#define	TWO_STOP_BIT			3
+
+#define	TX_RX_FIFO_DISABLE		0
+#define	TX_RX_FIFO_ENABLE		1
+
+
+/*
+ * macros declarations
+ */
+
+#define	HAL_UART_READ_DATA(idx,data) \
+{ \
+    ((data) = (_UART_RBR(idx)) & 0xFF);	\
+}
+
+
+#define	HAL_UART_WRITE_DATA(idx,data) \
+{ \
+    ((_UART_THR(idx)) =	(data) & 0xFF);	\
+}
+
+
+#define	HAL_UART_ENABLE_INTERRUPT_TYPE(idx,interrupt_type) \
+{ \
+    ((_UART_IER(idx)) |= (interrupt_type & 0xF)); \
+}
+
+
+#define	HAL_UART_DISABLE_INTERRUPT_TYPE(idx,interrupt_type) \
+{ \
+    ((_UART_IER(idx)) &= ~(interrupt_type & 0xF)); \
+}
+
+
+#define	HAL_UART_READ_INTERRUPT_IDENTIFICATION(idx,uart_IIR) \
+{ \
+    ((uart_IIR)	= (_UART_IIR(idx))); \
+}
+
+
+#define	HAL_UART_CHECK_NO_INT_PENDING(idx,uart_IIR) \
+{ \
+    (((uart_IIR) & 0xF)	== (NO_INT_PENDING_MASK)); \
+}
+
+
+#define	HAL_UART_CHECK_RX_LINE_STATUS_INT(idx,uart_IIR)	\
+    (((uart_IIR) & 0xF)	== (RX_LINE_STATUS_INT_MASK))
+
+
+#define	HAL_UART_CHECK_RX_DATA_READY_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (RX_DATA_READY_INT_MASK))
+
+
+#define	HAL_UART_CHECK_RX_DATA_TIMEOUT_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (RX_DATA_TIMEOUT_INT_MASK))
+
+
+#define	HAL_UART_CHECK_THR_EMPTY_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (THR_EMPTY_INT_MASK))
+
+
+#define	HAL_UART_FIFO_ENABLE(idx) \
+{ \
+    ((_UART_FCR(idx)) |= (FIFO_ENABLE)); \
+}
+
+
+#define	HAL_UART_FIFO_DISABLE(idx) \
+{ \
+    ((_UART_FCR(idx)) &= ~(FIFO_ENABLE)); \
+}
+
+
+#define	HAL_UART_RESET_RX_FIFO(idx) \
+{ \
+   ((_UART_FCR(idx)) |=	(RX_FIFO_RESET)); \
+}
+
+
+#define	HAL_UART_RESET_TX_FIFO(idx) \
+{ \
+    ((_UART_FCR(idx)) |= (TX_FIFO_RESET)); \
+}
+
+
+#define	HAL_UART_DLAB_ENABLE(idx) \
+{ \
+    ((_UART_LCR(idx)) |= (DLAB_ENABLE)); \
+}
+
+
+#define	HAL_UART_DLAB_DISABLE(idx) \
+{ \
+    ((_UART_LCR(idx)) &= ~(DLAB_ENABLE)); \
+}
+
+
+#define	HAL_UART_ENABLE_LOOPBACK_MODE(idx) \
+{ \
+    ((_UART_MCR(idx)) |= (UART_MCR_LPBK)); \
+}
+
+
+#define	HAL_UART_DISABLE_LOOPBACK_MODE(idx) \
+{ \
+    ((_UART_MCR(idx)) &= ~(UART_MCR_LPBK)); \
+}
+
+
+#define	HAL_UART_READ_LINE_STATUS(idx,uart_LSR)	\
+{ \
+    ((uart_LSR)	= (_UART_LSR(idx))); \
+}
+
+
+#define	HAL_UART_WRITE_DLL(idx,dll_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_DLL(idx) = (u32)dll_value; \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_WRITE_DLM(idx,dlm_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_DLM(idx) = (u32)dlm_value; \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_WRITE_PSR(idx,psr_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_PSR(idx) = (u32)(psr_value & 0x3); \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_READ_PSR(idx,psr_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    (psr_value)	= (u32)((_UART_PSR(idx)) & 0x3); \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_CHECK_RX_DATA_READY(idx) \
+    (((_UART_LSR(idx)) & _DATA_READY) == (_DATA_READY))
+
+
+#define	HAL_UART_CHECK_TX_FIFO_EMPTY(idx) \
+    (((_UART_LSR(idx)) & THR_EMPTY) == (THR_EMPTY))
+
+
+#define	HAL_UART_CHECK_TRANSMITTER_EMPTY(idx) \
+    (((_UART_LSR(idx)) & TRANSMITTER_EMPTY) == (TRANSMITTER_EMPTY))
+
+
+#endif	// end of #ifndef _STAR_UART_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_wdtimer.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_wdtimer.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/star_wdtimer.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/star_wdtimer.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,170 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_WATCHDOG_TIMER_H_
+#define	_STAR_WATCHDOG_TIMER_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	WDTIMER_MEM_MAP_VALUE(reg_offset)	(*((u32	volatile *)(SYSPA_WATCHDOG_TIMER_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	WDTIMER_MEM_MAP_VALUE(reg_offset)	(*((u32	volatile *)(SYSVA_WATCHDOG_TIMER_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	WDTIMER_COUNTER_REG			WDTIMER_MEM_MAP_VALUE(0x00)
+#define	WDTIMER_AUTO_RELOAD_REG			WDTIMER_MEM_MAP_VALUE(0x04)
+#define	WDTIMER_COUNTER_RESTART_REG		WDTIMER_MEM_MAP_VALUE(0x08)
+#define	WDTIMER_CONTROL_REG			WDTIMER_MEM_MAP_VALUE(0x0C)
+#define	WDTIMER_STATUS_REG			WDTIMER_MEM_MAP_VALUE(0x10)
+#define	WDTIMER_CLEAR_REG			WDTIMER_MEM_MAP_VALUE(0x14)
+#define	WDTIMER_INTERRUPT_LENGTH_REG		WDTIMER_MEM_MAP_VALUE(0x18)
+
+
+/*
+ * define constants macros
+ */
+#define	WDTIMER_ENABLE_BIT			(1 << 0)
+#define	WDTIMER_SYSTEM_RESET_ENABLE_BIT		(1 << 1)
+#define	WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT	(1 << 2)
+#define	WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT	(1 << 3)
+#define	WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT	(1 << 4)
+
+
+#define	WDTIMER_MAGIC_RESTART_VALUE		(0x5AB9)
+
+
+/*
+ * macros declarations
+ */
+#define	HAL_WDTIMER_READ_COUNTER(counter) \
+{ \
+    ((counter) = (WDTIMER_COUNTER_REG)); \
+}
+
+
+#define	HAL_WDTIMER_WRITE_AUTO_RELOAD_COUNTER(counter) \
+{ \
+    ((WDTIMER_AUTO_RELOAD_REG) = (counter)); \
+}
+
+
+#define	HAL_WDTIMER_READ_AUTO_RELOAD_COUNTER(counter) \
+{ \
+    ((counter) = (WDTIMER_AUTO_RELOAD_REG)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_RESTART_RELOAD() \
+{ \
+    ((WDTIMER_COUNTER_RESTART_REG) = (WDTIMER_MAGIC_RESTART_VALUE)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_SYSTEM_RESET() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_SYSTEM_RESET_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_SYSTEM_RESET() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_SYSTEM_RESET_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_SYSTEM_INTERRUPT() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_SYSTEM_INTERRUPT() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_EXTERNAL_SIGNAL() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_EXTERNAL_SIGNAL() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_CLOCK_SOURCE_PCLK()	\
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_CLOCK_SOURCE_EXTCLK() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_READ_STATUS(status)	\
+{ \
+    ((status) =	(WDTIMER_STATUS_REG) & 0x00000001); \
+}
+
+
+#define	HAL_WDTIMER_CLEAR_STATUS() \
+{ \
+    ((WDTIMER_CLEAR_REG) = (1)); \
+}
+
+
+#define	HAL_WDTIMER_WRITE_INTERRUPT_LENGTH(length) \
+{ \
+    ((WDTIMER_INTERRUPT_LENGTH_REG) = (length) & 0x000000FF); \
+}
+
+
+#endif	// end of #ifndef _STAR_WATCHDOG_TIMER_H_
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/system.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/system.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/system.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/system.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,50 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_SYSTEM_H__
+#define __ASM_ARCH_SYSTEM_H__
+
+#include <mach/star_powermgt.h>
+#include <mach/star_timer.h>
+
+static inline void arch_idle(void)
+{
+	volatile u32 dst= (*((u32 volatile *)(SYSVA_FLASH_BASE_ADDR + 0x20000)));
+
+// local_irq_enable();
+
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	HAL_PWRMGT_GLOBAL_SOFTWARE_RESET();
+}
+
+extern u64 volatile str8100_counter_tick;
+static inline u64 str8100_read_counter(void)
+{
+        return (str8100_counter_tick + TIMER2_COUNTER_REG);
+}
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/timex.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/timex.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/timex.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/timex.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#if 1 // on ASIC
+#define CLOCK_TICK_RATE		(43750000)
+#else // on FPGA
+#define CLOCK_TICK_RATE		(13000000)
+#endif
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/uncompress.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/uncompress.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/uncompress.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/uncompress.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H__
+#define __ASM_ARCH_UNCOMPRESS_H__
+
+#include <mach/star_uart.h>
+
+#define flush(x)	
+
+
+static void putstr(const char *s)
+{
+	while (*s) {
+		volatile unsigned int status = 0;
+
+		do {
+			status = __UART_LSR(0);
+		} while (!((status & THR_EMPTY) == THR_EMPTY));
+
+		__UART_THR(0) = *s;
+
+		if (*s == '\n') {
+			do {
+				status = __UART_LSR(0);
+			} while (!((status & THR_EMPTY) == THR_EMPTY));
+			__UART_THR(0) = '\r';
+		}
+		s++;
+	}
+}
+
+static const char * const digits="0123456789ABCDEF";
+static void ser_puts_hex8(unsigned char hex)
+{ 
+   char buf[3];
+   buf[0] = digits[(hex >> 4) & 0xF];
+   buf[1] = digits[hex & 0xF];
+      
+   buf[2] = '\0';
+   putstr(buf);
+}
+void ser_puts_hex32(unsigned long hex)
+{
+   char buf[9];
+   int i;
+   
+   for(i=7; i >= 0; i--)
+   {
+      buf[7-i] = digits[(hex >> (i * 4)) & 0xF];
+   }
+   
+   buf[8] = '\0';
+  putstr(buf);
+}
+
+/*
+static void putc(int c)
+{
+ star_putstr(&c);
+}
+
+*/
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/include/mach/vmalloc.h linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/vmalloc.h
--- linux-2.6.35.11/arch/arm/mach-str8100/include/mach/vmalloc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/include/mach/vmalloc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,31 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __ASM_ARCH_VMALLOC_H__
+#define __ASM_ARCH_VMALLOC_H__
+
+//#include <linux/config.h>
+
+#define VMALLOC_END	(PAGE_OFFSET + 0x10000000)
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/Kconfig linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Kconfig
--- linux-2.6.35.11/arch/arm/mach-str8100/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,143 @@
+if ARCH_STR8100
+
+menu "STR8100 Options"
+
+config CONSOLE_BAUD_RATE
+	int "Console Baud Rate"
+	default 38400
+	help
+	  set the console baudrate
+
+config VIC_INTERRUPT
+	bool "Enable Vector Interrupt Controller"
+	default y
+	help
+	  enable the vector interrupt controller
+
+choice
+	prompt "DRAM SIZE"
+	default STR8100_DRAM_16M
+
+config STR8100_DRAM_16M
+	bool "16MBytes"
+
+config STR8100_DRAM_32M
+	bool "32MBytes"
+
+config STR8100_DRAM_64M
+	bool "64MBytes"
+
+endchoice
+
+if PCI
+choice
+	prompt "PCI Frequency"
+	default STR8100_PCI33M
+
+config STR8100_PCI33M
+	bool "PCI_33Mhz"
+
+config STR8100_PCI66M
+	bool "PCI_66Mhz"
+
+endchoice
+endif
+
+config STR8100_DMA
+	bool "Enable DMA Controller"
+	default n
+	help
+	  enable the DMA controller
+
+config STR8100_HSDMA
+	bool "Enable HSDMA Controller"
+	default n
+	help
+	  enable the HSDMA controller
+
+config STR8100_INFO
+	bool "STR8100 Infomation at /proc/str8100/info"
+
+config STR8100_USBD_REBOOT_INTHANDLER
+	tristate "USB Mass Storage Device"
+
+config STR8100_I2S
+	bool "Enable I2S sound"
+	default n
+	help
+	  enable the I2S sound with /proc/str8100/i2s
+
+config STR8100_I2S_DEMO
+	tristate "Enable I2S sound demo driver"
+	default n
+	help
+	  enable the I2S sound demo driver with /proc/str8100/i2s
+
+config STR8100_I2S_WM8772_DEMO
+	tristate "Enable I2S sound demo driver with WM8772"
+	default n
+	help
+	  enable the I2S sound demo driver with wm8772
+
+config LE88221_CONTROL
+	bool "Legerity LE88221 Control Support"
+	depends on SPI
+
+config STR8100_PCM_LEGERITY_2PHONE_DEMO
+	tristate "2 phone PCM sound demo driver for Legerity"
+	select LE88221_CONTROL
+	default n
+
+config STR8100_RTC
+	bool "STR8100 Real Time Clock Support"
+
+config STR8100_GPIO
+	bool "STR8100 GPIO Support"
+	
+config STR8100_GPIO_INTERRUPT
+	bool "Interrupt Library Support"
+	depends on STR8100_GPIO	
+
+config STR8100_GPIO_GENERIC_INTERFACE
+	bool "Generic GPIO Interface Support"
+	depends on STR8100_GPIO	
+	select GENERIC_GPIO
+
+comment "Flash MAP"
+config STR8100_FLASH_PART
+	bool "STR8100 flash partition setting"
+
+if STR8100_FLASH_PART
+	config ARMBOOT_OFFSET
+	hex "ARMBOOT OFFSET"
+	default 0x0
+	help
+	  The armboot start offset in flash layout
+
+	config KERNEL_OFFSET
+	hex "KERNEL OFFSET"
+	default 0x40000
+	help
+	  The kernel start offset in flash layout
+
+	config ROOTFS_OFFSET
+	hex "ROOTFS OFFSET"
+	default 0x140000
+	help
+	  The rootfs start offset in flash layout
+
+	config CFG_OFFSET
+	hex "CFG OFFSET"
+	default 0x7f0000
+	help
+	  The cfg start offset in flash layout
+endif
+
+
+comment "Third Party Support"
+
+config STR8100_EWC_SUPPORT
+	bool "EWC(802.11N) Support"
+endmenu
+
+endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/le88221_control.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/le88221_control.c
--- linux-2.6.35.11/arch/arm/mach-str8100/le88221_control.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/le88221_control.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,1037 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <asm/semaphore.h>
+#include <mach/star_spi.h>
+
+static struct spi_device *le88221_spidev;
+static struct semaphore le88221_lock;
+
+/******************************************************************************
+* Busy Tone
+* Frequency: 480Hz + 620Hz
+* Temporal Pattern: 0.5s on/ 0.5s off
+* Event Reported After: 2 cycles of precise, 3 cycles of nonprecise
+*******************************************************************************/
+void le88221_busy_tone(struct spi_device *spi)
+{
+	u8 rx_data;
+	u8 write_data;
+	int retval;
+
+	//enable channel 1 and channel 2
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator 
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator C and D    
+	// 05 1F 1C C5 06 9D 1C C5
+	//FreqC= 1311(0x051f) * 0.3662 = 480.0882 Hz
+	//AmpC = 7365(0x1cc5) * 
+	//FreqD= 1693(0x069d) * 0.3662 = 619.9766 Hz
+	//AmpCD= 7365(0x1cc5) *
+	write_data = 0xD4;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x05;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xC5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x06;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x9D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xC5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Cadence Timer
+	// 00 64 00 64 (100ms On/ 100ms Off)
+	write_data = 0xE0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x64;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x64;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator
+	//Eanble Signal generator cadencing, Signal generator C,D
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x8C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System State
+	//Activate codec, Active Low battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x23;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+}
+
+/******************************************************************************
+* Dial Tone
+* Frequency: 350Hz + 440Hz
+* Temporal Pattern: Steady tone
+* Event Reported After: Approximately 0.75 seconds
+*******************************************************************************/
+void spi_le88221_dial_tone(struct spi_device *spi)
+{
+	u8 rx_data;
+	u8 write_data;
+	int retval;
+
+	//enable channel 1 and channel 2
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator 
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator C and D    
+	// 03 BC 1C C5 04 B2 1C C5
+	write_data = 0xD4;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xBC;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xC5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x04;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xB2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xC5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Cadence Timer
+	// 00 00 00 00
+	write_data = 0xE0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator
+	//Eanble Signal generator cadencing, Signal generator C,D
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x8C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System State
+	//Activate codec, Active Low battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x23;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+}
+
+void le88221_balanced_ring(struct spi_device *spi)
+{
+	u8 rx_data;
+	u8 write_data;
+	int retval;
+ 
+	//enable channel 1 and channel 2
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Write Signal Generator A,B and Bias Param
+	// 00 00 00 00 37 42 5B 00 00 00 00
+	//0x00:Ramp has a positive slope, SG A,B out continuous, sinusoidal waves
+	//Bias : 0 (0x0000) V
+	//FreqA: 55(0x0037) * 0.3662 = 20.141 Hz 
+	//AmpA : 16987(0x425B)
+	//FreqB: 0(0x0000) * 0.3662 = 0 Hz
+	//AmpB : 0(0x0000)
+	write_data = 0xD2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x37;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x5B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System State
+	//Activate codec, Active Mid Battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x2B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Loop Supervision Param
+	// 1B 84 B3 05
+	write_data = 0xC2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x84;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xB3;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x05;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System state        
+	//Deactivate codec, Balanced ringing
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x07;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+}
+
+void le88221_unbalanced_ring(struct spi_device *spi)
+{
+	u8 rx_data;
+	u8 write_data;
+	int retval;
+
+	//enable channel 1 and channel 2
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator 
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Cadence Timer
+	//01 90 03 20 (400ms on/800ms off)
+	write_data = 0xE0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x90;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x20;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Signal generator 
+	// Enable tone generator specified by EGA...
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x80;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Write Signal Generator A,B and Bias Param
+	// 00 00 00 00 37 21 2D 00 00 00 00
+	//0x00:Ramp has a positive slope, SG A,B out continuous, sinusoidal waves
+	//Bias : 0(0x0000) V
+	//FreqA: 55(0x0037) * 0.3662 = 20.141 Hz 
+	//AmpA : 8493(0x212D)
+	//FreqB: 0(0x0000) * 0.3662 = 0 Hz
+	//AmpB : 0(0x0000)
+	write_data = 0xD2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x37;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x21;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x2D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System State
+	//Activate codec, Active Mid Battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x2B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set Loop Supervision Param
+	// 1B 84 33 05
+	write_data = 0xC2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x1B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x84;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x33;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x05;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+
+	//Set System state        
+	//Deactivate codec, Balanced ringing
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0x0A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+}
+
+u32 le88221_hook_off(struct spi_device *spi)
+{
+	u8 rx_data;
+	u8 rx_data21, rx_data22;
+	u8 write_data;
+	int retval;
+
+	/* if Hook1/2 off hook status at the same time */ 	        	    
+	/*
+	 * Check Hook1/2 On or Off (Read Signaling Register)
+	 * Hook Switch, 0:On hook , 1:Off hook
+	 */
+	write_data = 0x4F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data21, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &rx_data22, 1);
+
+	return ((rx_data21 & 0x01) && (rx_data22 & 0x01));
+}
+
+static int le88221_init_hw(struct spi_device *spi)
+{
+#if 0
+	int retval;
+	u8 write_data;
+	u8 read_data;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	if (retval < 0) {
+
+	}
+#endif
+
+#if 0
+	u8 tx_buf[] = { 0x00, 0x00, 0x00, 0x00 };
+	u8 rx_buf[] = { 0x00, 0x00, 0x00, 0x00 };
+	struct spi_transfer t[2];
+	struct spi_message m;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+
+	t[0].tx_buf = tx_buf;
+	t[0].len = sizeof(tx_buf);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = rx_buf;
+	t[1].len = sizeof(rx_buf);
+	spi_message_add_tail(&t[1], &m);
+
+	down(&le88221_lock);
+	spi_sync(flash->spi, &m);
+	up(&le88221_lock);
+
+#endif
+
+	int retval;
+	u8 write_data;
+	u8 read_data;
+
+	// Hardware Reset
+	write_data = 0x04;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// 1ms delay
+	udelay(1000);
+
+	// I/O direction
+	write_data = 0x54;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x02;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x55;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	// Write Device Register(Define PCLK freq,ie 2.048MHz)
+	write_data = 0x46;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x02;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	write_data = 0x47;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Read Revision Code Number (RCN)
+	write_data = 0x73;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	printk("Revision:0x%02x\n", read_data);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	printk("Product:0x%02x\n", read_data);
+
+	/* 
+	 * Write SRP register for Flyback power supply(VBL reference) 
+	 * Note there should be voltages on VBH, VBL, VREF after the following codes are invoked.
+	 */
+	write_data = 0xE4;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x05;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x80;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0xE5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+    
+	// Write SRC register
+	write_data = 0xE6;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x07;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0xE7;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);   
+#endif
+    
+    	// wait 100ms delay until switing regulator is stable
+	mdelay(100);
+
+	// System State Register
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#ifdef Print_Reg
+	write_data = 0x57;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif    
+
+	// I/O Data Register
+	write_data = 0x52;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x53;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif        
+
+	/*
+	 * For channel 1,2 operation
+	 */
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x03;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x4B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	// Operating Functions
+	write_data = 0x60;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x61;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	// Operating Conditions
+	write_data = 0x70;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x71;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	// Loop Supervision Parameters  19 88 A4 00 */
+	write_data = 0xC2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x19;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x88;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA4;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// DC Feed Parameters  2C 08
+	write_data = 0xC6;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x08;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Signal Generator A and B Parameters  00 04 25 00 37 3E C3 00 00 00 00
+	write_data = 0xD2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x04;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x25;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x37;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3E;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xC3;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x44;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x68;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x35;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Digital Impedance Scaling Network
+	write_data = 0xCA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xEA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0xCB;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+    
+	// Z-Filter (FIR Only) Coefficients BA EB 2A 2C B5 25 AA 24 2C 3D
+	write_data = 0x98;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xBA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xEB;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xB5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x25;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xAA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x24;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Z-Filter (IIR Only) Coefficients  AA BA 27 9F 01
+	write_data = 0x9A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xAA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xBA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x27;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x9F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// R-Filter Coefficients  2D 01 2B B0 5A 33 24 5C 35 A4 5A 3D 33 B6
+	write_data = 0x8A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xB0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x5A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x33;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x24;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x5C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x35;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA4;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x5A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x33;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xB6;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// X-Filter Coefficients 3A 10 3D 3D B2 A7 6B A5 2A CE 2A 8F
+	write_data = 0x88;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x10;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x3D;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xB2;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA7;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x6B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xCE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x8F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// GR (Receive Gain A8 71
+	write_data = 0x82;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA8;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x71;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// GX (Transmit Gain) A9 F0
+	write_data = 0x80;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA9;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xF0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Voice Path Gains
+	write_data = 0x50;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef PRINT_REG
+	write_data = 0x51;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	// B1-Filter (FIR Only) Coefficients  2A 42 22 4B 1C A3 A8 FF 8F AA F5 9F BA F0
+	write_data = 0x86;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x22;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x4B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x1C;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA3;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xA8;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x8F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xAA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xF5;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x9F;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xBA;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xF0;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// B2-Filter (IIR Only) Coefficients 2E 01
+	write_data = 0x96;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x2E;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+ 	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);   
+
+	//le88221_busy_tone(spi);
+	//le88221_dial_tone(spi);
+	//le88221_balanced_ring(spi);
+	le88221_unbalanced_ring(spi);
+
+#if 1
+	while (!le88221_hook_off(spi))
+		; // do nothing
+#endif
+
+#ifdef OPEN_CH1_2
+	SPI_DEBUG("=== Configure channel 1...\n");
+	/*
+	 * For channel 1 operation, Active mode
+	 */
+	//Set Channel Enable and Operating Mode
+	//Channel 1 enabled, Channel 2 disabled
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set Signal generator
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set Operating Conditions
+	//0x00 : all disabled
+	write_data = 0x70;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set System state
+	//Activate codec, Active Low Battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x23;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	/*
+	 * If you want loopback test , you can TX_Time_Slot 00, TX_Time_Slot 02
+	 */
+	//Set Transmit time slot
+	write_data = 0x40;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+#ifdef LEGERITY_LOOPBACK_TEST
+	//Set Receive time slot
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x02;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#else
+	//Set Receive time slot
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif                                        
+
+	//Read Register Status
+	write_data = 0x4B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read Register Status(0x4B): channel 1 %s, channel 2 %s\n",(rx_data&0x01)?"enabled":"disabled",(rx_data&0x02)?"enabled":"disabled");
+
+	//Read System State Register
+	write_data = 0x57;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read System State Register(0x57): REX=%d, METR=%d, Codec %s, POLNR=%d, SS=0x%x\n",(rx_data&(1<<7)),(rx_data&(1<<6)),(rx_data&(1<<5))?"enabled":"disabled",(rx_data&(1<<4)),(rx_data&0xF));
+    
+	//Read Transmit time slot
+	write_data = 0x41;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Read Receive time slot
+	write_data = 0x43;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	SPI_DEBUG("=== Configure channel 2...\n");
+	/* 
+	 * For channel 2 operation, Active mode 
+	 */
+	//Set Channel Enable and Operating Mode
+	//Channel 1 disabled, Channel 2 enabled
+	write_data = 0x4A;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x02;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set Signal generator
+	//0x00: all disabled
+	write_data = 0xDE;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set Operating Conditions
+	//0x00 : all disabled
+	write_data = 0x70;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	//Set System state
+	//Activate codec, Active Low Battery
+	write_data = 0x56;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x23;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	/*
+	 * If you want loopback test , you can TX_Time_Slot 00, TX_Time_Slot 02 
+	 */
+#ifdef LEGERITY_LOOPBACK_TEST
+	// Transmit time slot
+	write_data = 0x40;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x02;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Receive time slot
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x00;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#else
+	// Transmit time slot
+	write_data = 0x40;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+
+	// Receive time slot
+	write_data = 0x42;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0x01;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+#endif
+
+	//Read Register Status
+	write_data = 0x4B;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read Register Status(0x4B): channel 1 %s, channel 2 %s\n",(rx_data&0x01)?"enabled":"disabled",(rx_data&0x02)?"enabled":"disabled");
+
+	//Read System State Register
+	write_data = 0x57;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read System State Register(0x57): REX=%d, METR=%d, Codec %s, POLNR=%d, SS=0x%x\n",(rx_data&(1<<7)),(rx_data&(1<<6)),(rx_data&(1<<5))?"enabled":"disabled",(rx_data&(1<<4)),(rx_data&0xF));
+
+	//Read Transmit time slot
+	write_data = 0x41;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read Transmit time slot(0x41): Transmit time slot = 0x%02x\n",rx_data&0x7f);
+
+	//Read Receive time slot
+	write_data = 0x43;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	write_data = 0xFF;
+	retval = spi_write_read_sync(spi, &write_data, 1, &read_data, 1);
+	SPI_DEBUG("Read Receive time slot(0x43): Receive time slot = 0x%02x\n",rx_data&0x7f);
+#endif      
+
+	return 0;
+}
+
+void Pcm_Initial_Legerity_Le88221(void)
+{
+	le88221_init_hw(le88221_spidev);
+}
+
+static int __devinit le88221_probe(struct spi_device *spi)
+{
+	le88221_spidev = spi;
+	init_MUTEX(&le88221_lock);
+	return 0;
+}
+
+static int __devexit le88221_remove(struct spi_device *spi)
+{
+	printk("le88221_remove() enter\n");
+	return 0;
+}
+
+static struct spi_driver le88221_driver = {
+	.driver = {
+		.name	= "le88221",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= le88221_probe,
+	.remove	= __devexit_p(le88221_remove),
+};
+
+static int le88221_init(void)
+{
+	return spi_register_driver(&le88221_driver);
+}
+
+static void le88221_exit(void)
+{
+	spi_unregister_driver(&le88221_driver);
+}
+
+module_init(le88221_init);
+module_exit(le88221_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Star Semi");
+MODULE_DESCRIPTION("Legerity Le88221 driver");
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/Makefile linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Makefile
--- linux-2.6.35.11/arch/arm/mach-str8100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,26 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+str8100_demo_pcm_legerity_2phone-objs := str8100_demo_pcm_legerity_config_2phone.o
+str8100_demo_i2s-objs := str8100_demo_i2s_config.o
+str8100_demo_i2s_wm8772-objs := str8100_demo_i2s_wm8772_config.o
+
+obj-y			:= str8100_debug.o str8100_setup.o str8100_timer.o str8100_intc.o str8100_misc.o str8100_counter.o str8100_pm.o str8100_demo_dma.o
+obj-m			:=
+obj-n			:=
+obj-			:=
+
+obj-$(CONFIG_PCI) += str8100_pci.o
+obj-$(CONFIG_STR8100_DMA) += str8100_dma.o
+obj-$(CONFIG_STR8100_HSDMA) += str8100_hsdma.o
+obj-$(CONFIG_STR8100_I2S) += str8100_i2s.o
+obj-$(CONFIG_STR8100_I2S_DEMO) += str8100_demo_i2s.o
+obj-$(CONFIG_STR8100_I2S_WM8772_DEMO) += str8100_demo_i2s_wm8772.o
+obj-$(CONFIG_LE88221_CONTROL) += le88221_control.o
+obj-$(CONFIG_STR8100_PCM_LEGERITY_2PHONE_DEMO) += str8100_demo_pcm_legerity_2phone.o
+obj-$(CONFIG_STR8100_RTC)	+= str8100_rtc.o
+obj-$(CONFIG_STR8100_GPIO)	+= str8100_gpio.o
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/Makefile.boot linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Makefile.boot
--- linux-2.6.35.11/arch/arm/mach-str8100/Makefile.boot	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/Makefile.boot	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,11 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00C00000
+# scott.test
+kernel_phys-y	:= 0x00600000
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_counter.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_counter.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_counter.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_counter.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,215 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/timex.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+u64 volatile str8100_counter_tick;
+EXPORT_SYMBOL(str8100_counter_tick);
+
+static struct proc_dir_entry *str8100_counter_proc_entry;
+
+#if 0
+// this is defined in include/asm/arch-str8100/system.h
+u64 str8100_read_counter(void)
+{
+	return (str8100_counter_tick + TIMER2_COUNTER_REG);
+}
+EXPORT_SYMBOL(str8100_read_counter);
+#endif
+
+static int match1=0;
+static int match2=0;
+static void str8100_setup_counter(void)
+{
+	unsigned long control_value;
+	unsigned long mask_value;    
+	unsigned long val;    
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+	mask_value = TIMER1_TIMER2_INTERRUPT_MASK_REG;
+
+	TIMER2_COUNTER_REG		= 0;
+	TIMER2_AUTO_RELOAD_VALUE_REG	= 0;
+	TIMER2_MATCH_VALUE1_REG		= match1;
+	TIMER2_MATCH_VALUE2_REG		= match2;
+
+	// Clock Source: PCLK
+	control_value &= ~(1 << TIMER2_CLOCK_SOURCE_BIT_INDEX);
+
+	// UP Count Mode
+	control_value &= ~(1 << TIMER2_UP_DOWN_COUNT_BIT_INDEX);
+
+	// un-mask match1, match2, and overflow interrupt sources
+	mask_value &= ~(0x7 << 3);
+
+	// mask match1, match2 interrupt sources
+	//mask_value |= (0x3 << 3);
+	val=0;
+	if(!match1) val|=0x1;
+	if(!match2) val|=0x2;
+	mask_value |= (val<< 3);
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+	TIMER1_TIMER2_INTERRUPT_MASK_REG = mask_value;
+}
+
+static void str8100_counter_enable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+
+	// enable overflow mode
+	control_value |= (1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value |= (1 << TIMER2_ENABLE_BIT_INDEX);
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+}
+
+static void str8100_counter_disable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+
+	// enable overflow mode
+	control_value &= ~(1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value &= ~(1 << TIMER2_ENABLE_BIT_INDEX);
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+str8100_counter_interrupt(int irq, void *dev_id /*, struct pt_regs *regs*/)
+{
+#ifndef CONFIG_VIC_INTERRUPT
+	// clear counter interrrupt status
+	TIMER1_TIMER2_INTERRUPT_STATUS_REG &= ~(1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX);
+#endif
+	str8100_counter_tick += (1ULL << 32);
+	if(match1){
+		TIMER2_MATCH_VALUE1_REG=TIMER2_COUNTER_REG+match1;
+		TIMER1_TIMER2_INTERRUPT_MASK_REG |= (0x1<<3);
+	}
+	if(match2){
+		TIMER2_MATCH_VALUE2_REG=TIMER2_COUNTER_REG+match2;
+		TIMER1_TIMER2_INTERRUPT_MASK_REG |= (0x2<<3);
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction str8100_counter_irq = {
+	.name		= "STR8100 Counter Tick",
+	/* scott.patch */
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= str8100_counter_interrupt,
+};
+
+static int str8100_counter_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	return sprintf(page, "str8100_counter_tick: %llu\n", str8100_counter_tick + TIMER2_COUNTER_REG);
+}
+
+
+static int
+str8100_counter_write_proc(struct file *file, const char __user *buffer,
+	unsigned long count, void *data)
+{
+	char *str;
+	char *cmd;
+
+	if (count > 0) {
+		str = (char *)buffer,
+		cmd = strsep(&str, "\t \n");
+		if (!cmd) goto err_out;
+		if (strcmp(cmd, "match1") == 0) {
+			u32 addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 10);
+			match1=addr;
+
+		} else if (strcmp(cmd, "match2") == 0) {
+			u32 addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 10);
+			match2=addr;
+
+
+		} else {
+			goto err_out;
+		}
+	}
+	if(match1){
+		TIMER2_MATCH_VALUE1_REG=TIMER2_COUNTER_REG+match1;
+		TIMER1_TIMER2_INTERRUPT_MASK_REG |= (0x1<<3);
+	}
+	if(match2){
+		TIMER2_MATCH_VALUE2_REG=TIMER2_COUNTER_REG+match2;
+		TIMER1_TIMER2_INTERRUPT_MASK_REG |= (0x2<<3);
+	}
+
+	return count;
+
+err_out:
+	return -EFAULT;
+}
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+int __init str8100_counter_setup(void)
+{
+     
+	str8100_setup_counter();
+	setup_irq(INTC_TIMER2_BIT_INDEX, &str8100_counter_irq);
+	str8100_counter_enable();
+	str8100_counter_proc_entry = create_proc_entry("str8100/counter", S_IFREG | S_IRUGO, NULL);
+	if (str8100_counter_proc_entry) {
+		str8100_counter_proc_entry->read_proc = str8100_counter_read_proc;
+		str8100_counter_proc_entry->write_proc = str8100_counter_write_proc;
+	}
+
+	return 0;
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_debug.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_debug.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_debug.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_debug.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/types.h>
+#include <mach/hardware.h>
+
+void debug_puts(const char *s)
+{
+	while (*s) {
+		volatile unsigned int status = 0;
+		do {
+			status = _UART_LSR(0);
+		} while (!((status & THR_EMPTY) == THR_EMPTY));
+
+		_UART_THR(0) = *s;
+
+		if (*s == '\n') {
+			do {
+				status = _UART_LSR(0);
+			} while (!((status & THR_EMPTY) == THR_EMPTY));
+
+			_UART_THR(0) = '\r';
+		}
+		s++;
+	}
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_dma.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_dma.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_dma.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_dma.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,576 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//Options 
+//#define DEBUG_PRINT	
+//=================================================================================
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/delay.h>
+#include <mach/star_demo_dma.h>
+#include <mach/star_i2s.h>
+#include <mach/star_powermgt.h>
+#include <mach/star_misc.h>
+#include <mach/star_gpio.h>
+
+#ifdef DEBUG_PRINT
+#undef DEBUG_PRINT
+//#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+#define DEBUG_PRINT printk
+#else
+#define DEBUG_PRINT(arg...) 
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_Dmac_Get_Channel_Transfer_Unit_Number
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+u32 Hal_Dmac_Get_Channel_Transfer_Unit_Number(u32 byte_size, u32 src_width)
+{
+    u32    transfer_unit_num;
+    
+    
+    if (src_width == DMAC_CH_SRC_WIDTH_8_BITS)  // 8-bit
+    {
+        transfer_unit_num = byte_size;
+    }
+    else if (src_width == DMAC_CH_SRC_WIDTH_16_BITS)  // 16-bit
+    {
+        if (byte_size % 2)
+        {
+            transfer_unit_num = (byte_size >> 1) + 1;
+        }
+        else
+        {
+            transfer_unit_num = (byte_size >> 1);
+        }
+    }
+    else if (src_width == DMAC_CH_SRC_WIDTH_32_BITS)  // 32-bit
+    {
+        if (byte_size % 4)
+        {
+            transfer_unit_num = (byte_size >> 2) + 1;
+        }
+        else
+        {
+            transfer_unit_num = (byte_size >> 2);
+        }
+    }
+    else
+    {
+        transfer_unit_num = 0;
+    }
+    
+    return transfer_unit_num;
+}
+EXPORT_SYMBOL(Hal_Dmac_Get_Channel_Transfer_Unit_Number);
+
+
+void Hal_Dmac_Configure_DMA_Handshake(DMAC_HARDWARE_HANDSHAKE_OBJ_T *dmac_obj)
+{
+    u32    channel_control, ch;
+
+    /*
+     * Configure DMA controller for UART's hardware DMA handshake mode
+     */    
+
+	/*
+	 * Stop mplayer will also stop PCM if disable GDMA Controller.
+	 * Changed to disable corresponding channels only.
+	 */
+	//HAL_DMAC_DISABLE();
+	for (ch = 0; ch < DMAC_MAX_CHANNEL_NUM; ch++)
+	{
+		if (dmac_obj->channel_id & DMAC_CH_ID(ch))
+			HAL_DMAC_DISABLE_CHANNEL(ch);
+	}
+	
+//#if (ENDIAN_MODE == BIG_ENDIAN)
+#if 0
+    /*Set Master0 and Master 1 endianness as Big Endian*/
+    HAL_DMAC_SET_MASTER0_BIG_ENDIAN();
+    HAL_DMAC_SET_MASTER1_BIG_ENDIAN();
+#else
+    /*Set Master0 and Master 1 endianness as Little Endian*/
+    HAL_DMAC_SET_MASTER0_LITTLE_ENDIAN();
+    HAL_DMAC_SET_MASTER1_LITTLE_ENDIAN();
+#endif
+
+    //Clear TC interrupt status    
+    HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(0xFF);        // 8 channels
+
+    //Clear Errot/Abort interrupt status    
+    HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(0x00FF00FF);    // 8 channels
+
+    /*
+     * Configure DMA's channel control
+     */   
+    channel_control = ((DMAC_CH_TC_MASK_DISABLE << 31) | \
+                       ((dmac_obj->target_select&0xf) << 25) | \
+                       (DMAC_CH_PRI_LEVEL_3 << 22) | \
+                       (DMAC_CH_PROT3_NON_CACHEABLE << 21) | \
+                       (DMAC_CH_PROT2_NON_BUFFERABLE << 20) | \
+                       (DMAC_CH_PROT1_PRIVILEGED_MODE << 19) | \
+                       ((dmac_obj->src_burst_size&0x7) << 16) | \
+                       ((dmac_obj->src_width&0x7) << 11) | \
+                       ((dmac_obj->dst_width&0x7) << 8) | \
+                       (DMAC_CH_MODE_HW_HANDSHAKE << 7) | \
+                       ((dmac_obj->srcad_ctl&0x3) << 5) | \
+                       ((dmac_obj->dstad_ctl&0x3) << 3) | \
+                       (dmac_obj->src_master << 2) | \
+                       (dmac_obj->dst_master << 1) | \
+                       (DMAC_CH_DISABLE));
+
+#if 0
+    // for testing only
+    if (dmac_obj->llp_addr != 0)
+    {
+        /*
+         * For LLP hardware handshaking with at least one descriptors, disable TC interrupt 
+         * of the first descriptor.
+         */
+        channel_control |= (DMAC_CH_TC_MASK_ENABLE << 31);
+    }
+#endif
+    for (ch = 0; ch < DMAC_MAX_CHANNEL_NUM; ch++)
+    {
+        if (dmac_obj->channel_id & DMAC_CH_ID(ch))
+        {  
+            /*
+             * Configure channel's CSR register
+             */
+            DMAC_CH_CSR_REG(ch) = channel_control & 0xFFFFFFFE; //Disable CH(n) DMA
+                
+            /*
+             * Configure channel's CFG register: disable channel abort interrupt,
+             * enable channel error and terminal count interrupts.
+             */
+            DMAC_CH_CFG_REG(ch) |= (0x07);
+            DMAC_CH_CFG_REG(ch) &= ~((0x3));
+        }                               	
+    }
+
+    for (ch = 0; ch < DMAC_MAX_CHANNEL_NUM; ch++)
+    {
+        if (dmac_obj->channel_id & DMAC_CH_ID(ch))
+        {  
+            //Set Src address register
+            DMAC_CH_SRC_ADDR_REG(ch)= dmac_obj->src_addr;
+
+            //Set Dst address register
+            DMAC_CH_DST_ADDR_REG(ch)= dmac_obj->dst_addr;    
+
+            //Set Transfer Number
+            if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_8_BITS)
+            {
+                DMAC_CH_SIZE_REG(ch) = (dmac_obj->transfer_bytes & 0x0FFF);
+                DEBUG_PRINT("%s: 8-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_16_BITS)
+            {                                  
+                DMAC_CH_SIZE_REG(ch) = ((dmac_obj->transfer_bytes >> 1) + (dmac_obj->transfer_bytes % 2)) & 0x0FFF;
+                DEBUG_PRINT("%s: 16-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_32_BITS)
+            {
+                DMAC_CH_SIZE_REG(ch) = ((dmac_obj->transfer_bytes >> 2) + ((dmac_obj->transfer_bytes % 4) ? 1 : 0)) & 0x0FFF;
+                DEBUG_PRINT("%s: 32-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else
+            {
+            	DEBUG_PRINT("%s: dead\n",__FUNCTION__);
+                while (1);
+            }
+
+            //Enable Channel DMA transfer 
+            HAL_DMAC_ENABLE_CHANNEL(ch);
+             
+            //Set Channel's Sync logic
+            DMAC_SYNC_REG |= (1 << ch);
+
+            /*
+             * Configure channel LLP if LLP is enabled
+             */
+            DMAC_CH_LLP_REG(ch) = (dmac_obj->llp_addr == 0) ? 0 : (dmac_obj->llp_addr & 0xFFFFFFFC);
+        }
+    }
+}
+EXPORT_SYMBOL(Hal_Dmac_Configure_DMA_Handshake);
+
+irqreturn_t str8100_dma_err_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 dma_error_status,dma_ch;
+printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+
+	HAL_DMAC_READ_ERROR_ABORT_INTERRUPT_STATUS(dma_error_status);
+	for (dma_ch = 0; dma_ch < DMAC_MAX_CHANNEL_NUM; dma_ch++)
+	{
+		if (dma_error_status & DMAC_CH_ID(dma_ch))
+		{
+			printk("%s: this_irq=%d, DMA channel error on ch %d\n",__FUNCTION__,this_irq,dma_ch);
+			HAL_DMAC_DISABLE_CHANNEL(dma_ch);
+			HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(DMAC_CH_ID(dma_ch));
+		}
+	}	
+	
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(str8100_dma_err_irq_handler);
+
+static const u32 rate_map[3][4]={	{48000,    0,    0,    0},
+					{44100,22050,11025, 5512},
+					{32000,16000, 8000,    0}};
+    /*
+     * Configure I2S related parameters
+     */
+/*//#define i2s_sdata_width	I2S_DATA_16_BIT
+#define i2s_sdata_width		I2S_DATA_32_BIT
+#define i2s_mode	 	I2S_SLAVE_MODE
+//#define i2s_mode		I2S_MASTER_MODE
+#define i2s_tranfer_timing_ctrl	I2S_I2S_MODE
+//#define i2s_tranfer_timing_ctrl	I2S_RJF_MODE
+//#define i2s_tranfer_timing_ctrl	I2S_LJF_MODE
+#define i2s_sclk_mode		I2S_CLOCK_CONTINUOUS_MODE
+//#define i2s_sclk_mode		I2S_CLOCK_256S_MODE
+*/
+
+//int str8100_i2s_init(sampling_rate,I2S_DATA_32_BIT, I2S_MASTER_MODE, I2S_I2S_MODE, I2S_CLOCK_256S_MODE);
+//int str8100_i2s_init(sampling_rate,I2S_DATA_32_BIT, I2S_SLAVE_MODE, I2S_I2S_MODE, I2S_CLOCK_CONTINUOUS_MODE);
+
+int str8100_i2s_init(int sampling_rate,u32 i2s_sdata_width, u32 i2s_mode,
+			u32 i2s_tranfer_timing_ctrl, u32 i2s_sclk_mode){
+	u32 tmp;
+	u32 i/*clock*/ ,j,i2s_src_clk_div;
+	DEBUG_PRINT("%s: sampling_rate=%d\n",__FUNCTION__,sampling_rate);
+	
+	for(i=0;i<3;i++)
+		for(j=0;j<4;j++)
+			if(rate_map[i][j]==sampling_rate) goto rate_match;
+
+rate_match:
+	if(i==3&&j==4) {
+		printk("%s: unsupported sampling rate (%d)\n",__FUNCTION__,sampling_rate);
+		return -1;
+	}else{
+		DEBUG_PRINT("%s: clock=%d,src_clk_div=%d\n",__FUNCTION__,i,j);
+	}
+	
+	i2s_src_clk_div=j;
+
+	/*
+	 * Select I2S clock source; here we use 48K sampling rate for the target file.
+	 */
+	 
+//	switch(sampling_rate){
+	switch(i/*clock*/){
+	case 0/*48000*/: 
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_12288000HZ(); 
+		break; 
+	case 1/*44100*/:
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_11289600HZ(); 
+		break;
+	case 2/*32000*/: 
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_8192000HZ(); 
+		break; 
+	}
+
+	HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(11,0);
+	
+	// Enable I2S pins
+	HAL_MISC_ENABLE_I2S_PINS();
+	
+	// Enable I2S clock
+	HAL_PWRMGT_ENABLE_I2S_CLOCK(); 
+
+	//Hal_Pwrmgt_Software_Reset(PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);
+
+
+    /*
+     * Configure I2S to be Master & Transmitter
+     * Note the I2S's WS Clock is derived from Clock & Power Management Functional
+     * Block!!
+     */
+	I2S_CONFIGURATION_REG = 
+                        (i2s_sdata_width << 0) |
+                        (i2s_src_clk_div << 4) |
+                        (0x1 << 12) |   /* Use I2SSD as data output pin and GPIOA[3] as data input pin for full-duplex mode */
+                        (0x0 << 15) |   /* Disable clock phase invert */
+                        (0x0 << 24) |   /* Disable I2S data swap */
+                        ((i2s_sclk_mode & 0x1) << 25) |
+                        ((i2s_tranfer_timing_ctrl & 0x3) << 26) |
+                        (0x0 << 29) |   /* Enable I2S Transmitter */
+			(i2s_mode << 30) |
+			(0x0 << 31);	/* Disable I2S */
+
+	//Enable none while initializing
+	I2S_INTERRUPT_ENABLE_REG = 0x0;
+//	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG | I2S_TXBF_R_EMPTY_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+
+    // Clear spurious interrupt sources
+    I2S_INTERRUPT_STATUS_REG = 0xF0;
+
+    tmp = I2S_LEFT_RECEIVE_DATA_REG;
+    tmp = I2S_RIGHT_RECEIVE_DATA_REG;
+
+    // Disable I2S
+    HAL_I2S_DISABLE_I2S();
+
+	return 0;
+}
+EXPORT_SYMBOL(str8100_i2s_init);
+
+
+
+/*
+ * Define which GPIO Pins will serve as Winbond's W571C161's SSP (Serial Setup
+ * Potr) Pins which consist of SSPEN, SSPCLK, and SSPTR.
+ * Note these three pins are uni-directional output pins:
+ * SSPEN  : mapping to COM1 pin
+ * SSPCLK : mapping to COM2 pin
+ * SSPTR  : mapping to COM3 pin
+ */
+//#define SSPEN_GPIO_INDEX        (3)   /* use GPIOA #3 as WM8772's COM1 */
+#define SSPEN_GPIO_INDEX        (0)   /* use GPIOA #3 as WM8772's COM1 */
+
+#define SSPCLK_GPIO_INDEX       (1)   /* use GPIOA #4 as WM8772's COM2 */
+
+#define SSPTR_GPIO_INDEX        (2)   /* use GPIOA #5 as WM8772's COM3 */
+
+#define SWITCH_GPIO_INDEX       (7)   /* use GPIOA #6 as WM8772's Transfer or Receiver */
+
+/*
+ * Macro-defines to "output" SSPEN, SSPCLK and SSPTR
+ */
+#define SSPEN_HIGH()            HAL_GPIOA_SET_DATA_OUT_HIGH(0x1 << SSPEN_GPIO_INDEX)
+
+#define SSPEN_LOW()             HAL_GPIOA_SET_DATA_OUT_LOW(0x1 << SSPEN_GPIO_INDEX)
+
+
+#define SSPCLK_HIGH()           HAL_GPIOA_SET_DATA_OUT_HIGH(0x1 << SSPCLK_GPIO_INDEX)
+
+#define SSPCLK_LOW()            HAL_GPIOA_SET_DATA_OUT_LOW(0x1 << SSPCLK_GPIO_INDEX)
+
+
+#define SSPTR_HIGH()            HAL_GPIOA_SET_DATA_OUT_HIGH(0x1 << SSPTR_GPIO_INDEX)
+
+#define SSPTR_LOW()             HAL_GPIOA_SET_DATA_OUT_LOW(0x1 << SSPTR_GPIO_INDEX)
+
+
+/*
+ * SWITCH TX/RX For ASIC VER.
+ */
+#define SSPSW_HIGH()            HAL_GPIOA_SET_DATA_OUT_HIGH(0x1 << SWITCH_GPIO_INDEX)
+
+#define SSPSW_LOW()             HAL_GPIOA_SET_DATA_OUT_LOW(0x1 << SWITCH_GPIO_INDEX)
+
+/*
+ * Macro-defines to configure the "directions" of SSPEN, SSPCLK and SSPTR
+ */
+#define SSPEN_DIR_OUT()         HAL_GPIOA_SET_DIRECTION_OUTPUT(0x1 << SSPEN_GPIO_INDEX)
+
+#define SSPCLK_DIR_OUT()        HAL_GPIOA_SET_DIRECTION_OUTPUT(0x1 << SSPCLK_GPIO_INDEX)
+
+#define SSPTR_DIR_OUT()         HAL_GPIOA_SET_DIRECTION_OUTPUT(0x1 << SSPTR_GPIO_INDEX)
+
+//For ASIC
+#define SSPSW_DIR_OUT()         HAL_GPIOA_SET_DIRECTION_OUTPUT(0x1 << SWITCH_GPIO_INDEX)
+
+
+#define TIME_FACTOR               (20)
+
+/*
+ * Function prototype declaration
+ */
+u32            I2s_Gpio_SSP_Initialise(void);
+
+void           I2s_Gpio_SSP_Write(u16);
+
+void           I2s_Gpio_SSP_Switch_To_Record_Data(void);
+
+void           I2s_Gpio_SSP_Switcg_To_Playback_Data(void);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2s_Gpio_SSP_Initialise
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+u32 I2s_Gpio_SSP_Initialise(void)
+{
+ 
+    // Enable GPIO clock
+    HAL_PWRMGT_ENABLE_GPIO_CLOCK();
+
+    // Perform GPIO software reset
+//    Hal_Pwrmgt_Software_Reset(PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);
+
+
+    /*
+     * 1. Determine/Check which three GPIO pins will serve as SSPEN, SSPCLK and 
+     *    SSPTR pins
+     * 2. At initialization :
+     *    SSPEN  : Output Direction, High state
+     *    SSPCLK : Output Direction, Low state
+     *    SSPTR  : Output Direction, Low state
+     */
+    SSPEN_DIR_OUT();
+    
+    SSPCLK_DIR_OUT();
+    
+    SSPTR_DIR_OUT();
+
+
+    /*
+     * Set SSPEN to be HIGH and SSPCLK/SSPTR be be LOW to "Free" SSP Bus
+     */
+     
+    SSPEN_HIGH();
+
+#if 1
+    SSPCLK_LOW();
+
+    SSPTR_LOW();
+#else
+    SSPCLK_HIGH();
+
+    SSPTR_HIGH();
+#endif
+
+    return 0;  // for success indication
+}
+EXPORT_SYMBOL(I2s_Gpio_SSP_Initialise);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2s_Gpio_SSP_Write
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+void I2s_Gpio_SSP_Write(u16 reg_data)
+{
+    unsigned long   cpsr_flags;
+    u32 volatile    ii;
+
+
+	local_irq_save(cpsr_flags);
+    
+    SSPEN_HIGH();
+
+    SSPCLK_LOW();
+
+    SSPTR_LOW();
+
+    ndelay(2 * TIME_FACTOR);
+
+    SSPEN_LOW();
+
+    // Output D15 ~ D0 of reg_data
+    for (ii = 0; ii < 16; ii++)
+    {
+        SSPCLK_LOW();
+    
+        ndelay(3 * TIME_FACTOR);//setup time
+        
+        if (reg_data & 0x8000)
+        {
+            SSPTR_HIGH();
+        }
+        else
+        {
+            SSPTR_LOW();
+        }
+        
+        ndelay(5 * TIME_FACTOR);
+        
+        SSPCLK_HIGH();
+        
+        ndelay(5 * TIME_FACTOR);//hold time
+
+        SSPCLK_LOW();
+        
+        ndelay(3 * TIME_FACTOR);
+
+        // Shift left by one bit to get the next data bit
+        reg_data <<= 1;
+    }
+    
+    SSPEN_HIGH();
+
+    SSPCLK_LOW();
+
+    ndelay(1 * TIME_FACTOR);
+
+    // for testing only
+#if 0
+    SSPCLK_HIGH();
+
+//    SSPTR_HIGH();
+#endif
+
+
+    // Delay some time
+//    for (ii = 0; ii < 0x100000; ii++);    
+
+	local_irq_restore(cpsr_flags);
+}
+EXPORT_SYMBOL(I2s_Gpio_SSP_Write);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2s_Gpio_SSP_Switch_To_Record_Data
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+void I2s_Gpio_SSP_Switch_To_Record_Data(void)
+{
+    SSPSW_DIR_OUT();
+    
+    SSPSW_HIGH();
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2s_Gpio_SSP_Switcg_To_Playback_Data
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+void I2s_Gpio_SSP_Switcg_To_Playback_Data(void)
+{
+    SSPSW_DIR_OUT();
+    
+    SSPSW_LOW();
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_i2s_config.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_i2s_config.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_i2s_config.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_i2s_config.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,471 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include <mach/star_powermgt.h>
+#include <mach/star_misc.h>
+#include <mach/star_i2s.h>
+#include <mach/star_demo_dma.h>
+
+MODULE_AUTHOR("Mac Lin");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+#define CONFIG_I2S_USE_DMA
+//Debug = left only
+#define DEBUG	
+
+static struct proc_dir_entry *star_i2s_proc_entry=NULL;
+static u32 sampling_rate=44100;
+static u32 sample_size=16;
+
+module_param(sampling_rate, int, 0);
+MODULE_PARM_DESC(gpio, "sampling_rate");
+
+module_param(sample_size, int, 0);
+MODULE_PARM_DESC(gpio, "sample_size");
+
+#define DMA_TRANSFER_MAX_BYTE    (0xfff<<(sample_size>>4)) 
+#define BUFSIZE (0xfff<<4) //twice the 32-bit DMA transfer byte size
+
+static u8* lbuffer;
+static u8* lbuffer_p;
+static u32 llen=0;
+static u32 lpos=0;
+static u32 i2s_err_lur=0;
+
+static u32 debug=0;
+#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+
+//=================================================================================
+//
+#ifdef CONFIG_I2S_USE_DMA
+
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8759_dma_handshake_left_tx;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8759_dma_handshake_right_tx;
+
+static u32                          i2s_wm8759_dma_right_tx_channel = 1;
+
+
+
+
+
+void I2s_WM8759_Configure_DMA_Hardware_Handshake(void)
+{
+    /*
+     * Configure DMA's channel setting for I2S's Left Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    i2s_wm8759_dma_handshake_left_tx.channel_num = 0;
+    i2s_wm8759_dma_handshake_left_tx.channel_id = DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num);
+    i2s_wm8759_dma_handshake_left_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_LEFT_ID;
+    i2s_wm8759_dma_handshake_left_tx.src_addr = (u32)lbuffer_p;
+    i2s_wm8759_dma_handshake_left_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    i2s_wm8759_dma_handshake_left_tx.dst_master = DMAC_CH_DST_SEL_M0;
+    i2s_wm8759_dma_handshake_left_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    i2s_wm8759_dma_handshake_left_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+    
+	switch(sample_size){
+	case 16:
+		i2s_wm8759_dma_handshake_left_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xCA);
+		i2s_wm8759_dma_handshake_left_tx.src_width = DMAC_CH_SRC_WIDTH_16_BITS;
+		i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_16_BITS;
+		break;
+	case 32:
+		i2s_wm8759_dma_handshake_left_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xC8);
+		i2s_wm8759_dma_handshake_left_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+		i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+		break;
+	}
+
+//    i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_16_BITS;
+
+    /*
+     * Note here the total number of bytes for each DMA transfer is specified!!
+     */
+//    i2s_wm8759_dma_handshake_left_tx.transfer_bytes = DMA_TRANSFER_MAX_BYTE;
+    i2s_wm8759_dma_handshake_left_tx.transfer_bytes = (llen<DMA_TRANSFER_MAX_BYTE)?llen:DMA_TRANSFER_MAX_BYTE;
+
+    i2s_wm8759_dma_handshake_left_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8759_dma_handshake_left_tx);
+
+#ifndef DEBUG 
+    /*
+     * Configure DMA's channel setting for I2S's Right Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    i2s_wm8759_dma_handshake_right_tx.channel_id = DMAC_CH_ID(i2s_wm8759_dma_right_tx_channel);
+    
+    i2s_wm8759_dma_handshake_right_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_RIGHT_ID;
+
+    i2s_wm8759_dma_handshake_right_tx.src_addr = (u32)rbuffer_p;
+
+    i2s_wm8759_dma_handshake_right_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xC4);
+
+    i2s_wm8759_dma_handshake_right_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    
+    i2s_wm8759_dma_handshake_right_tx.dst_master = DMAC_CH_DST_SEL_M0;
+
+    i2s_wm8759_dma_handshake_right_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    
+    i2s_wm8759_dma_handshake_right_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+
+    i2s_wm8759_dma_handshake_right_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    
+    i2s_wm8759_dma_handshake_right_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    /*
+     * Note here the total number of bytes for each DMA transfer is specified!!
+     */
+    i2s_wm8759_dma_handshake_right_tx.transfer_bytes = DMA_TRANSFER_MAX_BYTE;
+
+    i2s_wm8759_dma_handshake_right_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8759_dma_handshake_right_tx);
+#endif
+    return;
+}
+#endif //CONFIG_I2S_USE_DMA
+
+
+//=================================================================================
+//
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+#ifdef CONFIG_I2S_USE_DMA
+static irqreturn_t str8100_dma_tc_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 dma_tc_status,tot_size;
+	u32 len;
+//printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+
+    HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(dma_tc_status);
+
+    /*
+     * For DMA's Tx for I2S Left Channel
+     */
+	if (dma_tc_status & DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num))
+	{                      
+		HAL_DMAC_DISABLE_CHANNEL(i2s_wm8759_dma_handshake_left_tx.channel_num);
+		HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num));
+		lpos+=i2s_wm8759_dma_handshake_left_tx.transfer_bytes;
+		if(lpos<llen){
+			/*
+			 * Re-initialize DMA's channel for Left_Tx
+			 */
+			DMAC_CH_SRC_ADDR_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = (u32)lbuffer_p+lpos;
+			DMAC_CH_DST_ADDR_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = (SYSPA_I2S_BASE_ADDR + 0xC8);        
+			
+			/*
+			 * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+			 * number of source transfer width!
+			 */        
+			len=(llen - lpos);
+			i2s_wm8759_dma_handshake_left_tx.transfer_bytes= (len<DMA_TRANSFER_MAX_BYTE)?len:DMA_TRANSFER_MAX_BYTE;
+
+			if (i2s_wm8759_dma_handshake_left_tx.src_width == DMAC_CH_SRC_WIDTH_16_BITS)
+			{
+			    tot_size = (i2s_wm8759_dma_handshake_left_tx.transfer_bytes >> 1) + ((i2s_wm8759_dma_handshake_left_tx.transfer_bytes % 2) ? 1 : 0);
+			}
+			else if (i2s_wm8759_dma_handshake_left_tx.src_width == DMAC_CH_SRC_WIDTH_32_BITS)
+			{
+			    tot_size = (i2s_wm8759_dma_handshake_left_tx.transfer_bytes >> 2) + ((i2s_wm8759_dma_handshake_left_tx.transfer_bytes % 4) ? 1 : 0);
+			}
+			else
+			{
+			    tot_size = i2s_wm8759_dma_handshake_left_tx.transfer_bytes;
+			}
+			
+			DMAC_CH_SIZE_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = tot_size & 0x0FFF;
+			HAL_DMAC_ENABLE_CHANNEL(i2s_wm8759_dma_handshake_left_tx.channel_num);
+//printk("%s: 32-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,i2s_wm8759_dma_handshake_left_tx.transfer_bytes,i2s_wm8759_dma_handshake_left_tx.channel_num,DMAC_CH_SIZE_REG(i2s_wm8759_dma_handshake_left_tx.channel_num));
+
+	}else{
+		llen=lpos=0;
+	}
+	}
+
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+#endif //CONFIG_I2S_USE_DMA
+
+static irqreturn_t str8100_i2s_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 interrupt_status;
+	DEBUG_PRINT("%s: this_irq=%d, I2S_INTERRUPT_STATUS_REG=0x%.8x,llen=%d,lpos=%d\n",__FUNCTION__,this_irq,I2S_INTERRUPT_STATUS_REG,llen,lpos);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+	interrupt_status = I2S_INTERRUPT_STATUS_REG;   
+if((llen<lpos)||llen==0)     HAL_I2S_DISABLE_I2S();
+
+#ifndef CONFIG_I2S_USE_DMA
+		I2S_RIGHT_TRANSMIT_DATA_REG=0;
+
+	if ((lpos<=llen) && (interrupt_status & I2S_TXBF_L_EMPTY_FLAG)){
+		switch(sample_size){
+			case 16:
+				I2S_LEFT_TRANSMIT_DATA_REG=(*((u16*)(&lbuffer[lpos])))<<16;lpos+=2;
+				break;
+			case 32:
+				I2S_LEFT_TRANSMIT_DATA_REG=*((u32*)(&lbuffer[lpos]));lpos+=4;
+				break;
+		}
+		
+		if(lpos>llen){
+			// Disable Left Channel's Transmit Buffer Interrupt Sources
+			I2S_INTERRUPT_ENABLE_REG &= ~(I2S_TXBF_L_EMPTY_FLAG | I2S_TXBF_L_UR_FLAG);
+			lpos=llen=0;
+		}
+	}
+#endif //!CONFIG_I2S_USE_DMA
+
+
+	if (llen>=lpos && (interrupt_status & I2S_TXBF_L_UR_FLAG)){
+		// Clear I2S interrupt status
+		i2s_err_lur++;
+		if(i2s_err_lur>10)
+			I2S_INTERRUPT_ENABLE_REG &= ~(I2S_TXBF_L_UR_FLAG);
+//			HAL_I2S_DISABLE_I2S();
+		
+		printk("%s: Left Channel Tx Underrun!,llen=%d, lpos=%d, interrupt_status=%.8x,i2s_err_lur=%d\n",__FUNCTION__,llen,lpos,interrupt_status,i2s_err_lur);
+	}
+	I2S_INTERRUPT_STATUS_REG &= 0xf0;
+
+	
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+
+
+//=================================================================================
+static int proc_read_i2s(char *buf, char **start, off_t offset,
+                   int count, int *eof, void *data)
+{
+	int len=0;
+	DEBUG_PRINT("%s:\n",__FUNCTION__);
+	len += sprintf(buf,	"sampling_rate=%d\n"
+				"sample_size=%d\n"
+			,sampling_rate,sample_size); 
+	*eof = 1;
+	return len;
+}
+
+static proc_write_i2s(struct file *file, const char *buffer, unsigned long count, void *data){
+	int len=0;
+	DEBUG_PRINT("%s: sample size %d, sampling rate %d, count=%d\n",__FUNCTION__,sample_size,sampling_rate,count);
+	
+	//is buffer free?
+	if(lpos!=llen){
+		printk("%s: buffer not free\n");
+		return -EBUSY;
+	}
+	if(sampling_rate!=32000&&sampling_rate!=44100&&sampling_rate!=48000){
+		printk("%s: invalid sampling rate(%d)\n",sampling_rate);
+		return -EFAULT;
+	}
+	if(sample_size!=16&&sample_size!=32){
+		printk("%s: invalid sample size(%d)\n",sample_size);
+		return -EFAULT;
+	}
+
+	//copy the raw data to local buffer	
+	if(count>BUFSIZE) len=BUFSIZE;
+	else len=count;
+	
+	if(copy_from_user(lbuffer,buffer,len)){
+		return -EFAULT;	
+	}
+	llen=len;
+	lpos=0;
+	i2s_err_lur=0;
+	
+	str8100_i2s_init(sampling_rate,I2S_DATA_32_BIT, I2S_MASTER_MODE, I2S_I2S_MODE, I2S_CLOCK_256S_MODE);
+
+#ifdef CONFIG_I2S_USE_DMA
+    /*
+     * Configure DMA for hardware handshake for I2S
+     * Note the DMA is NOT enabled after invoking the following function, but the specified
+     * DMA channels are enabled!!
+     */
+    i2s_wm8759_dma_right_tx_channel = 1;   
+
+    I2s_WM8759_Configure_DMA_Hardware_Handshake();  
+
+#endif //CONFIG_I2S_USE_DMA
+	//fill the tx left/right registers
+
+		switch(sample_size){
+			case 16:
+				I2S_LEFT_TRANSMIT_DATA_REG=(*((u16*)(&lbuffer[lpos])))<<16;lpos+=2;
+				break;
+			case 32:
+				I2S_LEFT_TRANSMIT_DATA_REG=*((u32*)(&lbuffer[lpos]));lpos+=4;
+				break;
+		}
+
+	I2S_RIGHT_TRANSMIT_DATA_REG=0;
+
+#ifdef CONFIG_I2S_USE_DMA
+	/*
+	 * Enable I2S's interrupt sources
+	 * Note for DMA hardware handshake, we only need to enable Left/Right Channel's 
+	 * Transmit Buffer Underrun.
+	 */
+#ifdef DEBUG	
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_L_UR_FLAG);
+#else
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG);
+#endif
+#else //CONFIG_I2S_USE_DMA
+#ifdef DEBUG	
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_L_UR_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+#else
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG | I2S_TXBF_R_EMPTY_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+#endif
+#endif //CONFIG_I2S_USE_DMA
+
+	// Enable CPU interrupt
+	local_irq_enable();
+	
+#ifdef CONFIG_I2S_USE_DMA
+	/*
+	 * Note DMA must be enabled first before I2S is enabled
+	 */
+	HAL_DMAC_ENABLE();
+#endif //CONFIG_I2S_USE_DMA
+	HAL_I2S_ENABLE_I2S();
+
+
+	while (1){
+		local_irq_disable();
+		if (lpos>llen||llen==0){
+			// Disable I2S
+			HAL_I2S_DISABLE_I2S();
+			break;
+		}
+		local_irq_enable();
+	}
+	DEBUG_PRINT("%s: exit. i2s_err_lur=%d\n",__FUNCTION__,i2s_err_lur);
+
+	local_irq_enable();
+
+	return len;
+
+debug:
+	HAL_I2S_DISABLE_I2S();
+	return count;
+}
+
+static void __exit i2s_exit_module(void){
+	printk("%s:\n",__FUNCTION__);
+	remove_proc_entry("str8100/i2s", NULL);
+	free_irq(INTC_I2S_BIT_INDEX, NULL);
+#ifdef CONFIG_I2S_USE_DMA
+	free_irq(INTC_GDMAC_TC_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_ERROR_BIT_INDEX, NULL);
+#endif //CONFIG_I2S_USE_DMA
+	if(lbuffer) {
+		pci_free_consistent(NULL, BUFSIZE, lbuffer, lbuffer_p);
+		lbuffer=lbuffer_p=NULL;
+	}
+}
+
+static int __init i2s_init_module(void)
+{
+	
+	u32 ret;
+	
+	printk("%s:\n",__FUNCTION__);
+#ifdef CONFIG_I2S_USE_DMA
+	printk("%s: DMA Enabled...\n",__FUNCTION__);
+#endif //CONFIG_I2S_USE_DMA
+
+	star_i2s_proc_entry = create_proc_entry("str8100/i2s", S_IFREG | S_IRUGO, NULL);
+	if(!star_i2s_proc_entry){
+		return -EBUSY;
+	}
+	star_i2s_proc_entry->read_proc=proc_read_i2s;
+	star_i2s_proc_entry->write_proc=proc_write_i2s;
+	
+	lbuffer = pci_alloc_consistent(NULL, BUFSIZE, &lbuffer_p);
+	if(!lbuffer){
+		printk("%s: alloc lbuffer failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+
+	str8100_set_interrupt_trigger (INTC_I2S_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);
+	if ((ret=request_irq(INTC_I2S_BIT_INDEX, str8100_i2s_irq_handler, 0, "i2s", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_I2S_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+
+#ifdef CONFIG_I2S_USE_DMA
+	str8100_set_interrupt_trigger (INTC_GDMAC_TC_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_TC_BIT_INDEX, str8100_dma_tc_irq_handler, 0, "dma tc", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_TC_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+	str8100_set_interrupt_trigger (INTC_GDMAC_ERROR_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_ERROR_BIT_INDEX, str8100_dma_err_irq_handler, 0, "dma error", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_ERROR_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+#endif //CONFIG_I2S_USE_DMA
+
+	return 0;
+exit1:
+	i2s_exit_module();
+	return -EBUSY;
+}
+
+module_init(i2s_init_module);
+module_exit(i2s_exit_module);
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_i2s_wm8772_config.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_i2s_wm8772_config.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_i2s_wm8772_config.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_i2s_wm8772_config.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,924 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//Options
+#define DEBUG
+#define I2S_FULL_DUPLEX
+#define I2S_WM8772_DMAC_LLP_TEST
+#define I2S_WM8772_DMAC_LLP_NUM      3
+#define I2S_WM8772_BUFFER_SIZE       (48 * 1 * 2 * 100)
+#define I2S_TIMING 	I2S_I2S_MODE
+//#define I2S_TIMING 	I2S_RJF_MODE
+//#define I2S_TIMING 	I2S_LJF_MODE
+#define DATA_WIDTH 	I2S_DATA_32_BIT
+//#define DATA_WIDTH 	I2S_DATA_16_BIT
+#define I2S_MODE 	I2S_MASTER_MODE
+//#define I2S_MODE 	I2S_SLAVE_MODE
+#define I2S_SCLK_MODE	I2S_CLOCK_256S_MODE
+//#define I2S_SCLK_MODE	I2S_CLOCK_CONTINUOUS_MODE
+//*******************
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include <mach/star_powermgt.h>
+#include <mach/star_misc.h>
+#include <mach/star_i2s.h>
+#include <mach/star_demo_dma.h>
+
+MODULE_AUTHOR("Mac Lin");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+//Debug = left only
+
+static u32 sampling_rate=44100;
+
+module_param(sampling_rate, int, 0);
+MODULE_PARM_DESC(gpio, "sampling_rate");
+
+//#define DMA_TRANSFER_MAX_BYTE    (0xfff<<(sample_size>>4)) 
+//#define BUFSIZE (0xfff<<4) //twice the 32-bit DMA transfer byte size
+
+static u8* buffer=NULL;
+static u8* buffer_p=NULL;
+static DMAC_LLP_T* desc=NULL;
+static DMAC_LLP_T* desc_p=NULL;
+
+static u8* lbuffer=NULL;
+static u8* lbuffer_p=NULL;
+static DMAC_LLP_T* lb_txd=NULL;
+static DMAC_LLP_T* lb_txd_p=NULL;
+static DMAC_LLP_T* lb_rxd=NULL;
+static DMAC_LLP_T* lb_rxd_p=NULL;
+
+static u8* rbuffer=NULL;
+static u8* rbuffer_p=NULL;
+static DMAC_LLP_T* rb_txd=NULL;
+static DMAC_LLP_T* rb_txd_p=NULL;
+static DMAC_LLP_T* rb_rxd=NULL;
+static DMAC_LLP_T* rb_rxd_p=NULL;
+
+static DMAC_LLP_T* i2s_left_tx_channel_dma_llp_desc=NULL;
+static DMAC_LLP_T* i2s_left_rx_channel_dma_llp_desc=NULL;
+static DMAC_LLP_T* i2s_right_tx_channel_dma_llp_desc=NULL;
+static DMAC_LLP_T* i2s_right_rx_channel_dma_llp_desc=NULL;
+
+static u8* i2s_left_channel_llp_buf[I2S_WM8772_DMAC_LLP_NUM];
+static u8* i2s_right_channel_llp_buf[I2S_WM8772_DMAC_LLP_NUM];
+
+
+static u32 i2s_err_lur=0;
+
+static u32 debug=0;
+#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+
+static u32 i2s_wm8772_dma_left_tx_channel 	= 0;
+static u32 i2s_wm8772_dma_right_tx_channel 	= 1;
+static u32 i2s_wm8772_dma_left_rx_channel 	= 2;
+static u32 i2s_wm8772_dma_right_rx_channel 	= 3;
+
+
+#if (I2S_WM8772_DMAC_LLP_NUM >= 3)
+#define I2S_WM8772_DMAC_LLP_RING_TEST
+#endif
+#define BUFSIZE (I2S_WM8772_DMAC_LLP_NUM*I2S_WM8772_BUFFER_SIZE*4)
+
+#define I2S_BASE_ADDR SYSPA_I2S_BASE_ADDR
+#define i2s_dmac_llp_num I2S_WM8772_DMAC_LLP_NUM
+//=================================================================================
+//
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2s_Configure_WM8772
+ * PURPOSE:
+ *
+ ******************************************************************************/
+void I2s_Configure_WM8772(u32 interface_format, u32 word_length, u32 data_interface_mode)
+{
+    u16    reg_data;
+
+
+    /*
+     * The current configuration of W571C161 DAC are:
+     * 1. MODE : External hardware setting control mode
+     * 2. COM1 = 1, COM2 = 0 : 16-bit I2S
+     * 3. COM3 = 0 : De-emphasis filter off
+     * 4. I2S Level 2 (Slave Mode) : How to configure it
+     */
+
+    /*
+     * Configure register R31 for reset
+     */
+#if 1
+    reg_data = (0x1F << 9) |  /* Register address value : 0x1F */
+               (0x1FF);
+#else
+    reg_data = (0xF << 9) |  /* Register address value : 0xF */
+               (0x1FF);
+#endif
+
+    I2s_Gpio_SSP_Write(reg_data);
+    
+    /*
+     * Configure register R2
+     */ 
+    reg_data = (0x2 << 9) |  /* Register address value : 0x2 */
+#if 1
+//               (0x5 << 5) |  /* Right Channel Output Mixer Status : right channel data */
+               (0x9 << 5) |  /* Right Channel Output Mixer Status : right channel data */
+                             /* Left Channel Output Mixer Status : left channel data */
+#else
+               (0x2 << 7) |  /* Right Channel Output Mixer Status : right channel data */
+               (0x1 << 5) |  /* Left Channel Output Mixer Status : left channel data */
+#endif
+               (0x0 << 4) |  /* IZM : disable */
+               (0x0 << 3) |  /* ATC : right channels use right attenuations */
+               (0x0 << 2) |  /* PDWNALL : disable */
+               (0x0 << 1) |  /* DEEMPALL : normal */
+               (0x0 << 0);   /* Soft Mute Select : normal */
+
+    I2s_Gpio_SSP_Write(reg_data);
+ 
+    /*
+     * Configure register R12
+     */
+    reg_data = (0xC << 9) |  /* Register address value : 0xC */
+               (0x1 << 6) |  /* Disable the MUTE decoded circuit used by DZFM */
+//               (0x0 << 6) |  /* Enable the MUTE decoded circuit used by DZFM */
+               (0x0 << 2) |  /* Normal operation */
+               (0x0 << 1) |  /* Normal operation */
+               (0x0 << 0);   /* Normal operation */
+
+    I2s_Gpio_SSP_Write(reg_data);
+
+    
+    /*
+     * Configure register R9
+     */
+    reg_data = (0x9 << 9) |  /* Register address value : 0x9 */
+               (0x0 << 8) |  /* Channel 3L/R De-emphasis Status : No de-emphasis */
+               (0x0 << 7) |  /* Channel 2L/R De-emphasis Status : No de-emphasis */
+               (0x0 << 6) |  /* Channel 1L/R De-emphasis Status : No de-emphasis */
+               (0x1 << 5) |  /* Channel 3L/R Play Status : Mute */
+               (0x1 << 4) |  /* Channel 2L/R Play Status : Mute */
+               (0x0 << 3) |  /* Channel 1L/R Play Status : play */
+               (0x3 << 1) |  /* DZFM[1:0] : Channel 3 */
+               (0x1 << 0);   /* ZCD : disabled */
+
+    I2s_Gpio_SSP_Write(reg_data);
+
+
+    /*
+     * Configure register R3 for audio data interface format
+     */
+    reg_data = (0x3 << 9) |  /* Register address value : 0x3 */
+               (0x0 << 6) |  /* Phase : normal */
+               (0x0 << 4) |  /* Input Word Length : 16-bit(0x0 << 4) ; 32-bit(0x3 <<4) */
+#if 0
+               (0x1 << 3) |  /* BCK Polarity : invert : for DSP mode only ????? */
+#else
+               (0x0 << 3) |  /* BCK Polarity : normal */
+#endif
+
+#if 0
+               (0x1 << 2) |  /* LRC Polarity : invert */
+#else
+               (0x0 << 2) |  /* LRC Polarity : normal */
+#endif          
+               (0x0 << 0);   /* Interface Format : right justified mode */
+
+    if (interface_format == I2S_RJF_MODE)
+    {
+        reg_data |= 0;
+    }
+    else if (interface_format == I2S_LJF_MODE)
+    {
+        reg_data |= 1;
+    }
+    else if (interface_format == I2S_I2S_MODE)
+    {
+        reg_data |= 2;
+    }
+    else
+    {
+        printk("\nI2S: Incorrect selected interface mode: DSP mode!\n");
+        
+        reg_data |= 3;
+    }
+
+    /*
+     *  16-bit data for I2S_RJF_MODE
+     */ 
+    if (interface_format == I2S_RJF_MODE)
+    {
+        // 16-bit data
+        reg_data |= (0 << 4);
+    }
+    else
+    {
+        if (word_length == I2S_DATA_16_BIT)
+        {
+            reg_data |= (0 << 4);
+        }
+        else if (word_length == I2S_DATA_32_BIT)
+        {
+            reg_data |= (3 << 4);
+        }
+    }
+
+    I2s_Gpio_SSP_Write(reg_data);
+
+    
+    /*
+     * Configure register R10
+     */
+    reg_data = (0xA << 9) |  /* Register address value : 0xA */
+               (0x2 << 6) |  /* Frequency Ratio = MCLK/LRC : 256 */
+               //(0x3 << 6) |  /* Frequency Ratio = MCLK/LRC : 384 */
+               //(0x0 << 6) |  /* Frequency Ratio = MCLK/LRC : 128 */
+               (0x0 << 5) |  /* Data Interface Mode : Level 2 (Slave mode) */
+               (0x0 << 4) |  /* All Channel Power Down : play */
+               (0x1 << 3) |  /* Channel 3 L/R Play Status : power down */
+               (0x1 << 2) |  /* Channel 2 L/R Play Status : power down */
+               (0x0 << 1) |  /* Channel 1 L/R Play Status : play */
+#if 0
+               (0x1 << 0);   /* ADC deactive */
+#else
+               (0x0 << 0);   /* ADC active */
+#endif
+
+    if (data_interface_mode == I2S_SLAVE_MODE)
+    {
+        /*
+         * Equuleus's I2S is in Slave mode, so WM8772 will be in Master mode
+         */
+        reg_data |= (0x1 << 5);
+    }
+
+    I2s_Gpio_SSP_Write(reg_data);
+
+
+    /*
+     * Configure register R11?????
+     */
+    reg_data = (0xB << 9) |  /* Register address value : 0xB */
+               (0x0 << 8);   /* 128x oversampling */
+               
+    I2s_Gpio_SSP_Write(reg_data);
+
+
+    /*
+     * Configure register R12
+     */
+    reg_data = (0xC << 9) |  /* Register address value : 0xC */
+               (0x0 << 3);   /* Highpass filter enabled */
+               
+    I2s_Gpio_SSP_Write(reg_data);
+    
+    return;
+}
+
+//=================================================================================
+//
+
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8772_dma_right_tx;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8772_dma_right_rx;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8772_dma_left_tx;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8772_dma_left_rx;
+
+void I2s_Configure_WM8772_DMA_Hardware_Handshake(void)
+{
+	u32 ii,tot_size;
+    /*
+     * Initialize DMAC's LLP descriptors
+     */
+	i2s_left_tx_channel_dma_llp_desc=lb_txd;
+	i2s_left_rx_channel_dma_llp_desc=lb_rxd;
+	i2s_right_tx_channel_dma_llp_desc=rb_txd;
+	i2s_right_rx_channel_dma_llp_desc=rb_rxd;
+	
+    for (ii = 0; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+    {
+        memset ((void *)&i2s_left_tx_channel_dma_llp_desc[ii], 0x0, sizeof (i2s_left_tx_channel_dma_llp_desc[ii]));
+        memset ((void *)&i2s_left_rx_channel_dma_llp_desc[ii], 0x0, sizeof (i2s_left_rx_channel_dma_llp_desc[ii]));
+        
+        memset ((void *)&i2s_right_tx_channel_dma_llp_desc[ii], 0x0, sizeof (i2s_right_tx_channel_dma_llp_desc[ii]));
+        memset ((void *)&i2s_right_rx_channel_dma_llp_desc[ii], 0x0, sizeof (i2s_right_rx_channel_dma_llp_desc[ii]));
+    }
+
+//1. *****************************************************************************
+    /*
+     * Configure DMA's channel setting for I2S's Left Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    for (ii = 0; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+    {
+        i2s_left_tx_channel_dma_llp_desc[ii].SrcAddr = i2s_left_channel_llp_buf[ii];
+        
+        i2s_left_tx_channel_dma_llp_desc[ii].DstAddr = (I2S_BASE_ADDR + 0xC8);
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_left_tx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&lb_txd_p[ii+1] : (DMAC_LLP_T *)&lb_txd_p[1];
+#else
+        i2s_left_tx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&lb_txd_p[ii+1] : (DMAC_LLP_T *)(0);
+#endif
+
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+        
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tot_size = tot_size;  /* TOT_SIZE */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_sel = DMAC_CH_DST_SEL_M0;  /* DST_SEL */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_sel = DMAC_CH_SRC_SEL_M1;  /* SRC_SEL */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;  /* DSTAD_CTL */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;  /* SRCAD_CTL */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_width = DMAC_CH_DST_WIDTH_32_BITS;  /* DST_WIDTH */
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_width = DMAC_CH_SRC_WIDTH_32_BITS;  /* SRC_WIDTH */       
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = (DMAC_CH_TC_MASK_ENABLE);  /* TC_MASK */
+#else
+        i2s_left_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = ((ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_CH_TC_MASK_ENABLE) : (DMAC_CH_TC_MASK_DISABLE));  /* TC_MASK */
+#endif
+    }
+
+    i2s_wm8772_dma_left_tx.channel_id = DMAC_CH_ID(i2s_wm8772_dma_left_tx_channel);
+    i2s_wm8772_dma_left_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_LEFT_ID;
+
+    i2s_wm8772_dma_left_tx.src_addr = i2s_left_tx_channel_dma_llp_desc[0].SrcAddr;
+    i2s_wm8772_dma_left_tx.dst_addr = i2s_left_tx_channel_dma_llp_desc[0].DstAddr;
+
+    i2s_wm8772_dma_left_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    i2s_wm8772_dma_left_tx.dst_master = DMAC_CH_DST_SEL_M0;
+
+    i2s_wm8772_dma_left_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    i2s_wm8772_dma_left_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+
+    i2s_wm8772_dma_left_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    i2s_wm8772_dma_left_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+
+    // Note here the total number of bytes is specified!!
+    i2s_wm8772_dma_left_tx.transfer_bytes = I2S_WM8772_BUFFER_SIZE * 4;
+
+    i2s_wm8772_dma_left_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    i2s_wm8772_dma_left_tx.llp_addr = (i2s_dmac_llp_num == 1) ? 0 : (u32)i2s_left_tx_channel_dma_llp_desc[0].LLP;
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8772_dma_left_tx);
+//2. *****************************************************************************
+    /*
+     * Configure DMA's channel setting for I2S's Right Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    for (ii = 0; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+    {
+        i2s_right_tx_channel_dma_llp_desc[ii].SrcAddr = i2s_right_channel_llp_buf[ii];
+        
+        i2s_right_tx_channel_dma_llp_desc[ii].DstAddr = (I2S_BASE_ADDR + 0xC4);
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_right_tx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&rb_txd_p[ii+1] : (DMAC_LLP_T *)&rb_txd_p[1];
+#else
+        i2s_right_tx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&rb_txd_p[ii + 1] : (DMAC_LLP_T *)(0);
+#endif
+
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tot_size = tot_size;  /* TOT_SIZE */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_sel = DMAC_CH_DST_SEL_M0;  /* DST_SEL */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_sel = DMAC_CH_SRC_SEL_M1;  /* SRC_SEL */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;  /* DSTAD_CTL */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;  /* SRCAD_CTL */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_width = DMAC_CH_DST_WIDTH_32_BITS;  /* DST_WIDTH */
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_width = DMAC_CH_SRC_WIDTH_32_BITS;  /* SRC_WIDTH */
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = (DMAC_CH_TC_MASK_ENABLE);  /* TC_MASK */
+#else
+        i2s_right_tx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = ((ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_CH_TC_MASK_ENABLE) : (DMAC_CH_TC_MASK_DISABLE));  /* TC_MASK */
+#endif
+    }
+
+
+    i2s_wm8772_dma_right_tx.channel_id = DMAC_CH_ID(i2s_wm8772_dma_right_tx_channel);
+    i2s_wm8772_dma_right_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_RIGHT_ID;
+
+    i2s_wm8772_dma_right_tx.src_addr = i2s_right_tx_channel_dma_llp_desc[0].SrcAddr;
+    i2s_wm8772_dma_right_tx.dst_addr = i2s_right_tx_channel_dma_llp_desc[0].DstAddr;
+
+    i2s_wm8772_dma_right_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    i2s_wm8772_dma_right_tx.dst_master = DMAC_CH_DST_SEL_M0;
+
+    i2s_wm8772_dma_right_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    i2s_wm8772_dma_right_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+
+    i2s_wm8772_dma_right_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    i2s_wm8772_dma_right_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    i2s_wm8772_dma_right_tx.transfer_bytes = I2S_WM8772_BUFFER_SIZE * 4;
+
+    i2s_wm8772_dma_right_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;
+
+    i2s_wm8772_dma_right_tx.llp_addr = (i2s_dmac_llp_num == 1) ? 0 : (u32)i2s_right_tx_channel_dma_llp_desc[0].LLP;
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8772_dma_right_tx);
+
+
+//3. *****************************************************************************
+    /*
+     * Configure DMA's channel setting for I2S's Left Channel Rx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    for (ii = 0; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+    {
+        i2s_left_rx_channel_dma_llp_desc[ii].SrcAddr = (I2S_BASE_ADDR + 0xD0);
+        
+        i2s_left_rx_channel_dma_llp_desc[ii].DstAddr = i2s_left_channel_llp_buf[ii];
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_left_rx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&lb_rxd_p[ii + 1] : (DMAC_LLP_T *)&lb_rxd_p[1];
+#else
+        i2s_left_rx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&lb_rxd_p[ii + 1] : (DMAC_LLP_T *)(0);
+#endif
+
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tot_size = tot_size;  /* TOT_SIZE */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_sel = DMAC_CH_DST_SEL_M1;  /* DST_SEL */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_sel = DMAC_CH_SRC_SEL_M0;  /* SRC_SEL */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;  /* DSTAD_CTL */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;  /* SRCAD_CTL */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_width = DMAC_CH_DST_WIDTH_32_BITS;  /* DST_WIDTH */
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_width = DMAC_CH_SRC_WIDTH_32_BITS;  /* SRC_WIDTH */
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = (DMAC_CH_TC_MASK_ENABLE);  /* TC_MASK */
+#else
+        i2s_left_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = ((ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_CH_TC_MASK_ENABLE) : (DMAC_CH_TC_MASK_DISABLE));  /* TC_MASK */
+#endif
+    }
+
+    i2s_wm8772_dma_left_rx.channel_id = DMAC_CH_ID(i2s_wm8772_dma_left_rx_channel);
+    i2s_wm8772_dma_left_rx.target_select = DMAC_HW_HAND_SHAKE_I2S_RX_LEFT_ID;
+
+    i2s_wm8772_dma_left_rx.src_addr = i2s_left_rx_channel_dma_llp_desc[0].SrcAddr;
+    i2s_wm8772_dma_left_rx.dst_addr = i2s_left_rx_channel_dma_llp_desc[0].DstAddr;
+
+    i2s_wm8772_dma_left_rx.src_master = DMAC_CH_SRC_SEL_M0;
+    i2s_wm8772_dma_left_rx.dst_master = DMAC_CH_DST_SEL_M1;
+
+    i2s_wm8772_dma_left_rx.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;
+    i2s_wm8772_dma_left_rx.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;
+
+    i2s_wm8772_dma_left_rx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    i2s_wm8772_dma_left_rx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    i2s_wm8772_dma_left_rx.transfer_bytes = I2S_WM8772_BUFFER_SIZE * 4;
+
+    i2s_wm8772_dma_left_rx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    i2s_wm8772_dma_left_rx.llp_addr = (i2s_dmac_llp_num == 1) ? 0 : (u32)i2s_left_rx_channel_dma_llp_desc[0].LLP;
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8772_dma_left_rx);
+
+//4. *****************************************************************************
+    /*
+     * Configure DMA's channel setting for I2S's Right Channel Rx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    for (ii = 0; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+    {
+        i2s_right_rx_channel_dma_llp_desc[ii].SrcAddr = (I2S_BASE_ADDR + 0xCC);
+        
+        i2s_right_rx_channel_dma_llp_desc[ii].DstAddr = i2s_right_channel_llp_buf[ii];
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_right_rx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&rb_rxd_p[ii + 1] : (DMAC_LLP_T *)&rb_rxd_p[1];
+#else
+        i2s_right_rx_channel_dma_llp_desc[ii].LLP = (ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_LLP_T *)&rb_rxd_p[ii + 1] : (DMAC_LLP_T *)(0);
+#endif
+
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tot_size = tot_size;  /* TOT_SIZE */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_sel = DMAC_CH_DST_SEL_M1;  /* DST_SEL */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_sel = DMAC_CH_SRC_SEL_M0;  /* SRC_SEL */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;  /* DSTAD_CTL */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;  /* SRCAD_CTL */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.dst_width = DMAC_CH_DST_WIDTH_32_BITS;  /* DST_WIDTH */
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.src_width = DMAC_CH_SRC_WIDTH_32_BITS;  /* SRC_WIDTH */
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = (DMAC_CH_TC_MASK_ENABLE);  /* TC_MASK */
+#else
+        i2s_right_rx_channel_dma_llp_desc[ii].Ctrl_TotSize.tc_status_mask = ((ii != (I2S_WM8772_DMAC_LLP_NUM - 1)) ? (DMAC_CH_TC_MASK_ENABLE) : (DMAC_CH_TC_MASK_DISABLE));  /* TC_MASK */
+#endif
+    }
+
+    i2s_wm8772_dma_right_rx.channel_id = DMAC_CH_ID(i2s_wm8772_dma_right_rx_channel);
+    i2s_wm8772_dma_right_rx.target_select = DMAC_HW_HAND_SHAKE_I2S_RX_RIGHT_ID;
+
+    i2s_wm8772_dma_right_rx.src_addr = i2s_right_rx_channel_dma_llp_desc[0].SrcAddr;
+    i2s_wm8772_dma_right_rx.dst_addr = i2s_right_rx_channel_dma_llp_desc[0].DstAddr;
+
+    i2s_wm8772_dma_right_rx.src_master = DMAC_CH_SRC_SEL_M0;
+    i2s_wm8772_dma_right_rx.dst_master = DMAC_CH_DST_SEL_M1;
+
+    i2s_wm8772_dma_right_rx.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;
+    i2s_wm8772_dma_right_rx.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;
+
+    i2s_wm8772_dma_right_rx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    i2s_wm8772_dma_right_rx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    i2s_wm8772_dma_right_rx.transfer_bytes = I2S_WM8772_BUFFER_SIZE * 4;
+
+    i2s_wm8772_dma_right_rx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;
+
+    i2s_wm8772_dma_right_rx.llp_addr = (i2s_dmac_llp_num == 1) ? 0 : (u32)i2s_right_rx_channel_dma_llp_desc[0].LLP;
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8772_dma_right_rx);
+//*****************************************************************************
+    return;
+}
+
+
+//=================================================================================
+//
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+static irqreturn_t str8100_dma_tc_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 dma_tc_status,tot_size;
+	u32 len;
+//printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+
+    HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(dma_tc_status);
+printk("%s: this_irq=%d, dma_tc_status=%.8x\n",__FUNCTION__,this_irq,dma_tc_status);
+
+#ifdef I2S_WM8772_DMAC_LLP_RING_TEST
+	u32 i;
+    /*
+     * For LLP ring test, the TC interrupt shoule not happen!!
+     */
+	for(i=0;i<8;i++)
+	if (dma_tc_status & DMAC_CH_ID(i)){                      
+		HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i));
+		printk("%s: channel %d: Error!! there should be no tc irq happened!!\n",__FUNCTION__,i);
+	}
+
+#else
+    /*
+     * For this case, it's recommended to set I2S_WM8772_DMAC_LLP_NUM = 1
+     */
+    /*
+     * For DMA's Tx for I2S Left Channel
+     */
+    if (dma_tc_status & DMAC_CH_ID(i2s_wm8772_dma_left_tx_channel))
+    {                      
+        HAL_DMAC_DISABLE_CHANNEL(i2s_wm8772_dma_left_tx_channel);
+        
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8772_dma_left_tx_channel));
+
+        /*
+         * Re-initialize DMA's channel for Left_Tx
+         */
+        DMAC_CH_SRC_ADDR(i2s_wm8772_dma_left_tx_channel) = i2s_left_tx_channel_dma_llp_desc[0].SrcAddr;
+
+        DMAC_CH_DST_ADDR(i2s_wm8772_dma_left_tx_channel) = i2s_left_tx_channel_dma_llp_desc[0].DstAddr;
+
+        /*
+         * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+         * number of source transfer width!
+         */        
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        DMAC_CH_SIZE(i2s_wm8772_dma_left_tx_channel) = tot_size & 0x0FFF;
+
+        HAL_DMAC_ENABLE_CHANNEL(i2s_wm8772_dma_left_tx_channel);
+    }
+
+
+    /*
+     * For DMA's Tx for I2S Right Channel
+     */
+    if (dma_tc_status & DMAC_CH_ID(i2s_wm8772_dma_right_tx_channel))
+    {                      
+        HAL_DMAC_DISABLE_CHANNEL(i2s_wm8772_dma_right_tx_channel);
+        
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8772_dma_right_tx_channel));
+
+        /*
+         * Re-initialize DMA's channel for Right_Tx
+         */
+        DMAC_CH_SRC_ADDR(i2s_wm8772_dma_right_tx_channel) = i2s_right_tx_channel_dma_llp_desc[0].SrcAddr;
+
+        DMAC_CH_DST_ADDR(i2s_wm8772_dma_right_tx_channel) = i2s_right_tx_channel_dma_llp_desc[0].DstAddr;
+
+        /*
+         * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+         * number of source transfer width!
+         */        
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        DMAC_CH_SIZE(i2s_wm8772_dma_right_tx_channel) = tot_size & 0x0FFF;
+
+        HAL_DMAC_ENABLE_CHANNEL(i2s_wm8772_dma_right_tx_channel);
+    }
+
+
+    /*
+     * For DMA's Rx for I2S Left Channel
+     */
+    if (dma_tc_status & DMAC_CH_ID(i2s_wm8772_dma_left_rx_channel))
+    {                      
+        HAL_DMAC_DISABLE_CHANNEL(i2s_wm8772_dma_left_rx_channel);
+        
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8772_dma_left_rx_channel));
+
+        /*
+         * Re-initialize DMA's channel for Left_Rx
+         */
+        DMAC_CH_SRC_ADDR(i2s_wm8772_dma_left_rx_channel) = i2s_left_rx_channel_dma_llp_desc[0].SrcAddr;
+
+        DMAC_CH_DST_ADDR(i2s_wm8772_dma_left_rx_channel) = i2s_left_rx_channel_dma_llp_desc[0].DstAddr;
+
+        /*
+         * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+         * number of source transfer width!
+         */        
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        DMAC_CH_SIZE(i2s_wm8772_dma_left_rx_channel) = tot_size & 0x0FFF;
+
+        HAL_DMAC_ENABLE_CHANNEL(i2s_wm8772_dma_left_rx_channel);
+    }
+
+
+    /*
+     * For DMA's Rx for I2S Right Channel
+     */
+    if (dma_tc_status & DMAC_CH_ID(i2s_wm8772_dma_right_rx_channel))
+    {                      
+        HAL_DMAC_DISABLE_CHANNEL(i2s_wm8772_dma_right_rx_channel);
+        
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8772_dma_right_rx_channel));
+
+        /*
+         * Re-initialize DMA's channel for Right_Rx
+         */
+        DMAC_CH_SRC_ADDR(i2s_wm8772_dma_right_rx_channel) = i2s_right_rx_channel_dma_llp_desc[0].SrcAddr;
+
+        DMAC_CH_DST_ADDR(i2s_wm8772_dma_right_rx_channel) = i2s_right_rx_channel_dma_llp_desc[0].DstAddr;
+
+        /*
+         * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+         * number of source transfer width!
+         */        
+        tot_size = Hal_Dmac_Get_Channel_Transfer_Unit_Number(I2S_WM8772_BUFFER_SIZE * 4, DMAC_CH_SRC_WIDTH_32_BITS);
+
+        DMAC_CH_SIZE(i2s_wm8772_dma_right_rx_channel) = tot_size & 0x0FFF;
+
+        HAL_DMAC_ENABLE_CHANNEL(i2s_wm8772_dma_right_rx_channel);
+    }
+#endif
+
+
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+
+static irqreturn_t str8100_i2s_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 interrupt_status;
+	DEBUG_PRINT("%s: this_irq=%d, I2S_INTERRUPT_STATUS_REG=0x%.8x\n",__FUNCTION__,this_irq,I2S_INTERRUPT_STATUS_REG);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+	interrupt_status = I2S_INTERRUPT_STATUS_REG;   
+
+		I2S_RIGHT_TRANSMIT_DATA_REG=0;
+
+
+	if ((interrupt_status & (I2S_RXBF_R_FULL_FLAG | I2S_RXBF_L_FULL_FLAG | I2S_TXBF_R_EMPTY_FLAG | I2S_TXBF_L_EMPTY_FLAG))){
+		printk("%s: Error! wrong i2s empty/full flag\n",__FUNCTION__);
+	
+	}
+
+	if ((interrupt_status & (I2S_RXBF_R_OR_FLAG | I2S_RXBF_L_OR_FLAG |I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG))){
+		// Clear I2S interrupt status
+		i2s_err_lur++;
+		if(i2s_err_lur>10)
+			I2S_INTERRUPT_ENABLE_REG &= ~(I2S_TXBF_L_UR_FLAG);
+//			HAL_I2S_DISABLE_I2S();
+		
+		printk("%s: Left Channel Tx Underrun!, interrupt_status=%.8x,i2s_err_lur=%d\n",__FUNCTION__,interrupt_status,i2s_err_lur);
+	}
+	I2S_INTERRUPT_STATUS_REG &= 0xf0;
+
+	
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+
+
+//=================================================================================
+
+static void i2s_exit_module(void){
+	printk("%s:\n",__FUNCTION__);
+	remove_proc_entry("str8100/i2s", NULL);
+	free_irq(INTC_I2S_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_TC_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_ERROR_BIT_INDEX, NULL);
+	if(buffer) {
+		pci_free_consistent(NULL, BUFSIZE*2, buffer, buffer_p);
+		buffer=buffer_p=NULL;
+		lbuffer=lbuffer_p=rbuffer=rbuffer_p=NULL;
+	}
+	if(desc) {
+		pci_free_consistent(NULL, I2S_WM8772_DMAC_LLP_NUM*sizeof(DMAC_LLP_T)*4 , desc, desc_p);
+		desc=desc_p=NULL;
+		lb_txd=lb_txd_p=lb_rxd=lb_rxd_p=NULL;
+		rb_txd=rb_txd_p=rb_rxd=rb_rxd_p=NULL;
+	}
+}
+
+static int __init i2s_init_module(void)
+{
+	
+	u32 ret;
+	u32 ii;
+	
+	printk("%s:\n",__FUNCTION__);
+
+	buffer = pci_alloc_consistent(NULL, BUFSIZE*2, &buffer_p);
+	if(!buffer){
+		printk("%s: alloc buffer failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	lbuffer=buffer;
+	lbuffer_p=buffer_p;
+	rbuffer=lbuffer+BUFSIZE;
+	rbuffer_p=lbuffer_p+BUFSIZE;
+	
+	desc = pci_alloc_consistent(NULL, I2S_WM8772_DMAC_LLP_NUM*sizeof(DMAC_LLP_T)*4 , &desc_p);
+	if(!desc){
+		printk("%s: alloc buffer for desc failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	lb_txd=desc;
+	lb_txd_p=desc_p;
+	lb_rxd=desc+I2S_WM8772_DMAC_LLP_NUM;
+	lb_rxd_p=desc_p+I2S_WM8772_DMAC_LLP_NUM;
+
+	rb_txd=desc+I2S_WM8772_DMAC_LLP_NUM*2;
+	rb_txd_p=desc_p+I2S_WM8772_DMAC_LLP_NUM*2;
+	rb_rxd=desc+I2S_WM8772_DMAC_LLP_NUM*3;
+	rb_rxd_p=desc_p+I2S_WM8772_DMAC_LLP_NUM*3;
+	
+
+	str8100_set_interrupt_trigger (INTC_I2S_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);
+	if ((ret=request_irq(INTC_I2S_BIT_INDEX, str8100_i2s_irq_handler, 0, "i2s", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_I2S_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+
+	str8100_set_interrupt_trigger (INTC_GDMAC_TC_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_TC_BIT_INDEX, str8100_dma_tc_irq_handler, 0, "dma tc", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_TC_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+	str8100_set_interrupt_trigger (INTC_GDMAC_ERROR_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_ERROR_BIT_INDEX, str8100_dma_err_irq_handler, 0, "dma error", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_ERROR_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+
+	/*
+	 * Initialize GPIO pins for COM1/COM2/COM3
+	 */
+	I2s_Gpio_SSP_Initialise();
+
+	str8100_i2s_init(sampling_rate,DATA_WIDTH, I2S_MODE, I2S_TIMING, I2S_SCLK_MODE);
+
+	/*
+	 * Configure Wolfson's WM8772 ADC/DAC
+	 */
+	I2s_Configure_WM8772(I2S_TIMING, DATA_WIDTH, I2S_MODE); 
+#ifdef I2S_FULL_DUPLEX
+	/*
+	* To support I2S full duplex mode, GPIOA[3] will be used as I2S_DR pin.
+	* It means GPIOA[3] should be as input pin.
+	*/
+	MISC_GPIOA_PIN_ENABLE_REG &= ~(0x1 << 3);
+    
+	GPIOA_DIRECTION_REG &= ~(0x1 << 3);
+#endif
+
+	I2S_RIGHT_TRANSMIT_DATA_REG=0;
+	I2S_LEFT_TRANSMIT_DATA_REG=0;
+	ii=I2S_RIGHT_RECEIVE_DATA_REG;
+	ii=I2S_LEFT_RECEIVE_DATA_REG;
+
+	/*
+	 * Initialize DMAC related configuration
+	 */    
+
+	i2s_left_channel_llp_buf[0] = lbuffer_p;
+	i2s_right_channel_llp_buf[0] = rbuffer_p;
+	memset ((void *)&lbuffer[0], 0x0, I2S_WM8772_BUFFER_SIZE * 4);
+	memset ((void *)&rbuffer[0], 0x0, I2S_WM8772_BUFFER_SIZE * 4);
+	for (ii = 1; ii < I2S_WM8772_DMAC_LLP_NUM; ii++)
+	{
+		i2s_left_channel_llp_buf[ii] = i2s_left_channel_llp_buf[ii - 1] + (I2S_WM8772_BUFFER_SIZE * 4);
+		i2s_right_channel_llp_buf[ii] = i2s_right_channel_llp_buf[ii - 1] + (I2S_WM8772_BUFFER_SIZE * 4);
+		memset ((void *)&lbuffer[ii*I2S_WM8772_BUFFER_SIZE*4], 0x0, I2S_WM8772_BUFFER_SIZE * 4);
+		memset ((void *)&rbuffer[ii*I2S_WM8772_BUFFER_SIZE*4], 0x0, I2S_WM8772_BUFFER_SIZE * 4);
+	}
+
+	i2s_wm8772_dma_left_tx_channel = 0;
+    
+	i2s_wm8772_dma_right_tx_channel = 1;
+    
+	i2s_wm8772_dma_left_rx_channel = 2;
+    
+	i2s_wm8772_dma_right_rx_channel = 3;
+
+
+	I2s_Configure_WM8772_DMA_Hardware_Handshake();
+
+
+	/*
+	 * Enable I2S's interrupt sources
+	 * Note for DMA hardware handshake, we only need to enable Left/Right Channel's 
+	 * Transmit Buffer Underrun.
+	 */
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_RXBF_R_OR_FLAG | I2S_RXBF_L_OR_FLAG | I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG);
+
+	// Enable CPU interrupt
+	local_irq_enable();
+	
+	/*
+	 * Note DMA must be enabled first before I2S is enabled
+	 */
+	HAL_DMAC_ENABLE();
+	HAL_I2S_ENABLE_I2S();
+	printk("%s: exit successfully\n",__FUNCTION__);
+	return 0;
+
+exit1:
+	HAL_I2S_DISABLE_I2S();
+	i2s_exit_module();
+	printk("%s: exit errornous\n",__FUNCTION__);
+	return -EBUSY;
+}
+
+module_init(i2s_init_module);
+module_exit(i2s_exit_module);
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_pcm_legerity_config_2phone.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_pcm_legerity_config_2phone.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_demo_pcm_legerity_config_2phone.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_demo_pcm_legerity_config_2phone.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,921 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//Options 
+//#define DEBUG_PRINT	
+//=================================================================================
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/wait.h>		//wait queue
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include <mach/star_spi.h>
+#include <mach/star_pcm.h>
+#include <mach/star_dmac.h>
+#include <mach/star_demo_dma.h>
+
+#include <sound/pcm.h>
+#include <mach/star_i2s.h>
+
+#define u_int32 u32
+#define u_int16 u16
+#define u_int8 u8
+
+extern void Pcm_Initial_Legerity_Le88221(void);
+
+#define Sys_Interrupt_Disable_Save_Flags(_p) local_irq_save(*(_p))
+//#define Sys_Interrupt_Disable_Save_Flags local_irq_save
+#define Sys_Interrupt_Restore_Flags local_irq_restore
+
+#define Hal_Timer_Timer3_Delay(_p) mdelay(_p/1000)
+//int debug = 0;
+#ifdef DEBUG_PRINT
+#undef DEBUG_PRINT
+//#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+#define DEBUG_PRINT printk
+#else
+//#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+#define DEBUG_PRINT(arg...) printk(KERN_DEBUG arg);
+#endif
+
+
+
+/*
+ * public variable declarations
+ */
+PCM_OBJECT_T                          pcm_object;
+PCM_CHANNEL_OBJECT_T                  pcm_channel_object;
+
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T  pcm_tx_data0_dma_legerity;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T  pcm_rx_data0_dma_legerity;
+//static DMAC_HARDWARE_HANDSHAKE_OBJ_T  pcm_tx_data1_dma_legerity;
+//static DMAC_HARDWARE_HANDSHAKE_OBJ_T  pcm_rx_data1_dma_legerity;
+
+static u_int32                        pcm_tx_data0_dma_channel_num = 2;
+//static u_int32                        pcm_tx_data1_dma_channel_num = 3;
+static u_int32                        pcm_rx_data0_dma_channel_num = 4;
+//static u_int32                        pcm_rx_data1_dma_channel_num = 5;
+
+//#define           BUFFER_SIZE    (1 * 256)
+//#define           BUFFER_SIZE    (1 * 128)
+//#define           BUFFER_SIZE    (1 * PCM_LOG_PERIOD_SEC * 8000)
+#define           BUFFER_SIZE    0xfff
+
+u_int32    *buffer0;
+u_int32    *buffer1;
+u_int32    *buffer2;
+u_int32    *buffer3;
+
+u_int32    *buffer_p0;
+u_int32    *buffer_p1;
+u_int32    *buffer_p2;
+u_int32    *buffer_p3;
+
+u_int32    *pcm_rx0_buffer_le88221;
+u_int32    *pcm_tx0_buffer_le88221;
+u_int32    *pcm_rx1_buffer_le88221;
+u_int32    *pcm_tx1_buffer_le88221;
+
+u_int32    *pcm_rx0_buffer_le88221_p;
+u_int32    *pcm_tx0_buffer_le88221_p;
+u_int32    *pcm_rx1_buffer_le88221_p;
+u_int32    *pcm_tx1_buffer_le88221_p;
+
+
+#define HAL_DMAC_WRITE_CHANNEL0_DESTINATION_ADDRESS(_p) DMAC_CH_DST_ADDR_REG(2) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL1_DESTINATION_ADDRESS(_p) DMAC_CH_DST_ADDR_REG(3) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL2_DESTINATION_ADDRESS(_p) DMAC_CH_DST_ADDR_REG(4) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL3_DESTINATION_ADDRESS(_p) DMAC_CH_DST_ADDR_REG(5) = (_p)
+
+#define HAL_DMAC_WRITE_CHANNEL0_SOURCE_ADDRESS(_p) DMAC_CH_SRC_ADDR_REG(2) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL1_SOURCE_ADDRESS(_p) DMAC_CH_SRC_ADDR_REG(3) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL2_SOURCE_ADDRESS(_p) DMAC_CH_SRC_ADDR_REG(4) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL3_SOURCE_ADDRESS(_p) DMAC_CH_SRC_ADDR_REG(5) = (_p)
+
+#define HAL_DMAC_WRITE_CHANNEL0_TRANSFER_SIZE(_p) DMAC_CH_SIZE_REG(2) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL1_TRANSFER_SIZE(_p) DMAC_CH_SIZE_REG(3) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL2_TRANSFER_SIZE(_p) DMAC_CH_SIZE_REG(4) = (_p)
+#define HAL_DMAC_WRITE_CHANNEL3_TRANSFER_SIZE(_p) DMAC_CH_SIZE_REG(5) = (_p)
+		
+#define HAL_DMAC_ENABLE_CHANNEL0(_p) HAL_DMAC_ENABLE_CHANNEL(2)
+#define HAL_DMAC_ENABLE_CHANNEL1(_p) HAL_DMAC_ENABLE_CHANNEL(3)
+#define HAL_DMAC_ENABLE_CHANNEL2(_p) HAL_DMAC_ENABLE_CHANNEL(4)
+#define HAL_DMAC_ENABLE_CHANNEL3(_p) HAL_DMAC_ENABLE_CHANNEL(5)
+        
+u_int32 rxbuf_full=0;
+u_int32 txbuf_empty=0;
+u_int32 rxbuf_overrun=0;
+u_int32 txbuf_underrun=0;
+
+u_int32 pcm_dma_ch0_tc_count = 0;
+u_int32 pcm_dma_ch2_tc_count = 0;
+u_int32 pcm_dma_ch1_tc_count = 0;
+u_int32 pcm_dma_ch3_tc_count = 0;
+
+/*
+ * For Legerity's Le88221
+ */
+#define        CH0_TX_Le88221_DELAY       (0)
+#define        CH0_RX_Le88221_DELAY       (0)
+
+#define        CH1_TX_Le88221_DELAY       (8)
+#define        CH1_RX_Le88221_DELAY       (8)
+
+#define        CH2_TX_Le88221_DELAY       (32)
+#define        CH2_RX_Le88221_DELAY       (32)
+
+#define        CH3_TX_Le88221_DELAY       (48)
+#define        CH3_RX_Le88221_DELAY       (48)
+
+
+
+
+static struct proc_dir_entry *star_pcm_proc_entry=NULL;
+static u8* txbuffer;
+//static u8* txbuffer_p;
+static u32 txlen=0;
+static u32 txpos=0;
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_Pcm_Initialize
+ * PURPOSE:
+ *
+ ******************************************************************************/
+void Hal_Pcm_Initialize(PCM_OBJECT_T *pPcm_Object)
+{
+    //u_int32 volatile    tx_data0 = 0;
+    u_int32 volatile    rx_data0 = 0;
+
+
+    // Enable PCM pins
+    HAL_MISC_ENABLE_PCM_PINS();
+
+    // Enable PCM clock
+    HAL_PWRMGT_ENABLE_PCM_CLOCK(); 
+
+/*    if (p2s_reset_flag == 0)
+    {
+        Hal_Pwrmgt_Software_Reset(PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);
+        
+        p2s_reset_flag = 1;
+    }
+*/
+
+    /*
+     * Note PCM is NOT enabled after this function is invoked!!
+     */
+    PCM_CONFIGURATION_0_REG = pPcm_Object->config_0;
+    PCM_CONFIGURATION_1_REG = pPcm_Object->config_1;
+    PCM_CHANNEL_0_CONFIG_REG = pPcm_Object->channel_0_config;
+    PCM_CHANNEL_1_CONFIG_REG = pPcm_Object->channel_1_config;
+    PCM_CHANNEL_2_CONFIG_REG = pPcm_Object->channel_2_config;
+    PCM_CHANNEL_3_CONFIG_REG = pPcm_Object->channel_3_config;
+    PCM_INTERRUPT_ENABLE_REG = pPcm_Object->interrupt_config;
+
+/*
+    if (pPcm_Object->interrupt_config)
+    {
+        Hal_Intc_Register_Interrupt(&pPcm_Object->intc_obj);	
+    }
+*/
+    rx_data0 = PCM_RX_DATA_63_32_REG;
+    rx_data0 = PCM_RX_DATA_31_0_REG;
+
+    // Clear spurious interrupt sources
+    PCM_INTERRUPT_STATUS_REG = PCM_RXBUF_OVERRUN_FG | PCM_TXBUF_UNDERRUN_FG;
+
+    // Disable PCM
+    HAL_PCM_DISABLE_PCM();
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_Pcm_Is_Transmit_Buffer_Empty
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 Hal_Pcm_Is_Transmit_Buffer_Empty(void)
+{
+    /*
+     * Return value :
+     *    1 : PCM Tx Transmit Buffer Empty
+     *    0 : PCM Tx Transmit Buffer Not Empty
+     */    
+    return ((PCM_INTERRUPT_STATUS_REG & PCM_TXBUF_EMPTY_FG) ? 1 : 0);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_Pcm_Is_Receive_Buffer_Full
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 Hal_Pcm_Is_Receive_Buffer_Full(void)
+{
+    /*
+     * Return value :
+     *    1 : PCM Rx Receive Buffer Full
+     *    0 : PCM Rx Receive Buffer Not Full
+     */    
+    return ((PCM_INTERRUPT_STATUS_REG & PCM_RXBUF_FULL_FG) ? 1 : 0);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:  Pcm_Configure_DMA_Hardware_Handshake_For_Legerity
+ * PURPOSE:
+ *
+ ******************************************************************************/
+void Pcm_Configure_DMA_Hardware_Handshake_For_Legerity(void)
+{
+
+	DEBUG_PRINT(" %s : ==>\n" ,__FUNCTION__);
+#if 1
+    /*
+     * Configure DMA's channel setting for PCM Transmit Data[31:0] Register
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+
+    pcm_tx_data0_dma_legerity.channel_id = DMAC_CH_ID(pcm_tx_data0_dma_channel_num);//0    
+    pcm_tx_data0_dma_legerity.target_select = DMAC_HW_HAND_SHAKE_PCM_TX0_ID;//0
+
+    pcm_tx_data0_dma_legerity.src_addr = (u_int32)pcm_tx0_buffer_le88221_p;//SCR        
+    pcm_tx_data0_dma_legerity.dst_addr = (SYSPA_PCM_BASE_ADDR + 0x98);//DST
+
+    pcm_tx_data0_dma_legerity.src_master = DMAC_CH_SRC_SEL_M1;//1
+    pcm_tx_data0_dma_legerity.dst_master = DMAC_CH_DST_SEL_M0;//0
+
+    pcm_tx_data0_dma_legerity.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;//0
+    pcm_tx_data0_dma_legerity.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;//2
+
+    pcm_tx_data0_dma_legerity.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    pcm_tx_data0_dma_legerity.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    pcm_tx_data0_dma_legerity.transfer_bytes = BUFFER_SIZE * 4;
+
+    pcm_tx_data0_dma_legerity.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;//0   
+
+    // Note this DMA's channel will be enabled when the following function is invoked!!
+    Hal_Dmac_Configure_DMA_Handshake(&pcm_tx_data0_dma_legerity);
+
+
+    /*
+     * Configure DMA's channel setting for PCM Receive Data[31:0] Register
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    pcm_rx_data0_dma_legerity.channel_id = DMAC_CH_ID(pcm_rx_data0_dma_channel_num);//2    
+    pcm_rx_data0_dma_legerity.target_select = DMAC_HW_HAND_SHAKE_PCM_RX0_ID;//1
+
+    pcm_rx_data0_dma_legerity.src_addr = (SYSPA_PCM_BASE_ADDR + 0xA0);//SCR
+    pcm_rx_data0_dma_legerity.dst_addr = (u_int32)pcm_rx0_buffer_le88221_p;//DST        
+
+    pcm_rx_data0_dma_legerity.src_master = DMAC_CH_SRC_SEL_M0;//0
+    pcm_rx_data0_dma_legerity.dst_master = DMAC_CH_DST_SEL_M1;//1
+
+    pcm_rx_data0_dma_legerity.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;//2
+    pcm_rx_data0_dma_legerity.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;//0
+
+    pcm_rx_data0_dma_legerity.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    pcm_rx_data0_dma_legerity.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    pcm_rx_data0_dma_legerity.transfer_bytes = BUFFER_SIZE * 4;
+
+    pcm_rx_data0_dma_legerity.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;
+
+    // Note this DMA's channel will be enabled when the following function is invoked!!
+    Hal_Dmac_Configure_DMA_Handshake(&pcm_rx_data0_dma_legerity);
+#endif
+
+
+#if 0
+    /*
+     * Configure DMA's channel setting for PCM Transmit Data[31:0] Register
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */    
+    pcm_tx_data1_dma_legerity.channel_id = DMAC_CH_ID(pcm_tx_data1_dma_channel_num);//1
+    pcm_tx_data1_dma_legerity.target_select = DMAC_HW_HAND_SHAKE_PCM_TX1_ID;
+
+    pcm_tx_data1_dma_legerity.src_addr = (u_int32)pcm_tx1_buffer_le88221_p;
+    pcm_tx_data1_dma_legerity.dst_addr = (SYSPA_PCM_BASE_ADDR + 0x9C);    
+
+    pcm_tx_data1_dma_legerity.src_master = DMAC_CH_SRC_SEL_M1;
+    pcm_tx_data1_dma_legerity.dst_master = DMAC_CH_DST_SEL_M0;
+
+    pcm_tx_data1_dma_legerity.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    pcm_tx_data1_dma_legerity.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+
+    pcm_tx_data1_dma_legerity.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    pcm_tx_data1_dma_legerity.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    pcm_tx_data1_dma_legerity.transfer_bytes = BUFFER_SIZE * 4;
+
+    pcm_tx_data1_dma_legerity.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;
+
+    Hal_Dmac_Configure_DMA_Handshake(&pcm_tx_data1_dma_legerity);
+
+
+
+    /*
+     * Configure DMA's channel setting for PCM Receive Data[31:0] Register
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */    
+    pcm_rx_data1_dma_legerity.channel_id = DMAC_CH_ID(pcm_rx_data1_dma_channel_num);//3
+    pcm_rx_data1_dma_legerity.target_select = DMAC_HW_HAND_SHAKE_PCM_RX1_ID;
+    pcm_rx_data1_dma_legerity.src_addr = (SYSPA_PCM_BASE_ADDR + 0xA4);    
+    pcm_rx_data1_dma_legerity.dst_addr = (u_int32)pcm_rx1_buffer_le88221_p;    
+
+    pcm_rx_data1_dma_legerity.src_master = DMAC_CH_SRC_SEL_M0;
+    pcm_rx_data1_dma_legerity.dst_master = DMAC_CH_DST_SEL_M1;
+
+    pcm_rx_data1_dma_legerity.srcad_ctl = DMAC_CH_SRCAD_CTL_FIX;
+    pcm_rx_data1_dma_legerity.dstad_ctl = DMAC_CH_DSTAD_CTL_INC;
+
+    pcm_rx_data1_dma_legerity.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    pcm_rx_data1_dma_legerity.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    // Note here the total number of bytes is specified!!
+    pcm_rx_data1_dma_legerity.transfer_bytes = BUFFER_SIZE * 4;
+
+    pcm_rx_data1_dma_legerity.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;
+
+    Hal_Dmac_Configure_DMA_Handshake(&pcm_rx_data1_dma_legerity);    
+#endif            
+  
+    return;
+}
+
+#if 0
+static irqreturn_t str8100_pcm_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+    u_int32 volatile    interrupt_status;    
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+#if 1
+    PCM_INTERRUPT_STATUS_REG&=0xc0;
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+#endif
+	DEBUG_PRINT("%s: this_irq=%d, PCM_INTERRUPT_STATUS_REG=0x%.8x\n",__FUNCTION__,this_irq,PCM_INTERRUPT_STATUS_REG);
+
+    // Get PCM interrupt status
+    HAL_PCM_READ_INTERRUPT_STATUS(interrupt_status);   
+    if (interrupt_status & PCM_RXBUF_FULL_FG){
+    	rxbuf_full++;
+		DEBUG_PRINT("%s: rx buf full\n",__FUNCTION__);
+    }
+
+    if (interrupt_status & PCM_TXBUF_EMPTY_FG){
+    	txbuf_empty++;
+        DEBUG_PRINT("%s: tx buf empty\n",__FUNCTION__);
+    }
+    if (interrupt_status & PCM_RXBUF_OVERRUN_FG){
+        // Clear PCM interrupt status
+        HAL_PCM_CLEAR_INTERRUPT_STATUS(PCM_RXBUF_OVERRUN_FG);
+    
+        rxbuf_overrun++;
+        DEBUG_PRINT("%s: rx buf overrun\n",__FUNCTION__);
+    }
+
+    if (interrupt_status & PCM_TXBUF_UNDERRUN_FG){
+        // Clear PCM interrupt status
+        HAL_PCM_CLEAR_INTERRUPT_STATUS(PCM_TXBUF_UNDERRUN_FG);
+
+        txbuf_underrun++;
+        DEBUG_PRINT("%s: tx buf underrun\n",__FUNCTION__);
+    }
+    PCM_INTERRUPT_STATUS_REG&=0xc0;
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_SND_STAR_I2S_WM8759
+#define I2S_CHANNEL_NUM 2
+extern DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8759_dma_handshake_tx[I2S_CHANNEL_NUM];
+struct snd_star_i2s_wm8759_pcm_priv {
+	struct snd_star_i2s_wm8759_priv *card_priv;
+	spinlock_t lock;
+	struct timer_list timer;
+	unsigned int buffer_size_in_bytes;
+        unsigned int period_size_in_bytes;
+	unsigned int pcm_bps;		/* bytes per second */
+	unsigned int pcm_jiffie;	/* bytes per one jiffie */
+
+	unsigned int pcm_irq_pos[I2S_CHANNEL_NUM];	/* IRQ position */
+	unsigned int pcm_buf_pos[I2S_CHANNEL_NUM];	/* position in buffer */
+
+	u32 period_count_in_buffer; 	//(buffer_size/period_size)
+	u32 desc_count;		//period_count_in_buffer*channels
+
+	u32 desc_size_in_bytes;	//desc_count*sizeof(DMAC_LLP_T);
+	DMAC_LLP_T* desc;	//vir addr of desc buffer allocated
+	DMAC_LLP_T* desc_p;	//phy addr of desc buffer allocated
+
+	struct snd_pcm_substream *substream;
+};
+#endif
+
+static DECLARE_WAIT_QUEUE_HEAD(wg);
+static int swap_flag=0;
+static int call_swap_buffer(void)
+{
+	//current->pid, current->comm);
+	//printk(KERN_INFO "swap_flag=%d ...\n",swap_flag);
+
+	//wake up swap buffer
+	swap_flag=1;
+	wake_up_interruptible(&wg);
+	return 0;
+
+}
+
+
+static int swap_buffer_thread(void *data) 
+{
+	int i;
+	u_int32    *swap_buffer,*swap_buffer_p;
+	for(;;){
+		//printk(KERN_INFO "swap buffer start \n");
+		if(pcm_rx0_buffer_le88221==buffer0){
+			//printk("rx change to buffer1 \n");
+			swap_buffer=buffer2;
+			swap_buffer_p=buffer_p2;
+		}else if(pcm_rx0_buffer_le88221==buffer1){
+			//printk("rx change to buffer2 \n");
+			swap_buffer=buffer0;
+			swap_buffer_p=buffer_p0;
+
+		}else{
+			//printk("rx change to buffer0 \n");
+			swap_buffer=buffer1;
+			swap_buffer_p=buffer_p1;
+		}
+		for(i=0;i<BUFFER_SIZE;i++)
+			swap_buffer[i] = \
+			((swap_buffer[i] >> 8) & 0x000000FF) | \
+			((swap_buffer[i] << 8) & 0x0000FF00);
+
+		//printk("swap buffer end \n");
+		if(signal_pending(current))	
+			break;
+		wait_event_interruptible(wg, swap_flag !=0);
+		swap_flag=0;
+	}	
+	
+	return 1;
+}
+
+//static irqreturn_t str8100_dma_tc_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t str8100_dma_tc_irq_handler(int this_irq, void *dev_id)
+{
+    u_int32 volatile    dma_tc_status;
+	u32 i;
+
+	DEBUG_PRINT("%s: this_irq=%d,tc_status=0x%.8x\n",__FUNCTION__,this_irq,((DMAC_INT_TC_STATUS_REG) & 0xFF) );
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(dma_tc_status);
+    HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GDMAC_TC_BIT_INDEX);
+    HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(dma_tc_status);
+
+#ifdef CONFIG_SND_STAR_I2S_WM8759
+	if (dma_tc_status & DMAC_CH_ID(0) || dma_tc_status & DMAC_CH_ID(1))		// WM8759
+	{
+		for(i=0;i<I2S_CHANNEL_NUM;i++)
+		{
+			struct snd_pcm_substream *substream=(struct snd_pcm_substream *)i2s_wm8759_dma_handshake_tx[i].private_data;
+			struct snd_pcm_runtime *runtime = substream->runtime;
+			struct snd_star_i2s_wm8759_pcm_priv *dpcm = (struct snd_star_i2s_wm8759_pcm_priv *)runtime->private_data;
+			HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8759_dma_handshake_tx[i].channel_num));
+			dma_tc_status &= ~(DMAC_CH_ID(i2s_wm8759_dma_handshake_tx[i].channel_num));
+
+			//currently assume period size (in frames) is the DMA totsize
+			dpcm->pcm_irq_pos[i] += dpcm->period_size_in_bytes/runtime->channels;
+			dpcm->pcm_buf_pos[i] += dpcm->period_size_in_bytes/runtime->channels;
+			dpcm->pcm_buf_pos[i] %= dpcm->buffer_size_in_bytes/runtime->channels;
+
+			if (dpcm->pcm_irq_pos[i] >= (dpcm->period_size_in_bytes/runtime->channels)) {
+				dpcm->pcm_irq_pos[i] %= (dpcm->period_size_in_bytes/runtime->channels);
+				snd_pcm_period_elapsed(dpcm->substream);
+			}
+		}
+	}
+#endif
+
+    //DMA Rx reg 0
+    if (dma_tc_status & DMAC_CH_ID(pcm_rx_data0_dma_channel_num))
+    {
+        HAL_DMAC_DISABLE_CHANNEL(pcm_rx_data0_dma_channel_num);
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(pcm_rx_data0_dma_channel_num));
+        dma_tc_status &= ~(DMAC_CH_ID(pcm_rx_data0_dma_channel_num));
+
+        //make pcm ch0 to ch1, and vice versa
+		if(pcm_rx0_buffer_le88221==buffer0){
+			//printk("rx change to buffer1 \n");
+			pcm_rx0_buffer_le88221=buffer1;
+			pcm_rx0_buffer_le88221_p=buffer_p1;
+			
+		}
+        else if(pcm_rx0_buffer_le88221==buffer1){
+			//printk("rx change to buffer2 \n");
+			pcm_rx0_buffer_le88221=buffer2;
+			pcm_rx0_buffer_le88221_p=buffer_p2;
+
+		}else{
+			//printk("rx change to buffer0 \n");
+			pcm_rx0_buffer_le88221=buffer0;
+			pcm_rx0_buffer_le88221_p=buffer_p0;
+		}
+        
+        // Re-initialize DMA's channel for Rx
+        HAL_DMAC_WRITE_CHANNEL2_DESTINATION_ADDRESS((u_int32)pcm_rx0_buffer_le88221_p);
+        HAL_DMAC_WRITE_CHANNEL2_SOURCE_ADDRESS(SYSPA_PCM_BASE_ADDR + 0xA0);
+        HAL_DMAC_WRITE_CHANNEL2_TRANSFER_SIZE(BUFFER_SIZE);
+        HAL_DMAC_ENABLE_CHANNEL2();
+		call_swap_buffer();                        
+    }       
+
+    //DMA Tx reg 0
+    if (dma_tc_status & DMAC_CH_ID(pcm_tx_data0_dma_channel_num))
+    {
+        HAL_DMAC_DISABLE_CHANNEL(pcm_tx_data0_dma_channel_num);
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(pcm_tx_data0_dma_channel_num));
+        dma_tc_status &= ~(DMAC_CH_ID(pcm_tx_data0_dma_channel_num));
+
+		//swap buffer
+        if(pcm_tx0_buffer_le88221==buffer2) {
+			//printk("tx change to buffer0 \n");
+			pcm_tx0_buffer_le88221=buffer0;
+			pcm_tx0_buffer_le88221_p=buffer_p0;
+		}
+		else if(pcm_tx0_buffer_le88221==buffer1){
+			//printk("tx change to buffer2 \n");
+			pcm_tx0_buffer_le88221=buffer2;
+			pcm_tx0_buffer_le88221_p=buffer_p2;
+		}
+		else{
+			//printk("tx change to buffer1 \n");
+			pcm_tx0_buffer_le88221=buffer1;
+			pcm_tx0_buffer_le88221_p=buffer_p1;
+			}
+  
+        // Re-initialize DMA's channel for Tx
+        HAL_DMAC_WRITE_CHANNEL0_SOURCE_ADDRESS((u_int32)pcm_tx0_buffer_le88221_p);
+        HAL_DMAC_WRITE_CHANNEL0_DESTINATION_ADDRESS(SYSPA_PCM_BASE_ADDR + 0x98);
+        HAL_DMAC_WRITE_CHANNEL0_TRANSFER_SIZE(BUFFER_SIZE);
+        HAL_DMAC_ENABLE_CHANNEL0();
+    }       
+
+    /*
+     * If there is any bit set, it means something wrong!!
+     */
+    if (dma_tc_status)
+    {
+        // Something wrong because spurious interrupt happens!!
+        printk("Something wrong because spurious interrupt happens(%.8x)!!\n",dma_tc_status);
+    }
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+void pcm_init(void){
+	u32 flags;
+	//u32 tmp;
+	local_irq_save(flags);
+    /*
+     * Check CLK_OUT_SEL_Pin for 8.192 MHz
+     */
+	DEBUG_PRINT("%s:\n",__FUNCTION__);
+//    HAL_MISC_DISABLE_SPI_SERIAL_FLASH_BANK_ACCESS();
+    HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(10, 0);
+
+    /*
+     * For IDL Case:
+     *     UDCLK    : 4.096 MHz
+     *     PCMCLK   : 2.048 MHz = 4.096/(1 + 1)
+     *     FSYNCCLK : 8 KHz = 2048000/(255 + 1)
+     */
+    pcm_object.config_0 = ((/*clock_rate_ctrl*/1 & 0x7) << 0) |    /* Configure master clock rate */
+                          (0 << 12) |                   /* Disable loopback mode */
+                          (1 << 13) |                   /* Enable master mode */
+                          (0 << 14) |                   /* Select IDL mode */
+                          /*(1 << 24) | */                  /* Enable PCM data swap */
+                          (0 << 24) |                   /* Disable PCM data swap */
+                          (0 << 31);                    /* Disable PCM */
+
+    /*
+     * Note FSYNC_WIDE will be ignored when the PCM is configured as Slave or as Master
+     * with GCI mode
+     */    
+    pcm_object.config_1 = ((0 & 0x1) << 15);    /* Select FSYNC mode , 0 : short FSYNC, 1 : long FSYNC */
+
+
+    /*
+     * Configure the settings of PCM's channel
+     */
+    pcm_object.channel_0_config = ((CH0_TX_Le88221_DELAY & 0x7F) << 0) |
+                                  ((CH0_RX_Le88221_DELAY & 0x7F) << 8) |
+                                  ((PCM_DATA_BIT_8 & 0x1) << 22) |
+                                  (1 << 23);    /* Enable this channel */
+                                  
+    pcm_object.channel_1_config = ((CH1_TX_Le88221_DELAY & 0x7F) << 0) |
+                                  ((CH1_RX_Le88221_DELAY & 0x7F) << 8) |
+                                  ((PCM_DATA_BIT_8 & 0x1) << 22) |
+                                  (1 << 23);    /* Enable this channel */
+
+    pcm_object.channel_2_config = ((CH2_TX_Le88221_DELAY & 0x7F) << 0) |
+                                  ((CH2_RX_Le88221_DELAY & 0x7F) << 8) |
+                                  ((0 & 0x1) << 22) |
+                                  (0 << 23);    /* Disable this channel */
+
+    pcm_object.channel_3_config = ((CH3_TX_Le88221_DELAY & 0x7F) << 0) |
+                                  ((CH3_RX_Le88221_DELAY & 0x7F) << 8) |
+                                  ((0 & 0x1) << 22) |
+                                  (0 << 23);    /* Disable this channel */
+
+
+    // Enable PCM's interrupt sources
+//    pcm_object.interrupt_config = 0;
+    pcm_object.interrupt_config = PCM_RXBUF_OVERRUN_FG | PCM_TXBUF_UNDERRUN_FG;
+//    pcm_object.interrupt_config |=PCM_RXBUF_FULL_FG|PCM_TXBUF_EMPTY_FG;
+
+
+   
+    // Initialize PCM's setting
+    Hal_Pcm_Initialize(&pcm_object);
+    
+    
+    // Disable PCM interrupt since GDMA hardware handshake interrupt will be used.
+    //HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_PCM_BIT_INDEX);
+
+    // Initialize GDMA hardware handshake for PCM
+    Pcm_Configure_DMA_Hardware_Handshake_For_Legerity();
+
+
+    /*
+     * PCM will start to transmit and receive data once PCM is enabled. To avoid
+     * PCM Transmit Buffer underrun, we have to put one transmit data into PCM
+     * Transmit Buffer before PCM is enabled!!
+     * Note PCM channel 0 is used.
+     */
+/*
+	PCM_TX_DATA_31_0_REG=0;
+	PCM_TX_DATA_63_32_REG=0;
+
+	tmp=PCM_RX_DATA_31_0_REG;
+	tmp=PCM_RX_DATA_63_32_REG;
+*/
+    HAL_PCM_CLEAR_INTERRUPT_STATUS((PCM_RXBUF_OVERRUN_FG | PCM_TXBUF_UNDERRUN_FG));//(0x4 | 0x8)=0xC
+
+/*{
+	u32 dma_ch;
+	for (dma_ch = 0; dma_ch < DMAC_MAX_CHANNEL_NUM; dma_ch++)
+	{
+			HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(DMAC_CH_ID(dma_ch));
+        HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(dma_ch));
+	}	
+}
+*/
+    HAL_DMAC_ENABLE();    
+    HAL_PCM_ENABLE_PCM();
+
+    /*
+     * Configure Legerity's Le88221 MPI Interface
+     */
+    Pcm_Initial_Legerity_Le88221();
+	local_irq_restore(flags);
+
+    
+	DEBUG_PRINT("%s: end =>\n",__FUNCTION__);
+
+}
+
+//=================================================================================
+static int proc_read_pcm(char *buf, char **start, off_t offset,
+                   int count, int *eof, void *data)
+{
+	int len=0;
+	DEBUG_PRINT("%s:\n",__FUNCTION__);
+	len += sprintf(buf,	"test\n"
+				"test\n"); 
+	*eof = 1;
+	return len;
+}
+
+static int proc_write_pcm(struct file *file, const char *buffer, unsigned long count, void *data){
+	int len=0;
+	DEBUG_PRINT("%s: count=%ld\n",__FUNCTION__,count);
+	pcm_init();
+
+	return count;
+	//is buffer free?
+	if(txpos!=txlen){
+		printk("%s: buffer not free\n",__FUNCTION__);
+		return -EBUSY;
+	}
+
+	//copy the raw data to local buffer	
+	if(count>BUFFER_SIZE) len=BUFFER_SIZE;
+	else len=count;
+	
+	if(copy_from_user(txbuffer,buffer,len)){
+		return -EFAULT;	
+	}
+	txlen=len;
+	txpos=0;
+
+	//Initialization	
+
+	// Enable CPU interrupt
+	local_irq_enable();
+	
+	/*
+	 * Note DMA must be enabled first before PCM is enabled
+	 */
+	HAL_DMAC_ENABLE();
+
+
+	while (1){
+		local_irq_disable();
+		if (txpos>txlen||txlen==0){
+			// Disable PCM
+			
+			break;
+		}
+		local_irq_enable();
+	}
+	DEBUG_PRINT("%s: exit. \n",__FUNCTION__);
+
+	local_irq_enable();
+
+	return len;
+
+//debug:
+	
+//	return count;
+}
+
+static void __exit pcm_exit_module(void){
+	printk("%s:\n",__FUNCTION__);
+	remove_proc_entry("str8100/pcm", NULL);
+	free_irq(INTC_PCM_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_TC_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_ERROR_BIT_INDEX, NULL);
+/*	if(txbuffer) {
+		pci_free_consistent(NULL, BUFFER_SIZE*4, txbuffer, txbuffer_p);
+		txbuffer=txbuffer_p=NULL;
+	}
+*/
+#if 1
+	if(buffer0) {
+		pci_free_consistent(NULL, BUFFER_SIZE*4, buffer0, *buffer_p0);
+		buffer0=buffer_p0=NULL;
+	}
+
+	if(buffer1) {
+		pci_free_consistent(NULL, BUFFER_SIZE*4, buffer1, *buffer_p1);
+		buffer1=buffer_p1=NULL;
+	}
+	if(buffer2) {
+		pci_free_consistent(NULL, BUFFER_SIZE*4, buffer2, *buffer_p2);
+		buffer2=buffer_p2=NULL;
+	}
+
+	if(buffer3) {
+		pci_free_consistent(NULL, BUFFER_SIZE*4, buffer3, *buffer_p3);
+		buffer3=buffer_p3=NULL;
+	}
+#else
+	printk("%s:buffers not freed yet!!!\n",__FUNCTION__);
+#endif	
+}
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+static int __init pcm_init_module(void)
+{
+	
+	u32 ret;
+	
+	printk("%s:\n",__FUNCTION__);
+
+	star_pcm_proc_entry = create_proc_entry("str8100/pcm", S_IFREG | S_IRUGO, NULL);
+	if(!star_pcm_proc_entry){
+		return -EBUSY;
+	}
+	star_pcm_proc_entry->read_proc=proc_read_pcm;
+	star_pcm_proc_entry->write_proc=proc_write_pcm;
+	
+/*
+	txbuffer = pci_alloc_consistent(NULL, BUFFER_SIZE, &txbuffer_p);
+	if(!txbuffer){
+		printk("%s: alloc txbuffer failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+*/
+	buffer0 = pci_alloc_consistent(NULL, BUFFER_SIZE*4, &buffer_p0);
+	if(!buffer0){
+		printk("%s: alloc buffer0 failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	buffer1 = pci_alloc_consistent(NULL, BUFFER_SIZE*4, &buffer_p1);
+	if(!buffer1){
+		printk("%s: alloc buffer1 failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	buffer2 = pci_alloc_consistent(NULL, BUFFER_SIZE*4, &buffer_p2);
+	if(!buffer2){
+		printk("%s: alloc buffer2 failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	buffer3 = pci_alloc_consistent(NULL, BUFFER_SIZE*4, &buffer_p3);
+	if(!buffer3){
+		printk("%s: alloc buffer3 failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+	DEBUG_PRINT("%s: buffers allocated... \n",__FUNCTION__);
+
+	pcm_rx0_buffer_le88221=buffer0;
+	pcm_tx0_buffer_le88221=buffer1;
+	//pcm_rx1_buffer_le88221=buffer2;
+	//pcm_tx1_buffer_le88221=buffer3;
+	
+	pcm_rx0_buffer_le88221_p=buffer_p0;
+	pcm_tx0_buffer_le88221_p=buffer_p1;
+	//pcm_rx1_buffer_le88221_p=buffer_p2;
+	//pcm_tx1_buffer_le88221_p=buffer_p3;
+/*
+	str8100_set_interrupt_trigger (INTC_PCM_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);
+	if((ret=request_irq(INTC_PCM_BIT_INDEX, str8100_pcm_irq_handler, 0, "pcm", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_PCM_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+*/
+	str8100_set_interrupt_trigger (INTC_GDMAC_TC_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_TC_BIT_INDEX, str8100_dma_tc_irq_handler, 0, "dma tc", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_TC_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+	str8100_set_interrupt_trigger (INTC_GDMAC_ERROR_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_ERROR_BIT_INDEX, str8100_dma_err_irq_handler, 0, "dma error", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_ERROR_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+	kernel_thread(swap_buffer_thread, NULL, CLONE_KERNEL);
+
+	//pcm_init();
+
+	return 0;
+exit1:
+	//pcm_exit_module();
+	return -EBUSY;
+}
+
+module_init(pcm_init_module);
+module_exit(pcm_exit_module);
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_dma.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_dma.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_dma.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_dma.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,878 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <mach/star_intc.h>
+#include <mach/star_dmac.h>
+
+//#define DMA_DEBUG
+//#define STR8100_DMA_TEST
+
+#define DMA_CHANNEL_MAX_ID		6 // channel 0 ~ 6
+
+#define DMA_XFER_MAX_Q_LEN		32
+#define DMA_BUSY_MAX_Q_LEN		7
+
+#define ADDR_16BIT_ALIGN_MASK		0x1
+#define ADDR_32BIT_ALIGN_MASK		0x3
+
+#define DMA_LEN_SHIFT_8BIT_WIDTH	0
+#define DMA_LEN_SHIFT_16BIT_WIDTH	1
+#define DMA_LEN_SHIFT_32BIT_WIDTH	2
+#define DMA_MAX_LEN_8BIT_WIDTH		0xfff
+#define DMA_MAX_LEN_16BIT_WIDTH		(0xfff << 1)
+#define DMA_MAX_LEN_32BIT_WIDTH		(0xfff << 2)
+
+#define DMA_COPY_BUSY_WAIT_CHANNEL	7
+#define DMA_COPY_BUSY_WAIT_LOOP		1000
+
+static u32 dma_burst_size = DMAC_CH_SRC_BURST_SIZE_32;
+
+#define DEFAULT_CH_PRIORITY		DMAC_CH_PRIORITY_3
+#define DEFAULT_CH_BURST_SIZE		DMAC_CH_SRC_BURST_SIZE_128
+#define DEFAULT_CH_SRC_WIDTH		DMAC_CH_SRC_WIDTH_8BIT
+#define DEFAULT_CH_DST_WIDTH		DMAC_CH_SRC_WIDTH_8BIT
+#define DEFAULT_CH_MODE			DMAC_CH_MODE_NORMAL
+#define DEFAULT_CH_SRC_ADDR_CTL		DMAC_CH_SRC_ADDR_CTL_INC
+#define DEFAULT_CH_DST_ADDR_CTL		DMAC_CH_DST_ADDR_CTL_INC
+#define DEFAULT_CH_DST_SEL		DMAC_DST_SEL_MASTER0
+#define DEFAULT_CH_SRC_SEL		DMAC_SRC_SEL_MASTER0
+
+#define DEFAULT_DMA_CH_CTL \
+	((0xf				<< DMAC_CH_HHST_SEL_BIT_INDEX) | \
+	 (DEFAULT_CH_PRIORITY		<< DMAC_CH_PRIORITY_BIT_INDEX) | \
+	 (DEFAULT_CH_BURST_SIZE		<< DMAC_CH_SRC_BURST_SIZE_BIT_INDEX) | \
+	 (DEFAULT_CH_SRC_WIDTH		<< DMAC_CH_SRC_WIDTH_BIT_INDEX) | \
+	 (DEFAULT_CH_DST_WIDTH		<< DMAC_CH_DST_WIDTH_BIT_INDEX) | \
+	 (DEFAULT_CH_MODE		<< DMAC_CH_MODE_BIT_INDEX) | \
+	 (DEFAULT_CH_SRC_ADDR_CTL	<< DMAC_CH_SRC_ADDR_CTL_BIT_INDEX) | \
+	 (DEFAULT_CH_DST_ADDR_CTL	<< DMAC_CH_DST_ADDR_CTL_BIT_INDEX) | \
+	 (DEFAULT_CH_DST_SEL		<< DMAC_CH_DST_SEL_BIT_INDEX) | \
+	 (DEFAULT_CH_SRC_SEL		<< DMAC_CH_SRC_SEL_BIT_INDEX))
+
+#define DMA_CH_CTL_8BIT_WIDTH \
+	((0xf				<< DMAC_CH_HHST_SEL_BIT_INDEX) | \
+	 (DMAC_CH_PRIORITY_3		<< DMAC_CH_PRIORITY_BIT_INDEX) | \
+	 (dma_burst_size		<< DMAC_CH_SRC_BURST_SIZE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_WIDTH_8BIT	<< DMAC_CH_SRC_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_DST_WIDTH_8BIT	<< DMAC_CH_DST_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_MODE_NORMAL		<< DMAC_CH_MODE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_ADDR_CTL_INC	<< DMAC_CH_SRC_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_CH_DST_ADDR_CTL_INC	<< DMAC_CH_DST_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_DST_SEL_MASTER0		<< DMAC_CH_DST_SEL_BIT_INDEX) | \
+	 (DMAC_SRC_SEL_MASTER1		<< DMAC_CH_SRC_SEL_BIT_INDEX))
+
+#define DMA_CH_CTL_16BIT_WIDTH \
+	((0xf				<< DMAC_CH_HHST_SEL_BIT_INDEX) | \
+	 (DMAC_CH_PRIORITY_3		<< DMAC_CH_PRIORITY_BIT_INDEX) | \
+	 (dma_burst_size		<< DMAC_CH_SRC_BURST_SIZE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_WIDTH_16BIT	<< DMAC_CH_SRC_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_DST_WIDTH_16BIT	<< DMAC_CH_DST_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_MODE_NORMAL		<< DMAC_CH_MODE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_ADDR_CTL_INC	<< DMAC_CH_SRC_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_CH_DST_ADDR_CTL_INC	<< DMAC_CH_DST_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_DST_SEL_MASTER0		<< DMAC_CH_DST_SEL_BIT_INDEX) | \
+	 (DMAC_SRC_SEL_MASTER1		<< DMAC_CH_SRC_SEL_BIT_INDEX))
+
+
+#define DMA_CH_CTL_32BIT_WIDTH \
+	((0xf				<< DMAC_CH_HHST_SEL_BIT_INDEX) | \
+	 (DMAC_CH_PRIORITY_3		<< DMAC_CH_PRIORITY_BIT_INDEX) | \
+	 (dma_burst_size		<< DMAC_CH_SRC_BURST_SIZE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_WIDTH_32BIT	<< DMAC_CH_SRC_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_DST_WIDTH_32BIT	<< DMAC_CH_DST_WIDTH_BIT_INDEX) | \
+	 (DMAC_CH_MODE_NORMAL		<< DMAC_CH_MODE_BIT_INDEX) | \
+	 (DMAC_CH_SRC_ADDR_CTL_INC	<< DMAC_CH_SRC_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_CH_DST_ADDR_CTL_INC	<< DMAC_CH_DST_ADDR_CTL_BIT_INDEX) | \
+	 (DMAC_DST_SEL_MASTER0		<< DMAC_CH_DST_SEL_BIT_INDEX) | \
+	 (DMAC_SRC_SEL_MASTER1		<< DMAC_CH_SRC_SEL_BIT_INDEX))
+
+typedef struct
+{
+	struct list_head	lh;
+	dma_xfer_t		*xfer;
+	dma_llp_descr_t		*llp_descr;
+	u32			llp_descr_dma;
+	int			done_status;
+} dma_job_t;
+
+
+static u8 dma_dev;
+static spinlock_t dma_lock;
+static u8 dma_busy;
+static u8 dma_busy_q_len;
+static unsigned int dma_xfer_q_len;
+static unsigned int dma_done_q_len;
+static struct list_head dma_xfer_q;
+static struct list_head dma_done_q;
+static dma_job_t *dma_running_job[DMA_CHANNEL_MAX_ID + 1];
+
+static void *dma_mem_pool;
+static u32 dma_mem_pool_dma;
+
+static dma_job_t dma_job_pool[DMA_XFER_MAX_Q_LEN];
+static struct list_head dma_job_q;
+static spinlock_t dma_job_q_lock;
+
+static void dma_process_xfer_job(void *data);
+static void dma_process_done_job(void *data);
+
+// Eileen , for linux kernel 2.6.24 , 20080424
+//old : static DECLARE_WORK(dma_xfer_task, dma_process_xfer_job, (void *)&dma_xfer_q);
+//old : static DECLARE_WORK(dma_done_task, dma_process_done_job, (void *)&dma_done_q);
+static DECLARE_WORK(dma_xfer_task, dma_process_xfer_job);
+static DECLARE_WORK(dma_done_task, dma_process_done_job);
+
+static int dma_job_q_init(void)
+{
+	int i;
+
+	dma_mem_pool = (void *)pci_alloc_consistent(NULL,
+		(DMA_XFER_MAX_Q_LEN * MAX_DMA_VEC * sizeof(dma_llp_descr_t)),
+	       	&dma_mem_pool_dma);
+
+	if (dma_mem_pool == NULL) {
+		return -1;
+	}
+
+	INIT_LIST_HEAD(&dma_job_q);
+	for (i = 0; i < DMA_XFER_MAX_Q_LEN; i++) {
+		INIT_LIST_HEAD(&dma_job_pool[i].lh);
+		dma_job_pool[i].llp_descr = (dma_llp_descr_t *)(dma_mem_pool + (i * (MAX_DMA_VEC * sizeof(dma_llp_descr_t))));
+		dma_job_pool[i].llp_descr_dma = dma_mem_pool_dma + (i * (MAX_DMA_VEC * sizeof(dma_llp_descr_t)));
+		list_add_tail(&dma_job_pool[i].lh, &dma_job_q);
+	}
+
+	return 0;
+}
+
+static dma_job_t *dma_job_alloc(void)
+{
+	dma_job_t *job;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dma_job_q_lock, flags);
+	if (list_empty(&dma_job_q)) {
+		job = NULL;
+	} else {
+		job = list_entry(dma_job_q.next, dma_job_t, lh);
+		list_del_init(&job->lh);
+	}
+	spin_unlock_irqrestore(&dma_job_q_lock, flags);
+
+	return job;
+}
+
+static void dma_job_free(dma_job_t *job)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dma_job_q_lock, flags);
+	list_add(&job->lh, &dma_job_q);
+	spin_unlock_irqrestore(&dma_job_q_lock, flags);
+}
+
+#ifdef DMA_DEBUG
+void dma_dump_reg(void)
+{
+	printk("DMAC_BASE_ADDR+0x000: 0x%08x\n", DMAC_INT_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x004: 0x%08x\n", DMAC_INT_TC_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x008: 0x%08x\n", DMAC_INT_TC_STATUS_CLR_REG);
+	printk("DMAC_BASE_ADDR+0x00C: 0x%08x\n", DMAC_INT_ERR_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x010: 0x%08x\n", DMAC_INT_ERR_STATUS_CLR_REG);
+	printk("DMAC_BASE_ADDR+0x014: 0x%08x\n", DMAC_TC_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x018: 0x%08x\n", DMAC_ERR_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x01C: 0x%08x\n", DMAC_CH_ENABLE_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x020: 0x%08x\n", DMAC_CH_BUSY_STATUS_REG);
+	printk("DMAC_BASE_ADDR+0x024: 0x%08x\n", DMAC_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x028: 0x%08x\n", DMAC_SYNC_REG);
+	printk("DMAC_BASE_ADDR+0x100: 0x%08x\n", DMAC_CH0_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x104: 0x%08x\n", DMAC_CH0_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x108: 0x%08x\n", DMAC_CH0_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x10C: 0x%08x\n", DMAC_CH0_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x110: 0x%08x\n", DMAC_CH0_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x114: 0x%08x\n", DMAC_CH0_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x120: 0x%08x\n", DMAC_CH1_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x124: 0x%08x\n", DMAC_CH1_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x128: 0x%08x\n", DMAC_CH1_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x12C: 0x%08x\n", DMAC_CH1_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x130: 0x%08x\n", DMAC_CH1_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x134: 0x%08x\n", DMAC_CH1_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x140: 0x%08x\n", DMAC_CH2_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x144: 0x%08x\n", DMAC_CH2_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x148: 0x%08x\n", DMAC_CH2_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x14C: 0x%08x\n", DMAC_CH2_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x150: 0x%08x\n", DMAC_CH2_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x154: 0x%08x\n", DMAC_CH2_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x160: 0x%08x\n", DMAC_CH3_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x164: 0x%08x\n", DMAC_CH3_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x168: 0x%08x\n", DMAC_CH3_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x16C: 0x%08x\n", DMAC_CH3_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x170: 0x%08x\n", DMAC_CH3_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x174: 0x%08x\n", DMAC_CH3_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x180: 0x%08x\n", DMAC_CH4_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x184: 0x%08x\n", DMAC_CH4_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x188: 0x%08x\n", DMAC_CH4_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x18C: 0x%08x\n", DMAC_CH4_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x190: 0x%08x\n", DMAC_CH4_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x194: 0x%08x\n", DMAC_CH4_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x1A0: 0x%08x\n", DMAC_CH5_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x1A4: 0x%08x\n", DMAC_CH5_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x1A8: 0x%08x\n", DMAC_CH5_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1AC: 0x%08x\n", DMAC_CH5_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1B0: 0x%08x\n", DMAC_CH5_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x1B4: 0x%08x\n", DMAC_CH5_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x1C0: 0x%08x\n", DMAC_CH6_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x1C4: 0x%08x\n", DMAC_CH6_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x1C8: 0x%08x\n", DMAC_CH6_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1CC: 0x%08x\n", DMAC_CH6_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1D0: 0x%08x\n", DMAC_CH6_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x1D4: 0x%08x\n", DMAC_CH6_SIZE_REG);
+	printk("DMAC_BASE_ADDR+0x1E0: 0x%08x\n", DMAC_CH7_CSR_REG);
+	printk("DMAC_BASE_ADDR+0x1E4: 0x%08x\n", DMAC_CH7_CFG_REG);
+	printk("DMAC_BASE_ADDR+0x1E8: 0x%08x\n", DMAC_CH7_SRC_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1EC: 0x%08x\n", DMAC_CH7_DST_ADDR_REG);
+	printk("DMAC_BASE_ADDR+0x1F0: 0x%08x\n", DMAC_CH7_LLP_REG);
+	printk("DMAC_BASE_ADDR+0x1F4: 0x%08x\n", DMAC_CH7_SIZE_REG);
+}
+#endif
+
+static inline void dma_copy_busy_wait(void *dst, const void *src, size_t len, unsigned long dma_len_shift)
+{
+	int err = 0;
+	int i;
+
+	len = (len >> dma_len_shift);
+
+	while ((DMAC_CH_BUSY_STATUS_REG & 0xFF) & (1 << DMA_COPY_BUSY_WAIT_CHANNEL)) {
+		udelay(1);
+	}
+
+	DMAC_CH_SRC_ADDR_REG(DMA_COPY_BUSY_WAIT_CHANNEL)	= (u32)virt_to_phys((void *)src);
+	DMAC_CH_DST_ADDR_REG(DMA_COPY_BUSY_WAIT_CHANNEL)	= (u32)virt_to_phys((void *)dst);
+	DMAC_CH_SIZE_REG(DMA_COPY_BUSY_WAIT_CHANNEL)		= (u32)len;
+
+#ifdef DMA_DEBUG
+	dma_dump_reg();
+#endif
+
+	// enable the channel
+	DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) |= 0x1;
+
+	for (i = 0; i < DMA_COPY_BUSY_WAIT_LOOP; i++) {
+		if (DMAC_TC_STATUS_REG & (1 << DMA_COPY_BUSY_WAIT_CHANNEL)) {
+			break;
+		}
+		if (DMAC_ERR_STATUS_REG & (1 << DMA_COPY_BUSY_WAIT_CHANNEL)) {
+			err = 1;
+			break;
+		}
+		udelay(1);
+	}
+
+	// disable the channel
+	DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) &= ~0x1;
+
+	if (err || (i == DMA_COPY_BUSY_WAIT_LOOP)) {
+		if (err) {
+			// clear the ERROR status
+			DMAC_INT_ERR_STATUS_CLR_REG |= (1 << DMA_COPY_BUSY_WAIT_CHANNEL);
+		}
+		memcpy(dst, src, (len << dma_len_shift));
+	} else {
+		// clear the TC status
+		DMAC_INT_TC_STATUS_CLR_REG |= (1 << DMA_COPY_BUSY_WAIT_CHANNEL);
+	}
+}
+
+void dma_memcpy_busy_wait(void *dst, const void *src, size_t len)
+{
+	void *pdst = dst;
+	const void *psrc = src;
+	unsigned long dma_len_shift;
+	unsigned long dma_max_len;
+	unsigned long flags;
+
+#ifdef DMA_DEBUG
+	printk("dst: 0x%08x\n", (u32)dst);
+	printk("src: 0x%08x\n", (u32)src);
+	printk("len: 0x%08x\n", (u32)len);
+	printk("pdst: 0x%08x\n", (u32)pdst);
+	printk("psrc: 0x%08x\n", (u32)psrc);
+#endif
+
+	local_irq_save(flags);
+	
+	// Eileen , for linux kernel 2.6.24 , 20080424
+	// old : consistent_sync((void *)src, len, PCI_DMA_TODEVICE);
+	// old : consistent_sync((void *)dst, len, PCI_DMA_FROMDEVICE);
+	dma_cache_maint((void *)src, len, PCI_DMA_TODEVICE);
+	dma_cache_maint((void *)dst, len, PCI_DMA_FROMDEVICE);
+
+	if ((((u32)psrc & ADDR_32BIT_ALIGN_MASK) == 0) &&
+		(((u32)pdst & ADDR_32BIT_ALIGN_MASK) == 0) &&
+		((len & 3) == 0)) {
+		dma_len_shift = DMA_LEN_SHIFT_32BIT_WIDTH;
+		dma_max_len = DMA_MAX_LEN_32BIT_WIDTH;
+		DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) = DMA_CH_CTL_32BIT_WIDTH;
+	} else if ((((u32)psrc & ADDR_16BIT_ALIGN_MASK) == 0) &&
+		(((u32)pdst & ADDR_16BIT_ALIGN_MASK) == 0) &&
+		((len & 1) == 0)) {
+		dma_len_shift = DMA_LEN_SHIFT_16BIT_WIDTH;
+		dma_max_len = DMA_MAX_LEN_16BIT_WIDTH;
+		DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) = DMA_CH_CTL_16BIT_WIDTH;
+	} else {
+		dma_len_shift = DMA_LEN_SHIFT_8BIT_WIDTH;
+		dma_max_len = DMA_MAX_LEN_8BIT_WIDTH;
+		DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) = DMA_CH_CTL_8BIT_WIDTH;
+	}
+
+	while (len) {
+		if (len > dma_max_len) {
+			dma_copy_busy_wait(pdst, psrc, dma_max_len, dma_len_shift);
+			pdst += dma_max_len;
+			psrc += dma_max_len;
+			len -= dma_max_len;
+		} else {
+			dma_copy_busy_wait(pdst, psrc, len, dma_len_shift);
+			len = 0;
+		}
+	}
+
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(dma_memcpy_busy_wait);
+
+void dma_copy(dma_xfer_t *dma_xfer)
+{
+	dma_job_t *dma_job;
+	u32 size_shift = 0;
+	unsigned long flags;
+	int i;
+
+	if (dma_xfer_q_len > DMA_XFER_MAX_Q_LEN) {
+		dma_xfer->dma_end_io(dma_xfer, DMAC_RESPONSE_ERR);
+		return;
+	}
+
+	dma_job = dma_job_alloc();
+	if (dma_job == NULL) {
+		dma_xfer->dma_end_io(dma_xfer, DMAC_RESPONSE_ERR);
+		return;
+	}
+
+	memset(dma_job->llp_descr, 0, (dma_xfer->nr_vec * sizeof(dma_llp_descr_t)));
+	for (i = 0; i < dma_xfer->nr_vec; i++) {
+		// Eileen , for linux kernel 2.6.24 , 20080424
+		//old : consistent_sync((void *)dma_xfer->vec[i].src_addr, dma_xfer->vec[i].size, PCI_DMA_TODEVICE);
+		//old : consistent_sync((void *)dma_xfer->vec[i].dst_addr, dma_xfer->vec[i].size, PCI_DMA_FROMDEVICE);
+		dma_cache_maint((void *)dma_xfer->vec[i].src_addr, dma_xfer->vec[i].size, PCI_DMA_TODEVICE);
+		dma_cache_maint((void *)dma_xfer->vec[i].dst_addr, dma_xfer->vec[i].size, PCI_DMA_FROMDEVICE);
+		dma_job->llp_descr[i].src_addr = (u32)virt_to_phys((void *)dma_xfer->vec[i].src_addr);
+		dma_job->llp_descr[i].dst_addr = (u32)virt_to_phys((void *)dma_xfer->vec[i].dst_addr);
+		dma_job->llp_descr[i].dst_sel = dma_xfer->vec[i].dst_sel;
+		dma_job->llp_descr[i].src_sel = dma_xfer->vec[i].src_sel;
+		dma_job->llp_descr[i].dst_addr_ctl = dma_xfer->vec[i].dst_sel;
+		dma_job->llp_descr[i].src_addr_ctl = dma_xfer->vec[i].src_sel;
+		dma_job->llp_descr[i].dst_width = dma_xfer->vec[i].dst_width;
+		dma_job->llp_descr[i].src_width = dma_xfer->vec[i].src_width;
+		if (dma_xfer->vec[i].src_width == DMAC_CH_DST_WIDTH_32BIT) {
+			size_shift = 2;
+		} else if (dma_xfer->vec[i].src_width == DMAC_CH_DST_WIDTH_16BIT) {
+			size_shift = 1;
+		} else {
+			size_shift = 0;
+		}
+		dma_job->llp_descr[i].tot_size = (dma_xfer->vec[i].size >> size_shift) & 0xFFF;
+		if (i == (dma_xfer->nr_vec - 1)) {
+			dma_job->llp_descr[i].llp = 0;
+			dma_job->llp_descr[i].tc_mask = 0;
+		} else {
+			dma_job->llp_descr[i].llp = (u32)(dma_job->llp_descr_dma + ((i + 1) * sizeof(dma_llp_descr_t)));
+			dma_job->llp_descr[i].tc_mask = 1;
+		}
+#ifdef DMA_DEBUG
+		printk("in src_addr:  0x%08x\n", dma_xfer->vec[i].src_addr);
+		printk("in dst_addr:  0x%08x\n", dma_xfer->vec[i].dst_addr);
+		printk("src_addr:     0x%08x\n", dma_job->llp_descr[i].src_addr);
+		printk("dst_addr:     0x%08x\n", dma_job->llp_descr[i].dst_addr);
+		printk("llp:          0x%08x\n", dma_job->llp_descr[i].llp);
+		printk("tot_size:     0x%08x\n", dma_job->llp_descr[i].tot_size);
+		printk("dst_sel:      0x%08x\n", dma_job->llp_descr[i].dst_sel);
+		printk("src_sel:      0x%08x\n", dma_job->llp_descr[i].src_sel);
+		printk("dst_addr_ctl: 0x%08x\n", dma_job->llp_descr[i].dst_addr_ctl);
+		printk("src_addr_ctl: 0x%08x\n", dma_job->llp_descr[i].src_addr_ctl);
+		printk("dst_width:    0x%08x\n", dma_job->llp_descr[i].dst_width);
+		printk("src_width:    0x%08x\n", dma_job->llp_descr[i].src_width);
+		printk("tc_mask:      0x%08x\n", dma_job->llp_descr[i].tc_mask);
+#endif
+	}
+
+	dma_job->xfer = dma_xfer;
+	dma_job->done_status = 0;
+
+	spin_lock_irqsave(&dma_lock, flags);
+	list_add_tail(&dma_job->lh, &dma_xfer_q);
+	dma_xfer_q_len++;
+	spin_unlock_irqrestore(&dma_lock, flags);
+
+	if (!dma_busy) {
+		schedule_work(&dma_xfer_task);
+	}
+}
+EXPORT_SYMBOL(dma_copy);
+
+static void dma_process_xfer_job(void *data)
+{
+	struct list_head *l, *t;
+	dma_job_t *dma_job;
+	unsigned long csr_reg;
+	int i;
+	unsigned long flags;
+
+	if (dma_busy) {
+		return;
+	}
+
+	spin_lock_irqsave(&dma_lock, flags);
+	list_for_each_safe(l, t, &dma_xfer_q) {
+		dma_job = list_entry(l, dma_job_t, lh);
+		for (i = 0; i <= 6; i++) {
+			if (dma_running_job[i] != NULL) {
+				continue;
+			}
+			printk("Insert dma xfer to channel(%d)\n", i);
+			list_del_init(&dma_job->lh);
+			dma_running_job[i] = dma_job;
+			dma_xfer_q_len--;
+			dma_busy_q_len++;
+			csr_reg = DMAC_CH_CSR_REG(i);
+			if (dma_job->llp_descr[0].tc_mask) {
+				csr_reg |= (1 << 31);
+			} else {
+				csr_reg &= ~(1 << 31);
+			}
+			csr_reg &= ~(DMAC_CH_SRC_WIDTH_MASK << DMAC_CH_SRC_WIDTH_BIT_INDEX);
+			csr_reg &= ~(DMAC_CH_DST_WIDTH_MASK << DMAC_CH_DST_WIDTH_BIT_INDEX);
+			csr_reg &= ~(DMAC_CH_SRC_ADDR_CTL_MASK << DMAC_CH_SRC_ADDR_CTL_BIT_INDEX);
+			csr_reg &= ~(DMAC_CH_DST_ADDR_CTL_MASK << DMAC_CH_DST_ADDR_CTL_BIT_INDEX);
+			csr_reg |=
+				((dma_job->llp_descr[0].src_width << DMAC_CH_SRC_WIDTH_BIT_INDEX) |
+				 (dma_job->llp_descr[0].dst_width << DMAC_CH_DST_WIDTH_BIT_INDEX) |
+				 (dma_job->llp_descr[0].src_addr_ctl << DMAC_CH_SRC_ADDR_CTL_BIT_INDEX) |
+				 (dma_job->llp_descr[0].dst_addr_ctl << DMAC_CH_DST_ADDR_CTL_BIT_INDEX) |
+				 (dma_job->llp_descr[0].src_sel << DMAC_CH_SRC_SEL_BIT_INDEX) |
+				 (dma_job->llp_descr[0].dst_sel << DMAC_CH_DST_SEL_BIT_INDEX));
+			DMAC_CH_CSR_REG(i) = csr_reg;
+
+#if 0
+			if (dma_job->llp_descr[0].tc_mask) {
+				DMAC_CH_CFG_REG(i) |= 0x1;
+			} else {
+				DMAC_CH_CFG_REG(i) &= ~0x1;
+			}
+#endif
+
+			DMAC_CH_SRC_ADDR_REG(i) = dma_job->llp_descr[0].src_addr;
+			DMAC_CH_DST_ADDR_REG(i) = dma_job->llp_descr[0].dst_addr;
+			DMAC_CH_LLP_REG(i) = dma_job->llp_descr[0].llp;
+			DMAC_CH_SIZE_REG(i) = dma_job->llp_descr[0].tot_size;
+			HAL_DMAC_ENABLE_CHANNEL(i);
+			break;
+#ifdef DMA_DEBUG
+			//dma_dump_reg();
+#endif
+		}
+		if (dma_busy_q_len == DMA_BUSY_MAX_Q_LEN) {
+			dma_busy = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dma_lock, flags);
+}
+
+static void dma_process_done_job(void *data)
+{
+	dma_job_t *dma_job;
+	struct list_head *l, *t;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dma_lock, flags);
+	list_for_each_safe(l, t, &dma_done_q) {
+		dma_job = list_entry(l, dma_job_t, lh);
+		list_del_init(&dma_job->lh);
+		dma_done_q_len--;
+		spin_unlock_irqrestore(&dma_lock, flags);
+		dma_job->xfer->dma_end_io(dma_job->xfer, dma_job->done_status);
+		dma_job_free(dma_job);
+		spin_lock_irqsave(&dma_lock, flags);
+	}
+	spin_unlock_irqrestore(&dma_lock, flags);
+}
+// Eileen , for linux kernel 2.6.24 , 20080424
+//old : irqreturn_t dma_tc_isr(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t dma_tc_isr(int irq, void *dev_id)
+{
+	dma_job_t *dma_job;
+	u32 tc_status;
+	int i;
+
+	tc_status = DMAC_INT_TC_STATUS_REG;
+
+	for (i = 0; i <= 6; i++) {
+		if (tc_status & (1 << i)) {
+			HAL_DMAC_DISABLE_CHANNEL(i);
+			dma_job = dma_running_job[i];
+			if (dma_job) {
+				dma_running_job[i] = NULL;
+				dma_job->done_status = DMAC_RESPONSE_OK;
+				list_add_tail(&dma_job->lh, &dma_done_q);
+				dma_done_q_len++;
+				dma_busy_q_len--;
+				if (dma_busy) {
+					dma_busy = 0;
+				}
+				schedule_work(&dma_done_task);
+				if (dma_xfer_q_len) {
+					schedule_work(&dma_xfer_task);
+				}
+			}
+			DMAC_INT_TC_STATUS_CLR_REG |= (1 << i);
+			break;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+// Eileen ,for linux kernel 2.6.24 , 20080424
+//irqreturn_t dma_err_isr(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t dma_err_isr(int irq, void *dev_id)
+{
+	dma_job_t *dma_job;
+	u32 err_status;
+	int i;
+
+	err_status = DMAC_INT_ERR_STATUS_REG;
+
+	for (i = 0; i <= 6; i++) {
+		if (err_status & (1 << i)) {
+			HAL_DMAC_DISABLE_CHANNEL(i);
+			dma_job = dma_running_job[i];
+			if (dma_job) {
+				dma_running_job[i] = NULL;
+				dma_job->done_status = DMAC_RESPONSE_ERR;
+				list_add_tail(&dma_job->lh, &dma_done_q);
+				dma_done_q_len++;
+				dma_busy_q_len--;
+				if (dma_busy) {
+					dma_busy = 0;
+				}
+				schedule_work(&dma_done_task);
+				if (dma_xfer_q_len) {
+					schedule_work(&dma_xfer_task);
+				}
+			}
+			DMAC_INT_ERR_STATUS_CLR_REG |= (1 << i);
+			break;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+void dma_channel_init(void)
+{
+	int i;
+
+	// disable the channel
+	DMAC_CH_CSR_REG(DMA_COPY_BUSY_WAIT_CHANNEL) &= ~0x1;
+	DMAC_CH_CFG_REG(DMA_COPY_BUSY_WAIT_CHANNEL) = 0x7;
+
+	for (i = 0; i <= 6; i++) {
+		HAL_DMAC_DISABLE_CHANNEL(i);
+		DMAC_CH_CSR_REG(i) = DEFAULT_DMA_CH_CTL;
+		DMAC_CH_CFG_REG(i) &= ~0x3;
+	}
+
+	return;
+}
+
+static int dma_init(void)
+{
+	int retval;
+
+	HAL_PWRMGT_ENABLE_DMA_CLOCK();
+
+	// Master0 & Master1 in Little Endian Mode, DMA Controller Enable
+	DMAC_CSR_REG = 0x1;
+
+	if (dma_job_q_init() != 0) {
+		return -EFAULT;
+	}
+
+	dma_channel_init();
+
+#ifdef DMA_DEBUG
+	dma_dump_reg();
+#endif
+
+	spin_lock_init(&dma_lock);
+	INIT_LIST_HEAD(&dma_xfer_q);
+	INIT_LIST_HEAD(&dma_done_q);
+	
+	// Eileen , for linux kernel 2.6.24 , 20080424
+	//retval = request_irq(INTC_GDMAC_TC_BIT_INDEX, &dma_tc_isr, SA_INTERRUPT, "STAR DMA TC ISR", &dma_dev);
+	retval = request_irq(INTC_GDMAC_TC_BIT_INDEX, &dma_tc_isr, IRQF_DISABLED, "STAR DMA TC ISR", &dma_dev);
+	if (retval) {
+		printk("%s: unable to get IRQ %d (irqval=%d).\n", "STAR DMA", INTC_GDMAC_TC_BIT_INDEX, retval);
+		return retval;
+	}
+	// Eileen , for linux kernel 2.6.24 , 20080424
+	// old : retval = request_irq(INTC_GDMAC_ERROR_BIT_INDEX, &dma_err_isr, SA_INTERRUPT, "STAR DMA ERR ISR", &dma_dev);
+	retval = request_irq(INTC_GDMAC_ERROR_BIT_INDEX, &dma_err_isr, IRQF_DISABLED, "STAR DMA ERR ISR", &dma_dev);
+	if (retval) {
+		printk("%s: unable to get IRQ %d (irqval=%d).\n", "STAR DMA", INTC_GDMAC_ERROR_BIT_INDEX, retval);
+		free_irq(INTC_GDMAC_TC_BIT_INDEX, &dma_dev);
+		return retval;
+	}
+
+	return 0;
+}
+
+// Eileen , for linux kernel 2.6.24 , 20080425
+#ifdef STR8100_DMA_TEST
+	static int str8100_dmacopy_busywait_test(void);
+	static int str8100_dmacopy_llp_test(void);
+#endif
+
+
+static int __init str8100_dma_init(void)
+{
+	int retval;
+
+	printk("STR8100 DMA driver init\n");
+	retval = dma_init();
+#ifdef STR8100_DMA_TEST
+	if (retval == 0) {
+	       	// Eileen , for linux kernel 2.6.24 , 20080425
+		//move : static int str8100_dmacopy_busywait_test(void);
+		//move : static int str8100_dmacopy_llp_test(void);
+		(void)str8100_dmacopy_busywait_test();
+		(void)str8100_dmacopy_llp_test();
+	}
+#endif
+	return retval;
+}
+
+static void __exit str8100_dma_exit(void)
+{
+	return;
+}
+
+module_init(str8100_dma_init);
+module_exit(str8100_dma_exit);
+
+#ifdef STR8100_DMA_TEST
+#define MEMSIZE_K	64
+#define MEMSIZE		(MEMSIZE_K*1024)
+
+static int str8100_dmacopy_busywait_test(void)
+{
+	u8 *src;
+	u8 *dst;
+	int i;
+	int sjiffies;
+	int err_cnt = 0;
+
+	src = kmalloc(MEMSIZE, GFP_KERNEL);
+	if (!src) goto out;
+	dst = kmalloc(MEMSIZE, GFP_KERNEL);
+	if (!dst) {
+		kfree(src);
+		goto out;
+	}
+
+	memset(src, 0xA9, MEMSIZE);
+	memset(dst, 0, MEMSIZE);
+
+	printk("STR8100 DMA Busy Wait Testing...\n");
+
+	sjiffies = jiffies;
+	for (i = 0; i < 1024; i++) {
+		dma_memcpy_busy_wait(dst, src, MEMSIZE);
+	}
+
+	printk("STR8100 DMA Busy Wait Testing end\n");
+	if (memcmp(src, dst, MEMSIZE) == 0) {
+		printk("STR8100 DMA Busy Wait Testing success\n");
+		printk("STR8100 DMA Busy Wait Testing speed: %dMB/s\n", (u32)((MEMSIZE_K) * HZ/(jiffies - sjiffies)));
+	} else {
+		printk("STR8100 DMA Busy Wait Testing failed\n");
+		for (i = 0; i < MEMSIZE; i++) {
+			if (src[i] != dst[i]) {
+				err_cnt++;
+			}
+		}
+		printk("err_cnt: %d\n", err_cnt);
+	}
+
+	kfree(src);
+	kfree(dst);
+
+out:
+	return 0;
+}
+
+#define NUM_DMA_XFER		32
+#define NUM_DMA_VEC		32
+#define NUM_BYTES_PER_VEC	1024
+
+static dma_xfer_t dma_xfer_test[NUM_DMA_XFER];
+static u32 dma_xfer_finished;
+
+static u8 *src_vec[NUM_DMA_XFER];
+static u8 *dst_vec[NUM_DMA_XFER];
+
+extern void dma_copy(dma_xfer_t *dma_xfer);
+extern void dma_dump_reg(void);
+
+static void dma_copy_end(dma_xfer_t *dma_xfer, int err)
+{
+	int i;
+	int idx;
+
+	idx = (int)dma_xfer->private;
+	dma_xfer_finished++;
+
+	if (err) {
+		printk("STR8100 DMA Testing failed!!\n");
+	} else {
+		for (i = 0; i < NUM_DMA_VEC; i++) {
+			if (memcmp((src_vec[idx] + i * NUM_BYTES_PER_VEC), (dst_vec[idx] + i * NUM_BYTES_PER_VEC), NUM_BYTES_PER_VEC) == 0) {
+				printk("STR8100 DMA Testing success on xfer idx:%d started at offset: %04d:\n", idx, i * NUM_BYTES_PER_VEC);
+			} else {
+				int j;
+				u8 *psrc;
+				u8 *pdst;
+
+				psrc = src_vec[idx] + i * NUM_BYTES_PER_VEC;
+				pdst = dst_vec[idx] + i * NUM_BYTES_PER_VEC;
+
+				printk("STR8100 DMA Testing error started at offset: %04d\n", i * NUM_BYTES_PER_VEC);
+
+				for (j = 0; j < NUM_BYTES_PER_VEC; j++) {
+					if ((j % 16) == 0) {
+						printk("\n %08x: ", (u32)(psrc + j));
+					}
+					if (((j % 16) != 0) && ((j % 4) == 0)) {
+						printk(" ");
+					}
+					printk("%02x", psrc[j]);
+				}
+				printk("\n");
+	
+				for (j = 0; j < NUM_BYTES_PER_VEC; j++) {
+					if ((j % 16) == 0) {
+						printk("\n %08x: ", (u32)(pdst + j));
+					}
+					if (((j % 16) != 0) && ((j % 4) == 0)) {
+						printk(" ");
+					}
+					printk("%02x", pdst[j]);
+				}
+				printk("\n");
+			}
+		}
+	}
+
+	if (dma_xfer_finished == NUM_DMA_XFER) {
+		for (i = 0; i < NUM_DMA_XFER; i++) {
+			kfree(src_vec[i]);
+			kfree(dst_vec[i]);
+		}
+	}
+}
+
+static int str8100_dmacopy_llp_test(void)
+{
+	int i, j;
+
+	for (i = 0; i < NUM_DMA_XFER; i++) {
+		src_vec[i] = kmalloc(MEMSIZE, GFP_KERNEL);
+		if (!src_vec[i]) goto err_out;
+		dst_vec[i] = kmalloc(MEMSIZE, GFP_KERNEL);
+		if (!dst_vec[i]) goto err_out;
+		memset(src_vec[i], 0xA9, MEMSIZE);
+		memset(dst_vec[i], 0x00, MEMSIZE);
+		printk("dmacopy_llp src_vec[%d]: 0x%08x\n", i, (u32)src_vec[i]);
+		printk("dmacopy_llp dst_vec[%d]: 0x%08x\n", i, (u32)dst_vec[i]);
+	}
+
+	for (i = 0; i < NUM_DMA_XFER; i++) {
+		dma_xfer_test[i].nr_vec = NUM_DMA_VEC;
+		dma_xfer_test[i].dma_end_io = dma_copy_end;
+		dma_xfer_test[i].private = (void *)i;
+		for (j = 0; j < NUM_DMA_VEC; j++) {
+			dma_xfer_test[i].vec[j].src_addr = (u32)(src_vec[i] + (j * NUM_BYTES_PER_VEC));
+			dma_xfer_test[i].vec[j].dst_addr = (u32)(dst_vec[i] + (j * NUM_BYTES_PER_VEC));
+			dma_xfer_test[i].vec[j].size = NUM_BYTES_PER_VEC;
+			dma_xfer_test[i].vec[j].dst_sel = 0;
+			dma_xfer_test[i].vec[j].src_sel = 0;
+			dma_xfer_test[i].vec[j].dst_addr_ctl = 0;
+			dma_xfer_test[i].vec[j].src_addr_ctl = 0;
+			dma_xfer_test[i].vec[j].dst_width = DMAC_CH_DST_WIDTH_8BIT;
+			dma_xfer_test[i].vec[j].src_width = DMAC_CH_SRC_WIDTH_8BIT;
+		}
+	}
+
+	printk("STR8100 DMA Testing ...\n");
+
+	for (i = 0; i < NUM_DMA_XFER; i++) {
+		dma_copy(&dma_xfer_test[i]);
+	}
+
+	return 0;
+
+err_out:
+	for (i = 0; i < NUM_DMA_XFER; i++) {
+		if (src_vec[i])
+			kfree(src_vec[i]);
+		if (dst_vec[i])
+			kfree(dst_vec[i]);
+	}
+	return 0;
+}
+
+#endif // STR8100_DMA_TEST
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_gpio.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_gpio.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_gpio.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_gpio.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,855 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+#include <mach/star_powermgt.h>
+#include <mach/star_intc.h>
+#include <mach/star_misc.h>
+#include <mach/star_gpio.h>
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+
+#define MAX_GPIOA_LINE		32
+#define MAX_GPIOB_LINE		32
+#define PIN_INPUT 0
+#define PIN_OUTPUT 1
+
+#define PIN_TRIG_EDGE 0
+#define PIN_TRIG_LEVEL 1
+
+#define PIN_TRIG_SINGLE 0
+#define PIN_TRIG_BOTH 1
+
+#define PIN_TRIG_RISING 0
+#define PIN_TRIG_FALLING 1
+
+#define PIN_TRIG_HIGH 0
+#define PIN_TRIG_LOW 1
+void (*gpio_a_isr[MAX_GPIOA_LINE])(int i);
+void (*gpio_b_isr[MAX_GPIOB_LINE])(int i);
+
+#endif
+
+#if 0
+int __init_or_module gpio_direction_input(unsigned int);
+int __init_or_module gpio_direction_output(unsigned int, unsigned int);
+void gpio_set_value(unsigned int, unsigned int);
+int gpio_get_value(unsigned int);
+void str8100_gpio_a_set_edgeintr(void (*funcptr)(int), int, int, int);
+void str8100_gpio_b_set_edgeintr(void (*funcptr)(int),int,int, int);
+void str8100_gpio_a_set_levelintr(void (*funcptr)(int),int, int);
+void str8100_gpio_b_set_levelintr(void (*funcptr)(int),int, int);
+#endif
+
+/* 
+ * str8100_gpio_a_in - read Data Input Register(RO) of GPIO A
+ * @data: the target to store content of register
+ */
+int str8100_gpio_a_datain(volatile __u32 *data)
+{
+	HAL_GPIOA_READ_DATA_IN_STATUS(*data);
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_in - read Data Input Register(RO) of GPIO B
+ * @data: the target to store content of register
+ */
+int str8100_gpio_b_datain(volatile __u32 *data)
+{
+	HAL_GPIOB_READ_DATA_IN_STATUS(*data);
+	return 0;
+}
+
+/* str8100_gpio_a_out - write Data Output Register(RW) of GPIO A
+ * @data:
+ */
+int str8100_gpio_a_dataout(__u32 data)
+{
+	GPIOA_DATA_OUTPUT_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_out - write Data Output Register(RW) of GPIO B
+ * @data:
+ */
+int str8100_gpio_b_out(__u32 data)
+{
+	GPIOB_DATA_OUTPUT_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_a_read_direction - read Direction Register(RW) GPIO A
+ * @data:
+ */
+int str8100_gpio_a_read_direction(volatile __u32 *data)
+{
+	*data = GPIOA_DIRECTION_REG;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_read_direction - read Direction Register(RW) of GPIO B
+ * @data:
+ */
+int str8100_gpio_b_read_direction(volatile __u32 *data)
+{
+	*data = GPIOB_DIRECTION_REG;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_a_write_direction - write Direction Register(RW) of GPIO A
+ * @data:
+ */
+int str8100_gpio_a_write_direction(__u32 data)
+{
+	GPIOA_DIRECTION_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_write_direction - write Direction Register(RW) of GPIO B
+ * @data:
+ */
+int str8100_gpio_b_write_direction(__u32 data)
+{
+	GPIOB_DIRECTION_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_a_dataset - write Data Bit Set Register (W) of GPIO A
+ * @data:
+ *
+ * When write to this register and if some bits of GpioDataSet are 1,
+ * the corresponding bits in GpioDataOut register will be set to 1, 
+ * and the others will not be changed.
+ */
+int str8100_gpio_a_dataset(__u32 data)
+{
+	GPIOA_DATA_BIT_SET_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_dataset - write Data Bit Set Register (W) of GPIO B
+ * @data:
+ */
+int str8100_gpio_b_dataset(__u32 data)
+{
+	GPIOB_DATA_BIT_SET_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_a_dataclear - write Data Bit Clear Register (W) of GPIO A
+ * @data:
+ *
+ * When write to this register and if some bits of GpioDataClear are 1,
+ * the corresponding bits in GpioDataOut register will be cleard, 
+ * and the others will not be changed.
+ */
+int str8100_gpio_a_dataclear(__u32 data)
+{
+	GPIOA_DATA_BIT_CLEAR_REG = data;
+	return 0;
+}
+
+/* 
+ * str8100_gpio_b_dataclear - write Data Bit Clear Register (W) of GPIO B
+ * @data:
+ */
+int str8100_gpio_b_dataclear(__u32 data)
+{
+	GPIOB_DATA_BIT_CLEAR_REG = data;
+	return 0;
+}
+/*
+Read String into Buffer, Max String buffer is 100
+*/
+ssize_t readstring(char *buff, const char *buf, size_t count){
+    	int i=0;
+        if (count) {
+                char c;
+
+            for(i=0;i<count&&i<100;i++){
+                if (get_user(c, buf+i))
+                        return -EFAULT;
+                    buff[i] = c;
+            }
+                buff[i]=0;
+        }
+        return count;
+
+}
+
+#ifdef CONFIG_STR8100_GPIO_GENERIC_INTERFACE
+static int str8100_gpio_proc(char *page, char **start,  off_t off, int count, int *eof, void *data)
+{
+	int num = 0;
+
+	num += sprintf(page+num, "********** GPIO Group A **********\n");
+	
+	num += sprintf(page+num, "GPIO IN                : %08x \n", GPIOA_DATA_INPUT_REG);
+
+	num += sprintf(page+num, "GPIO Direction         : %08x \n", GPIOA_DIRECTION_REG);
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+	num += sprintf(page+num, "GPIO Interrupt Enable  : %08x \n", GPIOA_INTERRUPT_ENABLE_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Raw     : %08x \n", GPIOA_INTERRUPT_RAW_STATUS_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Trigger : %08x \n", GPIOA_INTERRUPT_TRIGGER_METHOD_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Both    : %08x \n", GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt RiseNeg : %08x \n", GPIOA_INTERRUPT_TRIGGER_TYPE_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt MASKED  : %08x \n", GPIOA_INTERRUPT_MASK_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt MASKEDST: %08x \n", GPIOA_INTERRUPT_MASKED_STATUS_REG);
+#endif	
+
+	num+= sprintf(page+num, "********** GPIO Group B **********\n");
+	
+	num += sprintf(page+num, "GPIO IN                : %08x \n", GPIOB_DATA_INPUT_REG);
+
+	num += sprintf(page+num, "GPIO Direction         : %08x \n", GPIOB_DIRECTION_REG);
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+	num += sprintf(page+num, "GPIO Interrupt Enable  : %08x \n", GPIOB_INTERRUPT_ENABLE_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Raw     : %08x \n", GPIOB_INTERRUPT_RAW_STATUS_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Trigger : %08x \n", GPIOB_INTERRUPT_TRIGGER_METHOD_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt Both    : %08x \n", GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt RiseNeg : %08x \n", GPIOB_INTERRUPT_TRIGGER_TYPE_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt MASKED  : %08x \n", GPIOB_INTERRUPT_MASK_REG);
+
+	num += sprintf(page+num, "GPIO Interrupt MASKEDST: %08x \n", GPIOB_INTERRUPT_MASKED_STATUS_REG);
+#endif	
+
+	return num;
+}
+#endif
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+static irqreturn_t str8100_gpio_irq_handler(int this_irq, void *dev_id /*, struct pt_regs *regs */)
+{
+	unsigned int volatile    status;
+	int i;
+
+	// Clean System irq status
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	HAL_GPIOA_READ_INTERRUPT_MASKED_STATUS(status);
+	for (i = 0; i < MAX_GPIOA_LINE; i++) {   
+		if (status & (1 << i))  {   		/* interrupt is detected and not masked */
+			if (gpio_a_isr[i] != NULL) {
+				gpio_a_isr[i](i);
+			}
+		}    
+	}  
+    HAL_GPIOA_CLEAR_INTERRUPT(status);
+
+	HAL_GPIOB_READ_INTERRUPT_MASKED_STATUS(status);
+	for (i = 0; i < MAX_GPIOB_LINE; i++) {   
+		if (status & (1 << i)) {			/* interrupt is detected and not masked */
+			if (gpio_b_isr[i] != NULL) {
+				gpio_b_isr[i](i);
+			}
+		}    
+	}   
+    HAL_GPIOB_CLEAR_INTERRUPT(status);
+
+	/* Unmask Intc Interrupt Status */
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	return IRQ_HANDLED;
+}
+
+int intr_a_count=0;
+int intr_b_count=0;
+/*  
+ * Setup GPIOA for Edge Trigger Interrupt mode 
+ */
+void str8100_gpio_a_set_edgeintr(void (*funcptr)(int), int trig_both, int trig_rising, int gpio_pin)
+{
+	u32 gpio_index = (0x1 << gpio_pin);
+	
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOA_LINE) {
+		HAL_GPIOA_SET_DIRECTION_INPUT(gpio_index);
+
+		if (trig_both == PIN_TRIG_BOTH) {
+			/* Set Trigger Both */
+			HAL_GPIOA_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index);	
+		}
+		else if (trig_both == PIN_TRIG_SINGLE) {
+			/* Set Single Rising/Falling Edge Trigger */
+			if (trig_rising == PIN_TRIG_RISING) {
+				HAL_GPIOA_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index);
+			}
+			else if (trig_rising == PIN_TRIG_FALLING) {
+				HAL_GPIOA_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index);
+			}
+			else {
+				printk("Trigger rising/falling error.\n");
+				return;
+			}
+		}
+		else
+		{
+			printk("Trigger both/single error.\n");
+			return;
+		}
+
+		gpio_a_isr[gpio_pin] = funcptr;
+
+		/* Enable Interrupt */
+		HAL_GPIOA_ENABLE_INTERRUPT(gpio_index);
+	}
+}
+
+/*  
+ * Setup GPIOB for Edge Trigger Interrupt mode 
+ */
+void str8100_gpio_b_set_edgeintr(void (*funcptr)(int),int trig_both,int trig_rising, int gpio_pin)
+{
+	u32 gpio_index = (0x1 << gpio_pin);
+	
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOA_LINE) {
+		HAL_GPIOB_SET_DIRECTION_INPUT(gpio_index);
+
+		if (trig_both == PIN_TRIG_BOTH) {
+			/* Set Trigger Both */
+			HAL_GPIOB_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index);	
+		}
+		else if (trig_both == PIN_TRIG_SINGLE) {
+			/* Set Single Rising/Falling Edge Trigger */
+			if (trig_rising == PIN_TRIG_RISING) {
+				HAL_GPIOB_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index);
+			}
+			else if (trig_rising == PIN_TRIG_FALLING) {
+				HAL_GPIOB_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index);
+			}
+			else {
+				printk("Trigger rising/falling error.\n");
+				return;
+			}
+		}
+		else {
+			printk("Trigger both/single error.\n");
+			return;
+		}
+
+		gpio_b_isr[gpio_pin] = funcptr;
+
+		/* Enable Interrupt */
+		HAL_GPIOB_ENABLE_INTERRUPT(gpio_index);
+	}
+}
+
+/*  
+ * Clear GPIOA Trigger Interrupt
+ */
+void str8100_gpio_a_clear_intr(int gpio_pin)
+{
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOA_LINE) {
+		/* Unregister isr of GPIOA[gpio_pin] */	
+		gpio_a_isr[gpio_pin] = NULL;	
+		/* Disable Interrupt */
+		HAL_GPIOA_DISABLE_INTERRUPT(0x1 << gpio_pin);
+	}
+}
+
+/*  
+ * Clear GPIOB Trigger Interrupt
+ */
+void str8100_gpio_b_clear_intr(int gpio_pin)
+{
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOB_LINE) {
+		/* Unregister isr of GPIOB[gpio_pin] */
+		gpio_b_isr[gpio_pin] = NULL;			
+		/* Disable Interrupt */
+		HAL_GPIOB_DISABLE_INTERRUPT(0x1 << gpio_pin);
+	}
+}
+
+/*  
+ * Setup GPIOA for LEVEL Trigger Interrupt mode 
+ */
+void str8100_gpio_a_set_levelintr(void (*funcptr)(int),int trig_level, int gpio_pin)
+{
+	u32 gpio_index = (0x1 << gpio_pin);
+
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOA_LINE) {
+		HAL_GPIOA_SET_DIRECTION_INPUT(gpio_index);
+
+		/* Set Trigger High/Low */
+		if (trig_level == PIN_TRIG_HIGH) {
+			HAL_GPIOA_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index);
+		}
+		else if (trig_level == PIN_TRIG_LOW) {
+			HAL_GPIOA_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index);
+		}
+		else {
+			printk("Trigger level error.\n");
+			return;
+		}
+
+		gpio_a_isr[gpio_pin] = funcptr;
+
+		/* Enable Interrupt */
+		HAL_GPIOA_ENABLE_INTERRUPT(gpio_index);
+	}
+}
+
+/*  
+ * Setup GPIO for LEVEL Triggle Interrupt mode 
+ */
+void str8100_gpio_b_set_levelintr(void (*funcptr)(int),int trig_level, int gpio_pin)
+{
+	u32 gpio_index = (0x1 << gpio_pin);
+
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIOB_LINE) {
+		HAL_GPIOB_SET_DIRECTION_INPUT(gpio_index);
+
+		/* Set Trigger High/Low */
+		if (trig_level == PIN_TRIG_HIGH) {
+			HAL_GPIOB_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index);
+		}
+		else if (trig_level == PIN_TRIG_LOW) {
+			HAL_GPIOB_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index);
+		}
+		else {
+			printk("Trigger level error.\n");
+			return;
+		}
+
+		gpio_b_isr[gpio_pin] = funcptr;
+
+		/* Enable Interrupt */
+		HAL_GPIOB_ENABLE_INTERRUPT(gpio_index);
+	}
+}
+
+EXPORT_SYMBOL(str8100_gpio_a_set_edgeintr);
+EXPORT_SYMBOL(str8100_gpio_a_clear_intr);
+EXPORT_SYMBOL(str8100_gpio_a_set_levelintr);
+EXPORT_SYMBOL(str8100_gpio_b_set_edgeintr);
+EXPORT_SYMBOL(str8100_gpio_b_clear_intr);
+EXPORT_SYMBOL(str8100_gpio_b_set_levelintr);
+
+/*  
+ * Display GPIO information at /proc/str9100/gpio
+ */
+
+#ifdef STR8100_GPIO_INTERRUPT_TEST
+void str8100_gpio_intr_test(int i)
+{
+	printk("GPIO Interrupt Service Single Active : %d \n",i);
+}
+#endif
+
+#endif
+
+#ifdef CONFIG_STR8100_GPIO_GENERIC_INTERFACE
+/***********************************************************************
+ * The STR8100 has GPIOA(32) and GPIOB(32) total 64 GPIO. For the
+ * generic GPIO interface, the GPIO pin number count from GPIOA to GPIOB.
+ * For example:
+ *      0 -> GPIOA[0]
+ *      1 -> GPIOA[1]
+ *     ......
+ *     31 -> GPIOA[31]
+ *     32 -> GPIOB[0]
+ *     33 -> GPIOB[1]
+ *     ......
+ *     63 -> GPIOB[31]
+ **********************************************************************/
+
+#define GPIOA_PIN_NO	32
+#define GPIOB_PIN_NO	32
+#define MAX_GPIO_NO	(GPIOA_PIN_NO + GPIOB_PIN_NO)
+
+/*
+ * Configure the GPIO line as an input.
+ */
+int __init_or_module gpio_direction_input(unsigned int pin)
+{
+	volatile __u32 reg;
+	unsigned long flags;
+
+	if (pin >= MAX_GPIO_NO)
+		return -EINVAL;
+
+        local_irq_save(flags);
+
+	/* Clear register bit to set as input pin. */
+	if (pin < GPIOA_PIN_NO)
+	{
+		/* GPIOA */
+		reg = GPIOA_DIRECTION_REG;
+		reg &= ~(1 << pin);
+		GPIOA_DIRECTION_REG = reg;
+	}
+	else
+	{
+		/* GPIOB */
+		reg = GPIOB_DIRECTION_REG;
+		reg &= ~(1 << (pin - GPIOA_PIN_NO));
+		GPIOB_DIRECTION_REG = reg;
+	}
+
+        local_irq_restore(flags);
+
+        return 0;
+}
+//EXPORT_SYMBOL(gpio_direction_input);
+
+/*
+ * Configure the GPIO line as an output, with default state.
+ */
+int __init_or_module gpio_direction_output(unsigned int pin, unsigned int state)
+{
+	volatile __u32 reg;
+	unsigned long flags;
+	if (pin >= MAX_GPIO_NO)
+		return -EINVAL;
+
+        local_irq_save(flags);
+
+	if (pin < GPIOA_PIN_NO)
+	{
+		/* GPIOA */
+		/* Set register bit to set as output pin. */
+		reg = GPIOA_DIRECTION_REG;
+		reg |= (1 << pin);
+		GPIOA_DIRECTION_REG = reg;
+
+		if (state)
+			GPIOA_DATA_BIT_SET_REG = (1 << pin);
+		else
+			GPIOA_DATA_BIT_CLEAR_REG = (1 << pin);
+
+	}
+	else
+	{
+		/* GPIOB */
+		/* Set register bit to set as output pin. */
+		reg = GPIOB_DIRECTION_REG;
+		reg |= (1 << (pin - GPIOA_PIN_NO));
+		GPIOB_DIRECTION_REG = reg;
+
+		if (state)
+			GPIOB_DATA_BIT_SET_REG = (1 << (pin - GPIOA_PIN_NO));
+		else
+			GPIOB_DATA_BIT_CLEAR_REG = (1 << (pin - GPIOA_PIN_NO));
+	}
+
+        local_irq_restore(flags);
+
+        return 0;
+}
+EXPORT_SYMBOL(gpio_direction_output);
+
+
+/*
+ * Set the state of an output GPIO line.
+ */
+void gpio_set_value(unsigned int pin, unsigned int state)
+{
+	if (pin >= MAX_GPIO_NO)
+		return;
+
+	if (pin < GPIOA_PIN_NO)
+	{
+		/* GPIOA */
+		if (state)
+			GPIOA_DATA_BIT_SET_REG = (1 << pin);
+		else
+			GPIOA_DATA_BIT_CLEAR_REG = (1 << pin);
+
+	}
+	else
+	{
+		/* GPIOB */
+		if (state)
+			GPIOB_DATA_BIT_SET_REG = (1 << (pin - GPIOA_PIN_NO));
+		else
+			GPIOB_DATA_BIT_CLEAR_REG = (1 << (pin - GPIOA_PIN_NO));
+	}
+}
+EXPORT_SYMBOL(gpio_set_value);
+
+
+/*
+ * Read the state of a GPIO line.
+ */
+int gpio_get_value(unsigned int pin)
+{
+	volatile __u32 reg;
+	bool bret = 0;
+
+	if (pin >= MAX_GPIO_NO)
+		return -EINVAL;
+
+	if (pin < GPIOA_PIN_NO)
+	{
+		/* GPIOA */
+		str8100_gpio_a_datain(&reg);
+		bret = (reg & (1 << pin)) != 0;
+	}
+	else
+	{
+		/* GPIOB */
+		str8100_gpio_b_datain(&reg);
+		bret = (reg & (1 << (pin - GPIOA_PIN_NO))) != 0;
+	}
+	
+	return bret;
+}
+EXPORT_SYMBOL(gpio_get_value);
+
+
+/*
+ * Map GPIO line to IRQ number.
+ */
+int gpio_to_irq(unsigned int pin)
+{
+	return INTC_GPIO_EXTERNAL_INT_BIT_INDEX;
+}
+EXPORT_SYMBOL(gpio_to_irq);
+
+
+/*
+ * INVALID
+ */
+int irq_to_gpio(unsigned int irq)
+{
+	return -EINVAL;
+}
+EXPORT_SYMBOL(irq_to_gpio);
+
+#endif /* CONFIG_STR8100_GPIO_GENREIC_INTERFACE */
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+static void gpio_a_isr_test(int i)
+{
+	unsigned int volatile status = 0;
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	printk("gpio_a_isr_test, count:%d\n",intr_a_count+1);
+	status = GPIOA_INTERRUPT_MASKED_STATUS_REG;
+	HAL_GPIOA_CLEAR_INTERRUPT(status);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	intr_a_count++;
+	if (intr_a_count >= 4) {
+		str8100_gpio_a_clear_intr(i);
+		intr_a_count = 0;
+	}
+
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+}
+
+static void gpio_b_isr_test(int i)
+{
+	unsigned int volatile status = 0;
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	printk("gpio_b_isr_test, count:%d\n",intr_b_count+1);
+	status = GPIOB_INTERRUPT_MASKED_STATUS_REG;
+	HAL_GPIOB_CLEAR_INTERRUPT(status);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	intr_b_count++;
+	if (intr_b_count >= 4) {
+		str8100_gpio_b_clear_intr(i);
+		intr_b_count = 0;
+	}
+
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+}
+#endif
+
+#ifdef CONFIG_STR8100_GPIO_GENERIC_INTERFACE
+static ssize_t str8100_gpio_write_proc(struct file *file, const char __user *buffer,
+			   ssize_t count, void *data){
+	int pin = 0,state =0;
+	char read_buff[100],buf_cmd[100],buf_param1[100],buf_param2[100],buf_param3[100],buf_param4[100];
+	readstring((char *)read_buff,(const char *)buffer,count);
+	sscanf(read_buff,"%s %s %s %s %s\n",(char *)&buf_cmd,(char *)&buf_param1\
+									   ,(char *)&buf_param2, (char *)&buf_param3, (char *)&buf_param4);
+	//printk("buf_cmd:%s buf_param1:%s buf_param2:%s buf_param2:%s \n", buf_cmd,buf_param1,buf_param2,buf_param3);
+	if(strcmp(buf_cmd,"direct") == 0)
+		if(strcmp(buf_param1,"input") == 0){
+			sscanf(buf_param2, "%d", &pin);
+			//printk("direction input pin=%d \n",pin);
+			gpio_direction_input(pin);
+		}
+	if(strcmp(buf_cmd,"direct") == 0)
+		if(strcmp(buf_param1,"output") == 0){
+			sscanf(buf_param2, "%d", &pin);
+			sscanf(buf_param3, "%d", &state);
+			//printk("direction output pin=%d state=%d  \n",pin,state);
+			gpio_direction_output(pin,state);
+		}
+	if(strcmp(buf_cmd,"set") == 0)
+		if(strcmp(buf_param1,"value") == 0){
+			sscanf(buf_param2, "%d", &pin);
+			sscanf(buf_param3, "%d", &state);
+			printk("set value pin=%d state=%d  \n",pin,state);
+			gpio_set_value(pin,state);
+		}
+	if(strcmp(buf_cmd,"get") == 0)
+		if(strcmp(buf_param1,"value") == 0){
+			sscanf(buf_param2, "%d", &pin);
+			state=gpio_get_value(pin);
+			printk("get value pin=%d state=%d \n",pin,state);
+		}
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+	if(strcmp(buf_cmd,"trig") == 0){
+		if(strcmp(buf_param1,"edge") == 0){
+			if(strcmp(buf_param2,"both") == 0){
+				sscanf(buf_param3, "%d", &pin);
+				if (pin < GPIOA_PIN_NO)
+					str8100_gpio_a_set_edgeintr(&gpio_a_isr_test, 1, 0, pin);
+				else
+					str8100_gpio_b_set_edgeintr(&gpio_b_isr_test, 1, 0, pin-GPIOA_PIN_NO);		
+			}
+			if(strcmp(buf_param2,"single") == 0){
+				if(strcmp(buf_param3,"rising") == 0){
+					sscanf(buf_param4, "%d", &pin);
+					if (pin < GPIOA_PIN_NO)
+						str8100_gpio_a_set_edgeintr(&gpio_a_isr_test, 0, 0, pin);
+					else
+						str8100_gpio_b_set_edgeintr(&gpio_b_isr_test, 0, 0, pin-GPIOA_PIN_NO);
+				}
+				if(strcmp(buf_param3,"falling") == 0){
+					sscanf(buf_param4, "%d", &pin);
+					if (pin < GPIOA_PIN_NO)
+						str8100_gpio_a_set_edgeintr(&gpio_a_isr_test, 0, 1, pin);
+					else
+						str8100_gpio_b_set_edgeintr(&gpio_b_isr_test, 0, 1, pin-GPIOA_PIN_NO);
+				}		
+			}
+		}
+		if(strcmp(buf_param1,"level") == 0){
+			if(strcmp(buf_param2,"high") == 0){
+				sscanf(buf_param3, "%d", &pin);
+				if (pin < GPIOA_PIN_NO)
+					str8100_gpio_a_set_levelintr(&gpio_a_isr_test, 0, pin);
+				else
+					str8100_gpio_b_set_levelintr(&gpio_b_isr_test, 0, pin-GPIOA_PIN_NO);
+			}
+			if(strcmp(buf_param2,"low") == 0){
+				sscanf(buf_param3, "%d", &pin);
+				if (pin < GPIOA_PIN_NO)
+					str8100_gpio_a_set_levelintr(&gpio_a_isr_test, 1, pin);
+				else
+					str8100_gpio_b_set_levelintr(&gpio_b_isr_test, 1, pin-GPIOA_PIN_NO);
+			}
+		}
+	}
+#endif
+		
+	return count;
+	
+}
+
+static struct proc_dir_entry *proc_str8100_gpio;
+#endif
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+int __init str8100_gpio_init(void)
+{
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+	u32 i, ret;
+#endif
+
+	//proc_str8100_gpio = create_proc_read_entry("str8100/gpio", 0, NULL, str8100_gpio_proc, NULL) ;
+#ifdef CONFIG_STR8100_GPIO_GENERIC_INTERFACE
+	proc_str8100_gpio = create_proc_entry("str8100/gpio", S_IFREG | S_IRUGO, NULL) ;
+	proc_str8100_gpio->read_proc = str8100_gpio_proc;
+	proc_str8100_gpio->write_proc = str8100_gpio_write_proc;
+#endif
+
+#ifdef CONFIG_STR8100_GPIO_INTERRUPT
+	for (i = 0; i < MAX_GPIOA_LINE; i++) {
+		gpio_a_isr[i] = NULL;
+	}
+	for (i = 0; i < MAX_GPIOB_LINE; i++) {
+		gpio_b_isr[i] = NULL;
+	}
+
+	/* Clear All Interrupt Status */
+	HAL_GPIOA_CLEAR_INTERRUPT(0xFFFFFFFF);
+	HAL_GPIOB_CLEAR_INTERRUPT(0xFFFFFFFF);
+	str8100_set_interrupt_trigger(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, INTC_EDGE_TRIGGER, INTC_RISING_EDGE);
+	ret = request_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, str8100_gpio_irq_handler, 0, "str8100_gpio", 0);
+	if (ret < 0) {
+		printk("request_irq fail : %d \n", ret);
+		return 0;
+	} else {
+		printk("GPIO interrupt handler install ok. \n");
+	}
+#endif
+#ifdef STR8100_GPIO_INTERRUPT_TEST
+	str8100_gpio_a_set_edgeintr(&str8100_gpio_intr_test, PIN_TRIG_SINGLE, PIN_TRIG_RISING, 0);
+	str8100_gpio_a_set_levelintr(&str8100_gpio_intr_test, PIN_TRIG_HIGH, 1);
+#endif
+
+	return 0;
+}	
+
+void __exit str8100_gpio_exit(void)
+{
+	free_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, 0);
+}
+
+module_init(str8100_gpio_init);
+module_exit(str8100_gpio_exit);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_hsdma.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_hsdma.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_hsdma.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_hsdma.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,439 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <mach/star_intc.h>
+#include <mach/star_hsdmac.h>
+
+//#define HSDMA_DEBUG
+#define STR8100_HSDMA_TEST
+
+#define HSDMA_MIN_XFER_SIZE		1024
+#define HSDMA_XFER_MAX_Q_LEN		32
+
+typedef struct
+{
+	struct list_head	lh;
+	hsdma_xfer_t		*xfer;
+	hsdma_llp_descr_t	*llp_descr;
+	u32			llp_descr_dma;
+	int			done_status;
+} hsdma_job_t;
+
+static u8 hsdma_dev;
+static spinlock_t hsdma_lock;
+static u8 hsdma_busy;
+static unsigned int hsdma_xfer_q_len;
+static unsigned int hsdma_done_q_len;
+static struct list_head hsdma_xfer_q;
+static struct list_head hsdma_done_q;
+static hsdma_job_t *hsdma_running_job;
+
+static void *hsdma_mem_pool;
+static u32 hsdma_mem_pool_dma;
+
+static hsdma_job_t hsdma_job_pool[HSDMA_XFER_MAX_Q_LEN];
+static struct list_head hsdma_job_q;
+static spinlock_t hsdma_job_q_lock;
+
+static void hsdma_process_xfer_job(void *data);
+static void hsdma_process_done_job(void *data);
+
+// Eileen , for linux kernel 2.6.24 , 20080425
+//static DECLARE_WORK(hsdma_xfer_task, hsdma_process_xfer_job, (void *)&hsdma_xfer_q);
+//static DECLARE_WORK(hsdma_done_task, hsdma_process_done_job, (void *)&hsdma_done_q);
+static DECLARE_WORK(hsdma_xfer_task, hsdma_process_xfer_job);
+static DECLARE_WORK(hsdma_done_task, hsdma_process_done_job);
+
+static int hsdma_job_q_init(void)
+{
+	int i;
+
+	hsdma_mem_pool = (void *)pci_alloc_consistent(NULL,
+		(HSDMA_XFER_MAX_Q_LEN * MAX_HSDMA_VEC * sizeof(hsdma_llp_descr_t)),
+	       	&hsdma_mem_pool_dma);
+
+	if (hsdma_mem_pool == NULL) {
+		return -1;
+	}
+
+	INIT_LIST_HEAD(&hsdma_job_q);
+	for (i = 0; i < HSDMA_XFER_MAX_Q_LEN; i++) {
+		INIT_LIST_HEAD(&hsdma_job_pool[i].lh);
+		hsdma_job_pool[i].llp_descr = (hsdma_llp_descr_t *)(hsdma_mem_pool + (i * (MAX_HSDMA_VEC * sizeof(hsdma_llp_descr_t))));
+		hsdma_job_pool[i].llp_descr_dma = hsdma_mem_pool_dma + (i * (MAX_HSDMA_VEC * sizeof(hsdma_llp_descr_t)));
+		list_add_tail(&hsdma_job_pool[i].lh, &hsdma_job_q);
+	}
+
+	return 0;
+}
+
+static hsdma_job_t *hsdma_job_alloc(void)
+{
+	hsdma_job_t *job;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdma_job_q_lock, flags);
+	if (list_empty(&hsdma_job_q)) {
+		job = NULL;
+	} else {
+		job = list_entry(hsdma_job_q.next, hsdma_job_t, lh);
+		list_del_init(&job->lh);
+	}
+	spin_unlock_irqrestore(&hsdma_job_q_lock, flags);
+
+	return job;
+}
+
+static void hsdma_job_free(hsdma_job_t *job)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdma_job_q_lock, flags);
+	list_add(&job->lh, &hsdma_job_q);
+	spin_unlock_irqrestore(&hsdma_job_q_lock, flags);
+}
+
+#ifdef HSDMA_DEBUG
+void hsdma_dump_reg(void)
+{
+	printk("HSDMAC_CONTROL_STATUS_REG:	0x%08x\n", HSDMAC_CONTROL_STATUS_REG);
+	printk("HSDMAC_MASTER0_ADDR_REG:	0x%08x\n", HSDMAC_MASTER0_ADDR_REG);
+	printk("HSDMAC_MASTER1_ADDR_REG:	0x%08x\n", HSDMAC_MASTER1_ADDR_REG);
+	printk("HSDMAC_LLP_REG:			0x%08x\n", HSDMAC_LLP_REG);
+	printk("HSDMAC_TOT_SIZE_REG:		0x%08x\n", HSDMAC_TOT_SIZE_REG);
+}
+#endif
+
+void hsdma_copy(hsdma_xfer_t *hsdma_xfer)
+{
+	hsdma_job_t *hsdma_job;
+	unsigned long flags;
+	int i;
+
+	if (hsdma_xfer_q_len > HSDMA_XFER_MAX_Q_LEN) {
+		hsdma_xfer->hsdma_end_io(hsdma_xfer, HSDMAC_RESPONSE_ERR);
+		return;
+	}
+
+	hsdma_job = hsdma_job_alloc();
+	if (hsdma_job == NULL) {
+		hsdma_xfer->hsdma_end_io(hsdma_xfer, HSDMAC_RESPONSE_ERR);
+		return;
+	}
+
+	memset(hsdma_job->llp_descr, 0, (hsdma_xfer->nr_vec * sizeof(hsdma_llp_descr_t)));
+	for (i = 0; i < hsdma_xfer->nr_vec; i++) {
+		if ((hsdma_xfer->vec[i].src_addr & 0x3) ||
+		    (hsdma_xfer->vec[i].dst_addr & 0x3) ||
+		    (hsdma_xfer->vec[i].size & 0x3)) {
+			hsdma_xfer->hsdma_end_io(hsdma_xfer, HSDMAC_RESPONSE_ERR);
+			hsdma_job_free(hsdma_job);
+			return;
+		}
+		hsdma_job->llp_descr[i].src_addr = (u32)virt_to_phys((void *)hsdma_xfer->vec[i].src_addr);
+		hsdma_job->llp_descr[i].dst_addr = (u32)virt_to_phys((void *)hsdma_xfer->vec[i].dst_addr);
+		hsdma_job->llp_descr[i].tot_size = (hsdma_xfer->vec[i].size >> 2) & 0xFFF;
+		hsdma_job->llp_descr[i].data_direction = hsdma_xfer->vec[i].data_direction;
+		if (i == (hsdma_xfer->nr_vec - 1)) {
+			hsdma_job->llp_descr[i].llp = 0;
+			hsdma_job->llp_descr[i].tc_mask = 0;
+		} else {
+			hsdma_job->llp_descr[i].llp = (u32)(hsdma_job->llp_descr_dma + ((i + 1) * sizeof(hsdma_llp_descr_t)));
+			hsdma_job->llp_descr[i].tc_mask = 1;
+		}
+		// Eileen , for linux kernel 2.6.24 , 20080425
+		//old : consistent_sync((void *)hsdma_xfer->vec[i].src_addr, hsdma_xfer->vec[i].size, PCI_DMA_TODEVICE);
+		//old : consistent_sync((void *)hsdma_xfer->vec[i].dst_addr, hsdma_xfer->vec[i].size, PCI_DMA_FROMDEVICE);
+		dma_cache_maint((void *)hsdma_xfer->vec[i].src_addr, hsdma_xfer->vec[i].size, PCI_DMA_TODEVICE);
+		dma_cache_maint((void *)hsdma_xfer->vec[i].dst_addr, hsdma_xfer->vec[i].size, PCI_DMA_FROMDEVICE);
+#ifdef HSDMA_DEBUG
+		printk("src_addr: 0x%08x\n", hsdma_job->llp_descr[i].src_addr);
+		printk("dst_addr: 0x%08x\n", hsdma_job->llp_descr[i].dst_addr);
+		printk("llp:      0x%08x\n", hsdma_job->llp_descr[i].llp);
+		printk("tot_size: 0x%08x\n", hsdma_job->llp_descr[i].tot_size);
+		printk("data_dir: 0x%08x\n", hsdma_job->llp_descr[i].data_direction);
+		printk("tc_mask:  0x%08x\n", hsdma_job->llp_descr[i].tc_mask);
+#endif
+	}
+
+	hsdma_job->xfer = hsdma_xfer;
+	hsdma_job->done_status = 0;
+
+	spin_lock_irqsave(&hsdma_lock, flags);
+	list_add_tail(&hsdma_job->lh, &hsdma_xfer_q);
+	hsdma_xfer_q_len++;
+	spin_unlock_irqrestore(&hsdma_lock, flags);
+
+	if (!hsdma_busy) {
+		schedule_work(&hsdma_xfer_task);
+	}
+}
+EXPORT_SYMBOL(hsdma_copy);
+
+static void hsdma_process_xfer_job(void *data)
+{
+	hsdma_job_t *hsdma_job;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdma_lock, flags);
+	hsdma_job = list_entry(hsdma_xfer_q.next, hsdma_job_t, lh);
+	if (hsdma_job) {
+		list_del_init(&hsdma_job->lh);
+		hsdma_running_job = hsdma_job;
+		hsdma_xfer_q_len--;
+		hsdma_busy = 1;
+		if (hsdma_job->llp_descr[0].data_direction == HSDMAC_MASTER0_TO_MASTER1) {
+			HSDMAC_MASTER0_ADDR_REG = hsdma_job->llp_descr[0].src_addr;
+			HSDMAC_MASTER1_ADDR_REG = hsdma_job->llp_descr[0].dst_addr;
+			HSDMAC_TOT_SIZE_REG &= ~(0x1 << 29);
+		} else {
+			HSDMAC_MASTER0_ADDR_REG = hsdma_job->llp_descr[0].dst_addr;
+			HSDMAC_MASTER1_ADDR_REG = hsdma_job->llp_descr[0].src_addr;
+			HSDMAC_TOT_SIZE_REG |= (0x1 << 20);
+		}
+		HSDMAC_LLP_REG = (u32)hsdma_job->llp_descr[0].llp;
+		HSDMAC_TOT_SIZE_REG |= hsdma_job->llp_descr[0].tot_size;
+		if (hsdma_job->llp_descr[0].tc_mask) {
+			HSDMAC_TOT_SIZE_REG |= (0x1 << 28);
+		} else {
+			HSDMAC_TOT_SIZE_REG &= ~(0x1 << 28);
+		}
+		HAL_HSDMAC_ENABLE();
+	}
+	spin_unlock_irqrestore(&hsdma_lock, flags);
+}
+
+static void hsdma_process_done_job(void *data)
+{
+	hsdma_job_t *hsdma_job;
+	struct list_head *l, *t;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdma_lock, flags);
+	list_for_each_safe(l, t, &hsdma_done_q) {
+		hsdma_job = list_entry(l, hsdma_job_t, lh);
+		list_del_init(&hsdma_job->lh);
+		hsdma_done_q_len--;
+		spin_unlock_irqrestore(&hsdma_lock, flags);
+		hsdma_job->xfer->hsdma_end_io(hsdma_job->xfer, hsdma_job->done_status);
+		hsdma_job_free(hsdma_job);
+		spin_lock_irqsave(&hsdma_lock, flags);
+	}
+	spin_unlock_irqrestore(&hsdma_lock, flags);
+}
+
+// Eileen , for linux kernel 2.6.24 , 20080425
+//old : irqreturn_t hsdma_isr(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t hsdma_isr(int irq, void *dev_id)
+{
+	hsdma_job_t *hsdma_job;
+
+	hsdma_job = hsdma_running_job;
+	hsdma_running_job = NULL;
+	list_add_tail(&hsdma_job->lh, &hsdma_done_q);
+	hsdma_done_q_len++;
+
+	if (HSDMAC_CONTROL_STATUS_REG & (0x1 << 12)) {
+		hsdma_job->done_status = HSDMAC_RESPONSE_ERR;
+	} else {
+		hsdma_job->done_status = HSDMAC_RESPONSE_OK;
+	}
+
+	HAL_HSDMAC_DISABLE();
+
+	hsdma_busy = 0;
+
+	schedule_work(&hsdma_done_task);
+
+	if (hsdma_xfer_q_len) {
+		schedule_work(&hsdma_xfer_task);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int hsdma_init(void)
+{
+	int retval;
+
+	// enable the HSDMA clock
+	HAL_PWRMGT_ENABLE_HSDMA_CLOCK();
+
+	// disable the HSDMA(normal mode, incremental address)
+	HSDMAC_CONTROL_STATUS_REG = 0x0;
+	HSDMAC_TOT_SIZE_REG = 0x10000000;
+
+	if (hsdma_job_q_init() != 0) {
+		return -EFAULT;
+	}
+
+	spin_lock_init(&hsdma_lock);
+	INIT_LIST_HEAD(&hsdma_xfer_q);
+	INIT_LIST_HEAD(&hsdma_done_q);
+
+	// Eileen , for linux kernel 2.6.24 , 20080425
+	//retval = request_irq(INTC_HSDMAC_BIT_INDEX, &hsdma_isr, SA_INTERRUPT, "STR8100 HSDMA", &hsdma_dev);
+	retval = request_irq(INTC_HSDMAC_BIT_INDEX, &hsdma_isr, IRQF_DISABLED, "STR8100 HSDMA", &hsdma_dev);
+	if (retval) {
+		printk("%s: unable to get IRQ %d (irqval=%d).\n", "STAR HSDMA", INTC_HSDMAC_BIT_INDEX, retval);
+		return retval;
+	}
+
+	return retval;
+}
+
+// Eileen , for linux kernel 2.6.24 , 20080425
+#ifdef STR8100_HSDMA_TEST
+	static int str8100_hsdma_test(void);
+#endif
+
+static int __init str8100_hsdma_init(void)
+{
+	int retval;
+
+	printk("STR8100 HSDMA driver init\n");
+	retval = hsdma_init();
+#ifdef STR8100_HSDMA_TEST
+	if (retval == 0) {
+		// Eileen ,for linux kernel 2.6.24 , 20080425
+		//move : static int str8100_hsdma_test(void);
+		(void)str8100_hsdma_test();
+	}
+#endif
+	return retval;
+}
+
+static void __exit str8100_hsdma_exit(void)
+{
+	        return;
+}
+
+module_init(str8100_hsdma_init);
+module_exit(str8100_hsdma_exit);
+
+#ifdef STR8100_HSDMA_TEST
+#define MEMSIZE_K		128
+#define MEMSIZE			(MEMSIZE_K*1024)
+
+#define NUM_HSDMA_VEC		16
+#define NUM_BYTES_PER_VEC	4096
+
+static hsdma_xfer_t hsdma_xfer_test;
+static u8 *src;
+static u8 *dst;
+
+static void hsdma_copy_end(hsdma_xfer_t *hsdma_xfer, int err)
+{
+	int i;
+
+	printk("STR8100 HSDMA Testing end\n");
+
+	if (err) {
+		printk("STR8100 HSDMA Testing failed!!\n");
+	} else {
+		for (i = 0; i < NUM_HSDMA_VEC; i++) {
+			if (memcmp((src + i * NUM_BYTES_PER_VEC), (dst + i * NUM_BYTES_PER_VEC), NUM_BYTES_PER_VEC) == 0) {
+				printk("STR8100 HSDMA Testing success started at offset: %04d:\n", i * NUM_BYTES_PER_VEC);
+			} else {
+				int j;
+				u8 *psrc;
+				u8 *pdst;
+
+				psrc = src + i * NUM_BYTES_PER_VEC;
+				pdst = dst + i * NUM_BYTES_PER_VEC;
+
+				printk("STR8100 HSDMA Testing error started at offset: %04d\n", i * NUM_BYTES_PER_VEC);
+
+				for (j = 0; j < NUM_BYTES_PER_VEC; j++) {
+					if ((j % 16) == 0) {
+						printk("\n 0x%08x: ", (u32)(psrc + j));
+					}
+					if (((j % 16) != 0) && ((j % 4) == 0)) {
+						printk(" ");
+					}
+					printk("%02x", psrc[j]);
+				}
+				printk("\n");
+	
+				for (j = 0; j < NUM_BYTES_PER_VEC; j++) {
+					if ((j % 16) == 0) {
+						printk("\n 0x%08x: ", (u32)(pdst + j));
+					}
+					if (((j % 16) != 0) && ((j % 4) == 0)) {
+						printk(" ");
+					}
+					printk("%02x", pdst[j]);
+				}
+				printk("\n");
+			}
+		}
+	}
+
+	kfree(src);
+	kfree(dst);
+}
+
+static int str8100_hsdma_test(void)
+{
+	int i;
+
+	src = kmalloc(MEMSIZE, GFP_KERNEL);
+	if (!src) goto out;
+	dst = kmalloc(MEMSIZE, GFP_KERNEL);
+	if (!dst) {
+		kfree(src);
+		goto out;
+	}
+
+	memset(src, 0xAF, MEMSIZE);
+	memset(dst, 0x00, MEMSIZE);
+
+	hsdma_xfer_test.nr_vec = NUM_HSDMA_VEC;
+	hsdma_xfer_test.hsdma_end_io = hsdma_copy_end;
+	for (i = 0; i < NUM_HSDMA_VEC; i++) {
+		hsdma_xfer_test.vec[i].data_direction = HSDMAC_MASTER0_TO_MASTER1;
+		hsdma_xfer_test.vec[i].src_addr = (u32)(src + i * NUM_BYTES_PER_VEC);
+		hsdma_xfer_test.vec[i].dst_addr = (u32)(dst + i * NUM_BYTES_PER_VEC);
+		hsdma_xfer_test.vec[i].size = NUM_BYTES_PER_VEC;
+	}
+
+	printk("STR8100 HSDMA Testing ...\n");
+	hsdma_copy(&hsdma_xfer_test);
+
+out:
+	return 0;
+}
+
+#endif // STR8100_HSDMA_TEST
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_i2s.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_i2s.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_i2s.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_i2s.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,743 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+/*
+ * defines for each channel
+ */
+#define DMAC_CH_DISABLE                0
+#define DMAC_CH_ENABLE                 1
+
+#define DMAC_CH_DST_SEL_M0             0
+#define DMAC_CH_DST_SEL_M1             1
+
+#define DMAC_CH_SRC_SEL_M0             0
+#define DMAC_CH_SRC_SEL_M1             1
+
+#define DMAC_CH_DSTAD_CTL_INC          0
+#define DMAC_CH_DSTAD_CTL_DEC          1
+#define DMAC_CH_DSTAD_CTL_FIX          2
+
+#define DMAC_CH_SRCAD_CTL_INC          0
+#define DMAC_CH_SRCAD_CTL_DEC          1
+#define DMAC_CH_SRCAD_CTL_FIX          2
+
+#define DMAC_CH_MODE_HW_HANDSHAKE      1
+
+#define DMAC_CH_SRC_WIDTH_8_BITS       0
+#define DMAC_CH_SRC_WIDTH_16_BITS      1
+#define DMAC_CH_SRC_WIDTH_32_BITS      2
+
+#define DMAC_CH_DST_WIDTH_8_BITS       0
+#define DMAC_CH_DST_WIDTH_16_BITS      1
+#define DMAC_CH_DST_WIDTH_32_BITS      2
+
+#define DMAC_CH_ABT_TRANSFER           1
+
+#define DMAC_CH_PROT1_PRIVILEGED_MODE  1
+#define DMAC_CH_PROT1_USER_MODE        0
+
+#define DMAC_CH_PROT2_BUFFERABLE       1
+#define DMAC_CH_PROT2_NON_BUFFERABLE   0
+
+#define DMAC_CH_PROT3_CACHEABLE        1
+#define DMAC_CH_PROT3_NON_CACHEABLE    0
+
+#define DMAC_CH_PRI_LEVEL_0            0
+#define DMAC_CH_PRI_LEVEL_1            1
+#define DMAC_CH_PRI_LEVEL_2            2
+#define DMAC_CH_PRI_LEVEL_3            3
+
+#define DMAC_CH_TC_MASK_DISABLE        0
+#define DMAC_CH_TC_MASK_ENABLE         1
+
+#define DMAC_MAX_CHANNEL_NUM           (8)
+
+
+#define DMAC_CH0_ID                    (1 << 0)
+#define DMAC_CH1_ID                    (1 << 1)
+#define DMAC_CH2_ID                    (1 << 2)
+#define DMAC_CH3_ID                    (1 << 3)
+#define DMAC_CH4_ID                    (1 << 4)
+#define DMAC_CH5_ID                    (1 << 5)
+#define DMAC_CH6_ID                    (1 << 6)
+#define DMAC_CH7_ID                    (1 << 7)
+#define DMAC_CH_ID(idx)                (1 << idx) 
+
+#define DMAC_LITTLE_ENDIAN             (0)
+#define DMAC_BIG_ENDIAN                (1)
+
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include <mach/star_powermgt.h>
+#include <mach/star_misc.h>
+#include <mach/star_i2s.h>
+#include <mach/star_dmac.h>
+
+MODULE_AUTHOR("Mac Lin");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+#define CONFIG_I2S_USE_DMA
+//Debug = left only
+#define DEBUG	
+
+static struct proc_dir_entry *star_i2s_proc_entry=NULL;
+static u32 sampling_rate=32000;
+static u32 sample_size=16;
+
+#define DMA_TRANSFER_MAX_BYTE    (0xfff<<(sample_size>>4)) 
+#define BUFSIZE (0xfff<<4) //twice the 32-bit DMA transfer byte size
+
+static u8* lbuffer;
+static u8* lbuffer_p;
+static u32 llen=0;
+static u32 lpos=0;
+static u32 i2s_err_lur=0;
+
+static u32 debug=0;
+#define DEBUG_PRINT(arg...) if(debug) printk(arg);
+
+//=================================================================================
+//
+#ifdef CONFIG_I2S_USE_DMA
+typedef struct _DMAC_HARDWARE_HANDSHAKE_OBJ_    DMAC_HARDWARE_HANDSHAKE_OBJ_T;
+
+struct _DMAC_HARDWARE_HANDSHAKE_OBJ_
+{
+    unsigned int    src_addr;                     //Src address
+    unsigned int    dst_addr;                     //Dst address
+    unsigned int    src_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dst_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dstad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    srcad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    src_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    dst_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    transfer_bytes;               //Byte Count to be transferred
+    unsigned int    channel_id;                   //0~7 for Channel0-7 selection
+    unsigned int    channel_num;                   //0~7
+    unsigned int    target_select;                //target ID
+    unsigned int    src_burst_size;               //number of transfer 
+}; 
+
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8759_dma_handshake_left_tx;
+static DMAC_HARDWARE_HANDSHAKE_OBJ_T    i2s_wm8759_dma_handshake_right_tx;
+
+static u32                          i2s_wm8759_dma_right_tx_channel = 1;
+
+
+
+
+void Hal_Dmac_Configure_DMA_Handshake(DMAC_HARDWARE_HANDSHAKE_OBJ_T *dmac_obj)
+{
+    u32    channel_control,interrupt_mask_config,ch;
+
+    
+    /*
+     * Configure DMA controller for UART's hardware DMA handshake mode
+     */    
+    HAL_DMAC_DISABLE();
+    
+//#if (ENDIAN_MODE == BIG_ENDIAN)
+#if 0
+    /*Set Master0 and Master 1 endianness as Big Endian*/
+    HAL_DMAC_SET_MASTER0_BIG_ENDIAN();
+    HAL_DMAC_SET_MASTER1_BIG_ENDIAN();
+#else
+    /*Set Master0 and Master 1 endianness as Little Endian*/
+    HAL_DMAC_SET_MASTER0_LITTLE_ENDIAN();
+    HAL_DMAC_SET_MASTER1_LITTLE_ENDIAN();
+#endif
+
+    //Clear TC interrupt status    
+    HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(0xFF);        // 8 channels
+
+    //Clear Errot/Abort interrupt status    
+    HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(0x00FF00FF);    // 8 channels
+
+    /*
+     * Configure DMA's channel control
+     */   
+    channel_control = ((DMAC_CH_TC_MASK_DISABLE << 31) | \
+                       ((dmac_obj->target_select&0xf) << 25) | \
+                       (DMAC_CH_PRI_LEVEL_3 << 22) | \
+                       (DMAC_CH_PROT3_NON_CACHEABLE << 21) | \
+                       (DMAC_CH_PROT2_NON_BUFFERABLE << 20) | \
+                       (DMAC_CH_PROT1_PRIVILEGED_MODE << 19) | \
+                       ((dmac_obj->src_burst_size&0x7) << 16) | \
+                       ((dmac_obj->src_width&0x7) << 11) | \
+                       ((dmac_obj->dst_width&0x7) << 8) | \
+                       (DMAC_CH_MODE_HW_HANDSHAKE << 7) | \
+                       ((dmac_obj->srcad_ctl&0x3) << 5) | \
+                       ((dmac_obj->dstad_ctl&0x3) << 3) | \
+                       (dmac_obj->src_master << 2) | \
+                       (dmac_obj->dst_master << 1) | \
+                       (DMAC_CH_DISABLE));
+
+    for (ch = 0; ch < DMAC_MAX_CHANNEL_NUM; ch++)
+    {
+        if (dmac_obj->channel_id & DMAC_CH_ID(ch))
+        {  
+            // 1. Set CSR
+            DMAC_CH_CSR_REG(ch) = channel_control & 0xFFFFFFFE; //Disable CH(n) DMA
+                
+            // 2.1 Reset Abort/Error/Terminal Count INT 
+            DMAC_CH_CFG_REG(ch) &= ~(0x07);
+            
+            // 2.2 Disable  Abort Count INT        
+            interrupt_mask_config = (1 << 2);
+            
+            DMAC_CH_CFG_REG(ch) |= (interrupt_mask_config & 0x07);
+        }                               	
+    }
+
+    for (ch = 0; ch < DMAC_MAX_CHANNEL_NUM; ch++)
+    {
+        if (dmac_obj->channel_id & DMAC_CH_ID(ch))
+        {  
+            //Set Src address register
+            DMAC_CH_SRC_ADDR_REG(ch)= dmac_obj->src_addr;
+
+            //Set Dst address register
+            DMAC_CH_DST_ADDR_REG(ch)= dmac_obj->dst_addr;    
+
+            //Set Transfer Number
+            if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_8_BITS)
+            {
+                DMAC_CH_SIZE_REG(ch) = (dmac_obj->transfer_bytes & 0x0FFF);
+                DEBUG_PRINT("%s: 8-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_16_BITS)
+            {                                  
+                DMAC_CH_SIZE_REG(ch) = ((dmac_obj->transfer_bytes >> 1) + (dmac_obj->transfer_bytes % 2)) & 0x0FFF;
+                DEBUG_PRINT("%s: 16-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else if (dmac_obj->src_width == DMAC_CH_SRC_WIDTH_32_BITS)
+            {
+                DMAC_CH_SIZE_REG(ch) = ((dmac_obj->transfer_bytes >> 2) + ((dmac_obj->transfer_bytes % 4) ? 1 : 0)) & 0x0FFF;
+                DEBUG_PRINT("%s: 32-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,dmac_obj->transfer_bytes,ch,DMAC_CH_SIZE_REG(ch));
+            }
+            else
+            {
+            	DEBUG_PRINT("%s: dead\n",__FUNCTION__);
+                while (1);
+            }
+
+            //Enable Channel DMA transfer 
+            HAL_DMAC_ENABLE_CHANNEL(ch);
+             
+            //Set Channel's Sync logic
+            DMAC_SYNC_REG |= (1 << ch);
+
+            //For NON Chain Transfer, clear LLP registers
+            DMAC_CH_LLP_REG(ch) = 0;
+        }
+    }
+}
+
+void I2s_WM8759_Configure_DMA_Hardware_Handshake(void)
+{
+    /*
+     * Configure DMA's channel setting for I2S's Left Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    i2s_wm8759_dma_handshake_left_tx.channel_num = 0;
+    i2s_wm8759_dma_handshake_left_tx.channel_id = DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num);
+    i2s_wm8759_dma_handshake_left_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_LEFT_ID;
+    i2s_wm8759_dma_handshake_left_tx.src_addr = (u32)lbuffer_p;
+    i2s_wm8759_dma_handshake_left_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    i2s_wm8759_dma_handshake_left_tx.dst_master = DMAC_CH_DST_SEL_M0;
+    i2s_wm8759_dma_handshake_left_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    i2s_wm8759_dma_handshake_left_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+    
+	switch(sample_size){
+	case 16:
+		i2s_wm8759_dma_handshake_left_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xCA);
+		i2s_wm8759_dma_handshake_left_tx.src_width = DMAC_CH_SRC_WIDTH_16_BITS;
+		i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_16_BITS;
+		break;
+	case 32:
+		i2s_wm8759_dma_handshake_left_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xC8);
+		i2s_wm8759_dma_handshake_left_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+		i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+		break;
+	}
+
+//    i2s_wm8759_dma_handshake_left_tx.dst_width = DMAC_CH_DST_WIDTH_16_BITS;
+
+    /*
+     * Note here the total number of bytes for each DMA transfer is specified!!
+     */
+//    i2s_wm8759_dma_handshake_left_tx.transfer_bytes = DMA_TRANSFER_MAX_BYTE;
+    i2s_wm8759_dma_handshake_left_tx.transfer_bytes = (llen<DMA_TRANSFER_MAX_BYTE)?llen:DMA_TRANSFER_MAX_BYTE;
+
+    i2s_wm8759_dma_handshake_left_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8759_dma_handshake_left_tx);
+
+#ifndef DEBUG 
+    /*
+     * Configure DMA's channel setting for I2S's Right Channel Tx
+     * Specially pay attention to the settings of src_width, dst_width, and src_burst_size
+     */
+    i2s_wm8759_dma_handshake_right_tx.channel_id = DMAC_CH_ID(i2s_wm8759_dma_right_tx_channel);
+    
+    i2s_wm8759_dma_handshake_right_tx.target_select = DMAC_HW_HAND_SHAKE_I2S_TX_RIGHT_ID;
+
+    i2s_wm8759_dma_handshake_right_tx.src_addr = (u32)rbuffer_p;
+
+    i2s_wm8759_dma_handshake_right_tx.dst_addr = (SYSPA_I2S_BASE_ADDR + 0xC4);
+
+    i2s_wm8759_dma_handshake_right_tx.src_master = DMAC_CH_SRC_SEL_M1;
+    
+    i2s_wm8759_dma_handshake_right_tx.dst_master = DMAC_CH_DST_SEL_M0;
+
+    i2s_wm8759_dma_handshake_right_tx.srcad_ctl = DMAC_CH_SRCAD_CTL_INC;
+    
+    i2s_wm8759_dma_handshake_right_tx.dstad_ctl = DMAC_CH_DSTAD_CTL_FIX;
+
+    i2s_wm8759_dma_handshake_right_tx.src_width = DMAC_CH_SRC_WIDTH_32_BITS;
+    
+    i2s_wm8759_dma_handshake_right_tx.dst_width = DMAC_CH_DST_WIDTH_32_BITS;
+
+    /*
+     * Note here the total number of bytes for each DMA transfer is specified!!
+     */
+    i2s_wm8759_dma_handshake_right_tx.transfer_bytes = DMA_TRANSFER_MAX_BYTE;
+
+    i2s_wm8759_dma_handshake_right_tx.src_burst_size = DMAC_CH_SRC_BURST_SIZE_1;   
+
+    Hal_Dmac_Configure_DMA_Handshake(&i2s_wm8759_dma_handshake_right_tx);
+#endif
+    return;
+}
+#endif //CONFIG_I2S_USE_DMA
+
+
+//=================================================================================
+//
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+#ifdef CONFIG_I2S_USE_DMA
+static irqreturn_t str8100_dma_tc_irq_handler(int this_irq, void *dev_id /*, struct pt_regs *regs*/)
+{
+	u32 dma_tc_status,tot_size;
+	u32 len;
+//printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+
+    HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(dma_tc_status);
+
+    /*
+     * For DMA's Tx for I2S Left Channel
+     */
+	if (dma_tc_status & DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num))
+	{                      
+		HAL_DMAC_DISABLE_CHANNEL(i2s_wm8759_dma_handshake_left_tx.channel_num);
+		HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(DMAC_CH_ID(i2s_wm8759_dma_handshake_left_tx.channel_num));
+		lpos+=i2s_wm8759_dma_handshake_left_tx.transfer_bytes;
+		if(lpos<llen){
+			/*
+			 * Re-initialize DMA's channel for Left_Tx
+			 */
+			DMAC_CH_SRC_ADDR_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = (u32)lbuffer_p+lpos;
+			DMAC_CH_DST_ADDR_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = (SYSPA_I2S_BASE_ADDR + 0xC8);        
+			
+			/*
+			 * Note this macro DMAC_CH_SIZE is to configure TOT_SIZE field which is the total transfer
+			 * number of source transfer width!
+			 */        
+			len=(llen - lpos);
+			i2s_wm8759_dma_handshake_left_tx.transfer_bytes= (len<DMA_TRANSFER_MAX_BYTE)?len:DMA_TRANSFER_MAX_BYTE;
+
+			if (i2s_wm8759_dma_handshake_left_tx.src_width == DMAC_CH_SRC_WIDTH_16_BITS)
+			{
+			    tot_size = (i2s_wm8759_dma_handshake_left_tx.transfer_bytes >> 1) + ((i2s_wm8759_dma_handshake_left_tx.transfer_bytes % 2) ? 1 : 0);
+			}
+			else if (i2s_wm8759_dma_handshake_left_tx.src_width == DMAC_CH_SRC_WIDTH_32_BITS)
+			{
+			    tot_size = (i2s_wm8759_dma_handshake_left_tx.transfer_bytes >> 2) + ((i2s_wm8759_dma_handshake_left_tx.transfer_bytes % 4) ? 1 : 0);
+			}
+			else
+			{
+			    tot_size = i2s_wm8759_dma_handshake_left_tx.transfer_bytes;
+			}
+			
+			DMAC_CH_SIZE_REG(i2s_wm8759_dma_handshake_left_tx.channel_num) = tot_size & 0x0FFF;
+			HAL_DMAC_ENABLE_CHANNEL(i2s_wm8759_dma_handshake_left_tx.channel_num);
+//printk("%s: 32-bits transfer_bytes=%d, DMAC_CH_SIZE_REG(%d)=%.8x\n",__FUNCTION__,i2s_wm8759_dma_handshake_left_tx.transfer_bytes,i2s_wm8759_dma_handshake_left_tx.channel_num,DMAC_CH_SIZE_REG(i2s_wm8759_dma_handshake_left_tx.channel_num));
+
+	}else{
+		llen=lpos=0;
+	}
+	}
+
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t str8100_dma_err_irq_handler(int this_irq, void *dev_id /*, struct pt_regs *regs*/)
+{
+	u32 dma_error_status,dma_ch;
+printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+
+	HAL_DMAC_READ_ERROR_ABORT_INTERRUPT_STATUS(dma_error_status);
+	for (dma_ch = 0; dma_ch < DMAC_MAX_CHANNEL_NUM; dma_ch++)
+	{
+		if (dma_error_status & DMAC_CH_ID(dma_ch))
+		{
+			printk("%s: this_irq=%d, DMA channel error on ch %d\n",__FUNCTION__,this_irq,dma_ch);
+			HAL_DMAC_DISABLE_CHANNEL(dma_ch);
+			HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(DMAC_CH_ID(dma_ch));
+		}
+	}	
+	
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+	return IRQ_HANDLED;
+}
+#endif //CONFIG_I2S_USE_DMA
+
+static irqreturn_t str8100_i2s_irq_handler(int this_irq, void *dev_id /*, struct pt_regs *regs*/)
+{
+	u32 interrupt_status;
+	DEBUG_PRINT("%s: this_irq=%d, I2S_INTERRUPT_STATUS_REG=0x%.8x,llen=%d,lpos=%d\n",__FUNCTION__,this_irq,I2S_INTERRUPT_STATUS_REG,llen,lpos);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	//todo:
+	interrupt_status = I2S_INTERRUPT_STATUS_REG;   
+if((llen<lpos)||llen==0)     HAL_I2S_DISABLE_I2S();
+
+#ifndef CONFIG_I2S_USE_DMA
+		I2S_RIGHT_TRANSMIT_DATA_REG=0;
+
+	if ((lpos<=llen) && (interrupt_status & I2S_TXBF_L_EMPTY_FLAG)){
+		switch(sample_size){
+			case 16:
+				I2S_LEFT_TRANSMIT_DATA_REG=(*((u16*)(&lbuffer[lpos])))<<16;lpos+=2;
+				break;
+			case 32:
+				I2S_LEFT_TRANSMIT_DATA_REG=*((u32*)(&lbuffer[lpos]));lpos+=4;
+				break;
+		}
+		
+		if(lpos>llen){
+			// Disable Left Channel's Transmit Buffer Interrupt Sources
+			I2S_INTERRUPT_ENABLE_REG &= ~(I2S_TXBF_L_EMPTY_FLAG | I2S_TXBF_L_UR_FLAG);
+			lpos=llen=0;
+		}
+	}
+#endif //!CONFIG_I2S_USE_DMA
+
+
+	if (llen>=lpos && (interrupt_status & I2S_TXBF_L_UR_FLAG)){
+		// Clear I2S interrupt status
+		i2s_err_lur++;
+		if(i2s_err_lur>10)
+			I2S_INTERRUPT_ENABLE_REG &= ~(I2S_TXBF_L_UR_FLAG);
+//			HAL_I2S_DISABLE_I2S();
+		
+		printk("%s: Left Channel Tx Underrun!,llen=%d, lpos=%d, interrupt_status=%.8x,i2s_err_lur=%d\n",__FUNCTION__,llen,lpos,interrupt_status,i2s_err_lur);
+	}
+	I2S_INTERRUPT_STATUS_REG &= 0xf0;
+
+	
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+static int str8100_i2s_init(void){
+	DEBUG_PRINT("%s: \n",__FUNCTION__);
+	int ret;
+	u32 tmp;
+	
+
+	/*
+	 * Select I2S clock source; here we use 48K sampling rate for the target file.
+	 */
+	 
+	switch(sampling_rate){
+	case 48000: 
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_12288000HZ(); 
+		break; 
+	case 44100:
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_11289600HZ(); 
+		break;
+	case 32000: 
+		HAL_PWRMGT_I2S_CLOCK_SOURCE_8192000HZ(); 
+		break; 
+	}
+	HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(11,0);
+	
+	// Enable I2S pins
+	HAL_MISC_ENABLE_I2S_PINS();
+	
+	// Enable I2S clock
+	HAL_PWRMGT_ENABLE_I2S_CLOCK(); 
+
+	//Hal_Pwrmgt_Software_Reset(PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);
+
+    /*
+     * Configure I2S to be Master & Transmitter
+     * Note the I2S's WS Clock is derived from Clock & Power Management Functional
+     * Block!!
+     */
+	I2S_CONFIGURATION_REG = /*(I2S_DATA_16_BIT << 0) |*/
+												(I2S_DATA_32_BIT << 0) |
+                        (0x0 << 4) |
+                        (0x0 << 12) |   /* Disable loopback */
+                        (0x0 << 15) |   /* Disable clock phase invert */
+                        (0x0 << 24) |   /* Disable I2S data swap */
+                        (I2S_CLOCK_256S_MODE << 25) |
+                        (I2S_I2S_MODE << 26) |
+                        (0x0 << 29) |   /* Enable I2S Transmitter */
+												(I2S_MASTER_MODE << 30) |
+												(0x0 << 31);	/* Disable I2S */
+
+	//Enable none while initializing
+	I2S_INTERRUPT_ENABLE_REG = 0x0;
+//	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG | I2S_TXBF_R_EMPTY_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+
+    // Clear spurious interrupt sources
+    I2S_INTERRUPT_STATUS_REG = 0xF0;
+
+    tmp = I2S_LEFT_RECEIVE_DATA_REG;
+    tmp = I2S_RIGHT_RECEIVE_DATA_REG;
+
+    // Disable I2S
+    HAL_I2S_DISABLE_I2S();
+
+	return 0;
+}
+
+
+//=================================================================================
+static int proc_read_i2s(char *buf, char **start, off_t offset,
+                   int count, int *eof, void *data)
+{
+	int len=0;
+	DEBUG_PRINT("%s:\n",__FUNCTION__);
+	len += sprintf(buf,	"sampling_rate=%d\n"
+				"sample_size=%d\n"
+			,sampling_rate,sample_size); 
+	*eof = 1;
+	return len;
+}
+
+static proc_write_i2s(struct file *file, const char *buffer, unsigned long count, void *data){
+	int len=0;
+	DEBUG_PRINT("%s: sample size %d, sampling rate %d, count=%d\n",__FUNCTION__,sample_size,sampling_rate,count);
+	
+	//is buffer free?
+	if(lpos!=llen){
+		printk("%s: buffer not free\n");
+		return -EBUSY;
+	}
+	if(sampling_rate!=32000&&sampling_rate!=44100&&sampling_rate!=48000){
+		printk("%s: invalid sampling rate(%d)\n",sampling_rate);
+		return -EFAULT;
+	}
+	if(sample_size!=16&&sample_size!=32){
+		printk("%s: invalid sample size(%d)\n",sample_size);
+		return -EFAULT;
+	}
+
+	//copy the raw data to local buffer	
+	if(count>BUFSIZE) len=BUFSIZE;
+	else len=count;
+	
+	if(copy_from_user(lbuffer,buffer,len)){
+		return -EFAULT;	
+	}
+	llen=len;
+	lpos=0;
+	i2s_err_lur=0;
+	
+	str8100_i2s_init();
+
+#ifdef CONFIG_I2S_USE_DMA
+    /*
+     * Configure DMA for hardware handshake for I2S
+     * Note the DMA is NOT enabled after invoking the following function, but the specified
+     * DMA channels are enabled!!
+     */
+    i2s_wm8759_dma_right_tx_channel = 1;   
+
+    I2s_WM8759_Configure_DMA_Hardware_Handshake();  
+
+#endif //CONFIG_I2S_USE_DMA
+	//fill the tx left/right registers
+
+		switch(sample_size){
+			case 16:
+				I2S_LEFT_TRANSMIT_DATA_REG=(*((u16*)(&lbuffer[lpos])))<<16;lpos+=2;
+				break;
+			case 32:
+				I2S_LEFT_TRANSMIT_DATA_REG=*((u32*)(&lbuffer[lpos]));lpos+=4;
+				break;
+		}
+
+	I2S_RIGHT_TRANSMIT_DATA_REG=0;
+
+#ifdef CONFIG_I2S_USE_DMA
+	/*
+	 * Enable I2S's interrupt sources
+	 * Note for DMA hardware handshake, we only need to enable Left/Right Channel's 
+	 * Transmit Buffer Underrun.
+	 */
+#ifdef DEBUG	
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_L_UR_FLAG);
+#else
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG);
+#endif
+#else //CONFIG_I2S_USE_DMA
+#ifdef DEBUG	
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_L_UR_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+#else
+	I2S_INTERRUPT_ENABLE_REG |= (I2S_TXBF_R_UR_FLAG | I2S_TXBF_L_UR_FLAG | I2S_TXBF_R_EMPTY_FLAG | I2S_TXBF_L_EMPTY_FLAG);
+#endif
+#endif //CONFIG_I2S_USE_DMA
+
+	// Enable CPU interrupt
+	local_irq_enable();
+	
+#ifdef CONFIG_I2S_USE_DMA
+	/*
+	 * Note DMA must be enabled first before I2S is enabled
+	 */
+	HAL_DMAC_ENABLE();
+#endif //CONFIG_I2S_USE_DMA
+	HAL_I2S_ENABLE_I2S();
+
+
+	while (1){
+		local_irq_disable();
+		if (lpos>llen||llen==0){
+			// Disable I2S
+			HAL_I2S_DISABLE_I2S();
+			break;
+		}
+		local_irq_enable();
+	}
+	DEBUG_PRINT("%s: exit. i2s_err_lur=%d\n",__FUNCTION__,i2s_err_lur);
+
+	local_irq_enable();
+
+	return len;
+
+debug:
+	HAL_I2S_DISABLE_I2S();
+	return count;
+}
+
+static void __devexit i2s_exit_module(void)
+{
+	printk("%s:\n",__FUNCTION__);
+	remove_proc_entry("str8100/i2s", NULL);
+	free_irq(INTC_I2S_BIT_INDEX, NULL);
+#ifdef CONFIG_I2S_USE_DMA
+	free_irq(INTC_GDMAC_TC_BIT_INDEX, NULL);
+	free_irq(INTC_GDMAC_ERROR_BIT_INDEX, NULL);
+#endif //CONFIG_I2S_USE_DMA
+	if(lbuffer) {
+		pci_free_consistent(NULL, BUFSIZE, lbuffer, lbuffer_p);
+		lbuffer=lbuffer_p=NULL;
+	}
+}
+
+static int __devinit i2s_init_module(void)
+{
+	u32 ret;
+	
+	printk("%s:\n",__FUNCTION__);
+#ifdef CONFIG_I2S_USE_DMA
+	printk("%s: DMA Enabled...\n",__FUNCTION__);
+#endif //CONFIG_I2S_USE_DMA
+
+	star_i2s_proc_entry = create_proc_entry("str8100/i2s", S_IFREG | S_IRUGO, NULL);
+	if(!star_i2s_proc_entry){
+		return -EBUSY;
+	}
+	star_i2s_proc_entry->read_proc=proc_read_i2s;
+	star_i2s_proc_entry->write_proc=proc_write_i2s;
+	
+	lbuffer = pci_alloc_consistent(NULL, BUFSIZE, &lbuffer_p);
+	if(!lbuffer){
+		printk("%s: alloc lbuffer failed.\n",__FUNCTION__);
+		goto exit1;
+	}
+
+	str8100_set_interrupt_trigger (INTC_I2S_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);
+	if ((ret=request_irq(INTC_I2S_BIT_INDEX, str8100_i2s_irq_handler, 0, "i2s", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_I2S_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+
+#ifdef CONFIG_I2S_USE_DMA
+	str8100_set_interrupt_trigger (INTC_GDMAC_TC_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_TC_BIT_INDEX, str8100_dma_tc_irq_handler, 0, "dma tc", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_TC_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+	str8100_set_interrupt_trigger (INTC_GDMAC_ERROR_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GDMAC_ERROR_BIT_INDEX, str8100_dma_err_irq_handler, 0, "dma error", NULL))){
+		printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_GDMAC_ERROR_BIT_INDEX,ret,-EBUSY);
+		goto exit1;
+	}
+#endif //CONFIG_I2S_USE_DMA
+
+	return 0;
+exit1:
+	i2s_exit_module();
+	return -EBUSY;
+}
+
+module_init(i2s_init_module);
+module_exit(i2s_exit_module);
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_intc.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_intc.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_intc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_intc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,222 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <mach/hardware.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+
+#define INTC_TRIGGER_UNKNOWN -1
+
+typedef struct
+{
+	int	mode;
+	int	level;
+} intc_trigger_t;
+
+static intc_trigger_t intc_trigger_table[] =
+{
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 0
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 1
+	{ INTC_EDGE_TRIGGER,	INTC_FALLING_EDGE	},	// 2
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 3
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 4
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 5
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 6
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 7
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 8
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 9
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 10
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 11
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 12
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 13
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 14
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 15
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 16
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 17
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 18
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 19
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 20
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 21
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 22
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 23
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 24
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 25
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 26
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 27
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 28
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 29
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 30
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 31
+};
+
+static u32 intc_edge_trigger_bitmap;
+
+/*
+ * Configure interrupt trigger mode to be level trigger or edge trigger
+ */
+static inline void str8100_set_irq_mode(unsigned int irq, unsigned int mode)
+{
+	volatile unsigned int val;
+
+	if (irq < 0 || irq > NR_IRQS) {
+		return;
+	}
+
+	if ((mode != INTC_LEVEL_TRIGGER) &&
+		(mode != INTC_EDGE_TRIGGER)) {
+		return;
+	}
+
+	val = INTC_INTERRUPT_TRIGGER_MODE_REG;
+
+	if (mode == INTC_LEVEL_TRIGGER) {
+		if (val & (1UL << irq)) {
+			val &= ~(1UL << irq);
+			INTC_INTERRUPT_TRIGGER_MODE_REG = val;
+		}
+	} else {
+		intc_edge_trigger_bitmap |= (1UL << irq);
+		if (!(val & (1UL << irq))) {
+			val |= (1UL << irq);
+			INTC_INTERRUPT_TRIGGER_MODE_REG = val;
+		}
+	}
+}	
+
+/*
+ * Configure interrupt trigger level to be Active High/Low or Rising/Falling Edge
+ */
+static inline void str8100_set_irq_level(unsigned int irq, unsigned int level)
+{
+	volatile unsigned int val;
+
+	if (irq < 0 || irq > NR_IRQS) {
+		return;
+	}
+
+	if ((level != INTC_ACTIVE_HIGH) &&
+		(level != INTC_ACTIVE_LOW) &&
+		(level != INTC_RISING_EDGE) &&
+		(level != INTC_FALLING_EDGE)) {
+		return;
+	}
+
+	val = INTC_INTERRUPT_TRIGGER_LEVEL_REG;
+
+	if ((level == INTC_ACTIVE_HIGH) ||
+		(level == INTC_RISING_EDGE)) {
+		if (val & (1UL << irq)) {
+			val &= ~(1UL << irq);
+			INTC_INTERRUPT_TRIGGER_LEVEL_REG = val;
+		}
+	} else {
+		if (!(val & (1UL << irq))) {
+			val |= (1UL << irq);
+			INTC_INTERRUPT_TRIGGER_LEVEL_REG = val;
+		}
+	}
+}
+
+/*
+ * Configure interrupt trigger mode and trigger level
+ */
+void str8100_set_interrupt_trigger(unsigned int irq, unsigned int mode, unsigned int level)
+{
+	str8100_set_irq_mode(irq, mode);
+	str8100_set_irq_level(irq, level);
+}
+EXPORT_SYMBOL(str8100_set_interrupt_trigger);
+
+/*
+ * Mask/Disable this interrupt source
+ */
+void str8100_mask_irq(unsigned int irq)
+{
+      
+//	if (irq != INTC_NIC_RXRC_BIT_INDEX && irq != INTC_NIC_RXQF_BIT_INDEX) {
+		// Mask/Disable this interrupt source
+		INTC_INTERRUPT_MASK_REG = (1UL << irq);
+//	}
+}
+
+/*
+ * Un-Mask/Enable this interrupt source
+ */
+void str8100_unmask_irq(unsigned int irq)
+{
+         
+#ifndef CONFIG_VIC_INTERRUPT
+	// Clear interrupt status of the interrupt source which is edge-triggered
+	INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG = (1UL << irq);
+#endif
+	// Enable this interrupt source
+	INTC_INTERRUPT_MASK_CLEAR_REG = (1UL << irq);
+}
+
+static struct irq_chip str8100_irqchip = {
+	.ack	= str8100_mask_irq,
+	.mask	= str8100_mask_irq,
+	.unmask	= str8100_unmask_irq,
+};
+
+void __init str8100_init_irq(void)
+{
+	int i;
+
+   //printk("str8100_init_irq()\n");
+      
+   disable_hlt();
+   
+	INTC_INTERRUPT_MASK_REG = 0xFFFFFFFF;
+	INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG = 0xFFFFFFFF;
+	INTC_SOFTWARE_INTERRUPT_CLEAR_REG = 0xFFFFFFFF;
+	INTC_SOFTWARE_PRIORITY_MASK_REG = 0x0;
+	INTC_FIQ_SELECT_REG = 0x0;
+#ifdef CONFIG_VIC_INTERRUPT
+	for (i = 0; i < NR_IRQS; i++) {
+		(*((u32 volatile *)(SYSVA_VIC_BASE_ADDR + 0x40 + (i << 2)))) = i;
+	}
+	INTC_VECTOR_INTERRUPT_ENABLE_REG = 1;
+#else
+	INTC_VECTOR_INTERRUPT_ENABLE_REG = 0;
+#endif
+
+	for (i = 0; i < NR_IRQS; i++) {
+		if (intc_trigger_table[i].mode != INTC_TRIGGER_UNKNOWN) {
+			str8100_set_irq_mode(i, intc_trigger_table[i].mode);
+			str8100_set_irq_level(i, intc_trigger_table[i].level);
+		}
+	}
+	
+	for (i = 0; i < NR_IRQS;  i++) {
+		set_irq_chip(i, &str8100_irqchip);
+		/* scott.patch */
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_misc.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_misc.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_misc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_misc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,210 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
+
+static struct map_desc str8100_map_desc[64];
+static int str8100_map_desc_count;
+
+#define REG_DEBUG_CMD_BUFFER_SIZE	128
+#define REG_DEBUG_RESULT_BUFFER_SIZE	256
+
+struct proc_dir_entry *str8100_proc_dir;
+EXPORT_SYMBOL(str8100_proc_dir);
+static struct proc_dir_entry *star_reg_debug_proc_entry;
+static char str8100_reg_debug_cmd_buf[REG_DEBUG_CMD_BUFFER_SIZE];
+static char str8100_reg_debug_result_buf[REG_DEBUG_RESULT_BUFFER_SIZE];
+
+void str8100_register_map_desc(struct map_desc *map, int count)
+{
+	if (count) {
+		if (str8100_map_desc) {
+			int i;
+			for (i = 0; i < count; i++) {
+				str8100_map_desc[i].virtual = map->virtual;
+				str8100_map_desc[i].pfn = map->pfn;
+				str8100_map_desc[i].length = map->length;
+				str8100_map_desc[i].type = map->type;
+				map++;
+			}
+			str8100_map_desc_count = count;
+		}
+	}
+}
+
+u32 str8100_query_map_desc_by_phy(u32 addr)
+{
+	struct map_desc *map;
+	int i;
+	u32 ret_addr = 0;
+	for (i = 0; i < str8100_map_desc_count; i++) {
+		map = &str8100_map_desc[i];
+		if (addr >= (map->pfn << PAGE_SHIFT) && addr < ((map->pfn << PAGE_SHIFT) + map->length)) {
+			ret_addr = map->virtual + (addr - (map->pfn << PAGE_SHIFT));
+			break;
+		}
+	}
+
+	return ret_addr;
+}
+
+u32 str8100_query_map_desc_by_vir(u32 addr)
+{
+	struct map_desc *map;
+	int i;
+	u32 ret_addr = 0;
+	for (i = 0; i < str8100_map_desc_count; i++) {
+		map = &str8100_map_desc[i];
+		if (addr >= map->virtual && addr < (map->virtual + map->length)) {
+			ret_addr = (map->pfn << PAGE_SHIFT) + (addr - map->virtual);
+			break;
+		}
+	}
+
+	return ret_addr;
+}
+
+static int star_reg_debug_read_proc(char *buffer, char **start, off_t offset,
+	int length, int *eof, void *data)
+{
+	int count;
+	int num = 0;
+
+	if (str8100_reg_debug_cmd_buf[0]) {
+		count = strlen(str8100_reg_debug_cmd_buf);
+		sprintf(buffer, str8100_reg_debug_cmd_buf, count);
+		num += count;
+	}
+	if (str8100_reg_debug_result_buf[0]) {
+		count = strlen(str8100_reg_debug_result_buf);
+		sprintf(buffer + num, str8100_reg_debug_result_buf, count);
+		num += count;
+	}
+
+	return num;
+}
+
+static int
+star_reg_debug_write_proc(struct file *file, const char __user *buffer,
+	unsigned long count, void *data)
+{
+	char *str;
+	char *cmd;
+
+	if (count > 0) {
+		str = (char *)buffer,
+		cmd = strsep(&str, "\t \n");
+		if (!cmd) goto err_out;
+		if (strcmp(cmd, "dump") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 16);
+			if (addr & 0x3) goto err_out;
+			vir_addr = str8100_query_map_desc_by_phy(addr);
+			sprintf(str8100_reg_debug_cmd_buf,
+				"dump 0x%08x\n",
+				addr);
+			if (!vir_addr) goto err_out;
+			sprintf(str8100_reg_debug_result_buf,
+				"physical addr: 0x%08x content: 0x%08x\n",
+				addr,
+				*(volatile unsigned int __force *)(vir_addr));
+		} else if (strcmp(cmd, "write") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			u32 data;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 16);
+			arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			data = simple_strtoul(arg, &arg, 16);
+			if (addr & 0x3) goto err_out;
+			vir_addr = str8100_query_map_desc_by_phy(addr);
+			if (!vir_addr) goto err_out;
+			*(volatile unsigned int __force *)(vir_addr) = data;
+			sprintf(str8100_reg_debug_cmd_buf,
+				"write 0x%08x 0x%08x\n",
+				addr, data);
+			sprintf(str8100_reg_debug_result_buf,
+				"physical addr: 0x%08x content: 0x%08x\n",
+				addr,
+				*(volatile unsigned int __force *)(vir_addr));
+		} else {
+			goto err_out;
+		}
+	}
+
+	return count;
+
+err_out:
+	return -EFAULT;
+}
+
+static int __init star_reg_debug_proc_init(void)
+{
+	star_reg_debug_proc_entry = create_proc_entry("str8100/reg_debug", S_IFREG | S_IRUGO, NULL);
+	if (star_reg_debug_proc_entry) {
+		star_reg_debug_proc_entry->read_proc = star_reg_debug_read_proc;
+		star_reg_debug_proc_entry->write_proc = star_reg_debug_write_proc;
+	}
+
+	return 0;
+}
+
+static int __init str8100_proc_dir_create(void)
+{
+	str8100_proc_dir = proc_mkdir("str8100", NULL);
+	if (!str8100_proc_dir) {
+		printk("Error: cannot create str8100 proc dir entry at /proc/str8100\n");
+		return -EINVAL;
+	}
+
+	if (str8100_map_desc_count) {
+		(void)star_reg_debug_proc_init();
+	}
+
+	return 0;
+}
+
+extern int __init str8100_counter_setup(void);
+static int __init str8100_misc_init(void)
+{
+	str8100_proc_dir_create();
+	str8100_counter_setup();
+	return 0;
+}
+
+module_init(str8100_misc_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Star Semi Corporation");
+MODULE_DESCRIPTION("STR8100 MISC");
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_pci.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_pci.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_pci.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,337 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+//#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#define CONFIG_CMD(bus, device_fn, where) (0x80000000 | ((bus) << 16) | ((device_fn) << 8) | ((where) & ~3))
+
+static struct pci_dev *pci_bridge = NULL;
+static u32 pci_config_addr;				// PCI configuration register address port
+static u32 pci_config_data;				// PCI configuration register data port
+u32 str8100_pci_irqs[4] = {0, INTC_PCI_INTA_BIT_INDEX, INTC_PCI_INTB_BIT_INDEX, 0};
+
+static int str8100_pci_read_config(struct pci_bus *bus,
+	unsigned int devfn, int where, int size, u32 *val)
+{
+	u32 v = 0;
+	u32 shift;
+	unsigned long flags;
+
+	switch (size) {
+	case 1:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		v = (v >> shift) & 0xff;
+		break;
+
+	case 2:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		v = (v >> shift) & 0xffff;
+
+		break;
+
+	case 4:
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		break;
+	}
+
+	*val = v;
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int str8100_pci_write_config(struct pci_bus *bus,
+	unsigned int devfn, int where, int size, u32 val)
+{
+	u32 v;
+	u32 shift;
+	unsigned long flags;
+
+	switch (size) {
+	case 1:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		v = (v & ~(0xff << shift)) | (val << shift);
+		__raw_writel(v, pci_config_data);
+		local_irq_restore(flags);
+		break;
+
+	case 2:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		v = (v & ~(0xffff << shift)) | (val << shift);
+		__raw_writel(v, pci_config_data);
+		local_irq_restore(flags);
+		break;
+
+	case 4:
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		__raw_writel(val, pci_config_data);
+		local_irq_restore(flags);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops str8100_pci_ops = {
+	.read	= str8100_pci_read_config,
+	.write	= str8100_pci_write_config,
+};
+
+static struct resource str8100_pci_io = {
+	.name	= "PCI I/O space",
+	.start	= PCI_IO_SPACE_START,
+	.end	= PCI_IO_SPACE_END, //albert : 20040714
+	.flags	= IORESOURCE_IO,
+};
+
+static struct resource str8100_pci_nprefetch_mem = {
+	.name	= "PCI non-prefetchable",
+	.start	= PCI_NPREFETCH_MEMORY_SPACE_START,
+	.end	= PCI_NPREFETCH_MEMORY_SPACE_END,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource str8100_pci_prefetch_mem = {
+	.name	= "PCI prefetchable",
+	.start	= PCI_PREFETCH_MEMORY_SPACE_START,
+	.end	= PCI_PREFETCH_MEMORY_SPACE_END,
+	.flags	= IORESOURCE_MEM | IORESOURCE_PREFETCH,
+};
+
+static int __init str8100_pci_setup_resources(struct resource **resource)
+{
+	int ret = -1;
+
+	ret = request_resource(&iomem_resource, &str8100_pci_io);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate I/O "
+		       "memory region (%d)\n", ret);
+		goto out;
+	}
+	ret = request_resource(&iomem_resource, &str8100_pci_nprefetch_mem);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate non-prefetchable "
+		       "memory region (%d)\n", ret);
+		goto release_io;
+	}
+	ret = request_resource(&iomem_resource, &str8100_pci_prefetch_mem);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate prefetchable "
+		       "memory region (%d)\n", ret);
+		goto release_nprefetch_mem;
+	}
+
+	/*
+	 * bus->resource[0] is the IO resource for this bus
+	 * bus->resource[1] is the mem resource for this bus
+	 * bus->resource[2] is the prefetch mem resource for this bus
+	 */
+	resource[0] = &str8100_pci_io;
+	resource[1] = &str8100_pci_nprefetch_mem;
+	resource[2] = &str8100_pci_prefetch_mem;
+
+	ret = 0;
+
+	goto out;
+
+release_nprefetch_mem:
+	release_resource(&str8100_pci_nprefetch_mem);
+release_io:
+	release_resource(&str8100_pci_io);
+out:
+	return ret;
+}
+
+static irqreturn_t PCI_AHB2PCIB_ISR(int irq, void *dev_id /*, struct pt_regs * regs*/)
+{
+	u32 status;
+
+	//disable_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX);
+	pci_read_config_dword(pci_bridge, PCI_COMMAND, &status);
+	printk("AHB to bridge interrupt status: 0x%x\n", status);
+	pci_write_config_dword(pci_bridge, PCI_COMMAND, status);
+	//enable_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t PCI_BROKEN_ISR(int irq, void *dev_id /*, struct pt_regs *regs*/)
+{
+	u32 status;
+
+	status = MISC_PCI_BROKEN_STATUS_REG & 0x1f;
+	printk("PCI BROKEN interrupt status: 0x%x\n", status);
+	MISC_PCI_BROKEN_STATUS_REG = status;
+
+	return IRQ_HANDLED;
+}
+
+int __init str8100_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	if (nr != 0) {
+		return 0;
+	}
+
+	if (str8100_pci_setup_resources(sys->resource)) {
+		BUG();
+	}
+
+	return 1;
+}
+
+struct pci_bus * __devinit str8100_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	return pci_scan_bus(sys->busnr, &str8100_pci_ops, sys);
+}
+
+void __init str8100_pci_preinit(void)
+{
+	pci_config_addr = SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR + PCI_BRIDGE_CONFIG_ADDR_REG_OFFSET;
+	pci_config_data = SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR + PCI_BRIDGE_CONFIG_DATA_REG_OFFSET;
+
+	HAL_MISC_ENABLE_PCI_PINS();
+
+#ifdef  CONFIG_STR8100_PCI66M
+	printk("PCI clock at 66M\n");
+	HAL_PWRMGT_ENABLE_PCI_BRIDGE_66M_CLOCK();
+#else
+	printk("PCI clock at 33M\n");
+	HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M_CLOCK();
+#endif
+}
+
+void __init str8100_pci_postinit(void)
+{
+//	pci_bridge = pci_find_device(PCIB_VENDOR_ID, PCIB_DEVICE_ID, NULL);
+	pci_bridge = pci_get_device(PCIB_VENDOR_ID, PCIB_DEVICE_ID, NULL);
+	if (pci_bridge == NULL) {
+		printk("PCI Bridge not found\n");
+		return;
+	} else {
+		printk("PCI Bridge found\n");
+	} 
+
+	/* scott.patch 
+	request_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX, PCI_AHB2PCIB_ISR, SA_INTERRUPT, "pci bridge", pci_bridge);
+	*/
+	request_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX, PCI_AHB2PCIB_ISR, IRQF_DISABLED, "pci bridge", (void*)pci_bridge);
+
+	MISC_PCI_CONTROL_BROKEN_MASK_REG &= ~0x1f;
+
+	/* scott.patch */
+	request_irq(INTC_PCI_BROKEN_BIT_INDEX, PCI_BROKEN_ISR, IRQF_DISABLED, "pci broken", pci_bridge);
+
+	//albert :20040803
+	pci_write_config_dword(pci_bridge, PCI_BASE_ADDRESS_0, 0x0); // = 0x0, can NOT use 0x20000000
+	pci_write_config_dword(pci_bridge, PCI_BASE_ADDRESS_1, 0x0); // = 0x0, can NOT use 0x20000000
+
+	// if we enable pci on u-boot
+	// the pci_enable_device will complain with resource collisions
+	// use this to fixup
+	{
+		int i;
+		struct resource *r;
+
+		for (i = 0; i < 6; i++) {
+			r = pci_bridge->resource + i;
+			r->start = 0;
+			r->end = 0;
+		}
+	}
+
+	pci_enable_device(pci_bridge);
+	pci_set_master(pci_bridge);
+
+	pci_write_config_byte(pci_bridge, PCI_CACHE_LINE_SIZE, 0x8); //configure cache line size
+	pci_write_config_byte(pci_bridge, PCI_LATENCY_TIMER, 0x30); //configure latency timer
+}
+
+/*
+ * map the specified device/slot/pin to an IRQ.   Different backplanes may need to modify this.
+ */
+static int __init str8100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/* slot,  pin,	irq
+	 * 0      1     0
+	 * 1      1     5
+	 * 2      1     6
+	 * 3      1     0
+	 */
+	irq = str8100_pci_irqs[((slot + pin - 1) & 3)];
+
+	printk("PCI map irq: %02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
+		slot, pin, irq);
+
+	return irq;
+}
+
+static struct hw_pci str8100_pci __initdata = {
+	.swizzle		= pci_std_swizzle,
+	.map_irq		= str8100_pci_map_irq,
+	.nr_controllers		= 1,
+	.setup			= str8100_pci_setup,
+	.scan			= str8100_pci_scan_bus,
+	.preinit		= str8100_pci_preinit,
+	.postinit		= str8100_pci_postinit,
+};
+
+static int __init str8100_pci_init(void)
+{
+	pci_common_init(&str8100_pci);
+	return 0;
+}
+
+subsys_initcall(str8100_pci_init);
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_pm.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_pm.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_pm.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_pm.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,162 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+
+#include <asm/mach-types.h>
+#include <linux/suspend.h>
+
+#ifdef CONFIG_PM
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_Cpu_Enter_Sleep_Mode
+ * PURPOSE:   
+ *
+ ******************************************************************************/
+#ifdef CONFIG_PM_DEBUG
+#define PM_DEBUG printk
+#else
+#define PM_DEBUG(_parm,...) 
+#endif
+void inline Hal_Cpu_Enter_Sleep_Mode(void)
+{
+	__asm__ volatile (
+				"nop\n"
+				"mcr	p15, 0, r0, c7, c0, 5\n");
+}
+
+static int str8100_pm_prepare(suspend_state_t state)
+{
+	int error = 0;
+	PM_DEBUG("%s: state=%d\n",__FUNCTION__,state);
+	switch (state)
+	{
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return error;
+}
+
+extern int str8100_nic_suspend(suspend_state_t);
+extern int str8100_nic_resume(void);
+static int str8100_pm_enter(suspend_state_t state)
+{
+	PM_DEBUG("%s: state=%d\n",__FUNCTION__,state);
+	switch (state)
+	{
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+
+#ifdef DEBUG
+		/*
+		* Configure system Xtal clock to be output to CLKOUT pin
+		*/
+		HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(0, 0);
+#endif
+
+		/*
+		* 1. Disable DRAM Controller's clock
+		* 2. Power-down sytem 25MHz XTAL pad
+		* 3. Force CPU into sleep mode, and wait until wake-up interrupt happens!!
+		*    When in sleep mode, CPU internal clock and system PLLs and/or 25MHZ XTAL 
+		*    pad will be power-down!!
+		*/
+
+//int 16, 18, 28-30
+//#define WAKEUP_INT 0x70050000
+//int 16, 18, 29-30
+//#define WAKEUP_INT 0x60050000
+//int 18, 29-30
+#define WAKEUP_INT 0x60040000
+//int 29-30
+//#define WAKEUP_INT 0x60000000
+//#define WAKEUP_INT 0xffffffff
+		PM_DEBUG("%s: int that can wake cpu up, WAKEUP_INT=%.8x\n",__FUNCTION__,WAKEUP_INT);
+//		HAL_INTC_SELECT_INTERRUPT_SOURCE_FOR_SLEEP_WAKEUP(30);
+		INTC_POWER_MANAGEMENT_INTERRUPT_REG=WAKEUP_INT;
+		HAL_PWRMGT_DISABLE_DRAMC_CLOCK();
+#ifndef CONFIG_STAR_NIC_PHY_INTERNAL_PHY
+		HAL_PWRMGT_POWER_DOWN_SYSTEM_XTAL_PAD();
+#endif
+
+		PM_DEBUG("%s: bye...\n",__FUNCTION__);
+		str8100_nic_suspend(state);
+		local_irq_enable();
+		Hal_Cpu_Enter_Sleep_Mode();
+		local_irq_disable();
+		str8100_nic_resume();
+		PM_DEBUG("%s: awake from sleep\n",__FUNCTION__);
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+/*
+static int str8100_pm_finish(suspend_state_t state)
+{
+printk("%s: \n",__FUNCTION__);
+	return 0;
+}
+*/
+
+static struct platform_suspend_ops str8100_pm_ops ={
+        .prepare        = str8100_pm_prepare,
+        .enter          = str8100_pm_enter,
+//		.finish         = str8100_pm_finish,
+};
+
+static int __init str8100_pm_init(void)
+{
+	int ret;
+printk("%s: \n",__FUNCTION__);
+
+    /*
+     * Configure system Xtal clock to be output to CLKOUT pin
+     */
+	HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(0, 0);
+
+	suspend_set_ops(&str8100_pm_ops);
+	return 0;
+}
+__initcall(str8100_pm_init);
+
+
+#endif//CONFIG_PM
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_rtc.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_rtc.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_rtc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_rtc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,497 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/sysctl.h>
+#include <linux/rtc.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <mach/star_rtc.h>
+#include <mach/star_intc.h>
+
+#define STR8100_RTC_DATE       "20060628"
+#define STR8100_RTC_VERSION    "1.0.0"
+#define DEVICE_NAME            "rtc"
+#define SECS_PER_HOUR   (60 * 60)
+#define SECS_PER_DAY    (SECS_PER_HOUR * 24)
+#define TM_YEAR_BASE            1900
+#define EPOCH_YEAR              1970
+#define RTC_INTR_ALARM		0x20
+
+extern spinlock_t rtc_lock;
+
+static int rtc_busy = 0;
+static unsigned long epoch = 1900;
+static unsigned int  rtc_interrupt_flag = 0;
+static time_t local_rtc_offset, set_rtc_offset, current_rtc_time;
+static DECLARE_WAIT_QUEUE_HEAD(str8100_rtc_wait);
+
+
+# define __isleap(year) ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+
+static const unsigned char days_in_mo[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+                                                                                
+static const unsigned short int __mon_yday[2][13] =
+{
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
+static int offtime (const time_t *t, long int offset, struct rtc_time *tp)
+{
+    long int days, rem, y;
+    const unsigned short int *ip;
+				                                                                                
+    days = *t / SECS_PER_DAY;
+    rem = *t % SECS_PER_DAY;
+    rem += offset;
+    while (rem < 0)
+    {
+         rem += SECS_PER_DAY;
+   	 --days;
+    }
+    while (rem >= SECS_PER_DAY)
+    {
+         rem -= SECS_PER_DAY;
+  	 ++days;
+    }
+    tp->tm_hour = rem / SECS_PER_HOUR;
+    rem %= SECS_PER_HOUR;
+    tp->tm_min = rem / 60;
+    tp->tm_sec = rem % 60;
+    tp->tm_wday = (4 + days) % 7;
+    if (tp->tm_wday < 0)
+      tp->tm_wday += 7;
+    y = 1970;														                                                                                
+#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))
+#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))							                                                                                
+    while (days < 0 || days >= (__isleap (y) ? 366 : 365))
+    {
+   	 long int yg = y + days / 365 - (days % 365 < 0);  
+   	 days -= ((yg - y) * 365 + LEAPS_THRU_END_OF (yg - 1)- LEAPS_THRU_END_OF (y - 1));
+   	 y = yg;
+    }
+    tp->tm_year = y - 1900;
+    if (tp->tm_year != y - 1900)
+      return 0;
+    tp->tm_yday = days;
+    ip = __mon_yday[__isleap(y)];
+    for (y = 11; days < (long int) ip[y]; --y)
+       continue;
+    days -= ip[y];
+    tp->tm_mon = y;
+    tp->tm_mday = days + 1;
+    return 1;
+}
+
+static time_t ydhms_tm_diff (int year, int yday, int hour, int min, int sec, const struct rtc_time *tp)
+{
+    if (!tp) return 1;
+    else {
+      int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
+      int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
+      int a100 = a4 / 25 - (a4 % 25 < 0);
+      int b100 = b4 / 25 - (b4 % 25 < 0);
+      int a400 = a100 >> 2;
+      int b400 = b100 >> 2;
+      int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
+      time_t years = year - (time_t) tp->tm_year;
+      time_t days = (365 * years + intervening_leap_days + (yday - tp->tm_yday));
+      return (60 * (60 * (24 * days+(hour - tp->tm_hour))+(min - tp->tm_min))+(sec - tp->tm_sec));
+    }
+}
+
+static time_t _mktime(struct rtc_time *tp, time_t *offset)
+{
+    time_t t;
+    struct rtc_time tm;
+    int sec = tp->tm_sec;
+    int min = tp->tm_min;
+    int hour = tp->tm_hour;
+    int mday = tp->tm_mday;
+    int mon = tp->tm_mon;
+    int year_requested = tp->tm_year;
+
+    int mon_remainder = mon % 12;
+    int negative_mon_remainder = mon_remainder < 0;
+    int mon_years = mon / 12 - negative_mon_remainder;
+    int year = year_requested + mon_years;
+    int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
+  	       [mon_remainder + 12 * negative_mon_remainder])
+  	       + mday - 1);
+    if (year < 69) return -1;
+    tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
+    tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
+    t = ydhms_tm_diff (year, yday, hour, min, sec, &tm);
+    if (year == 69)
+    {
+      if (t < 0 || t > 2 * 24 * 60 * 60) return -1;
+    }
+    *tp = tm;
+    return t;
+}
+
+void get_rtc_time (struct rtc_time *rtc_tm)
+{
+    time_t update_time;	
+    
+    spin_lock (&rtc_lock);
+    update_time =  RTC_SECOND_REG + RTC_MINUTE_REG * 60 + RTC_HOUR_REG * 60 * 60 + RTC_DAY_REG * 60 * 60 * 24 - local_rtc_offset + set_rtc_offset;
+    offtime(&update_time, 0, rtc_tm);	
+    if ((rtc_tm->tm_year += (epoch - 1900)) <= 69)
+      rtc_tm->tm_year += 100; 
+    spin_unlock (&rtc_lock);
+}
+
+int set_rtc_time (struct rtc_time *rtc_tm)
+{
+    unsigned char mon, day, hrs, min, sec, leap_yr;
+    unsigned int yrs;
+    
+    spin_lock (&rtc_lock);
+    yrs = rtc_tm->tm_year + 1900;
+    mon = rtc_tm->tm_mon + 1;  
+    day = rtc_tm->tm_mday;
+    hrs = rtc_tm->tm_hour;
+    min = rtc_tm->tm_min;
+    sec = rtc_tm->tm_sec; 
+    if (yrs < 1970) return -EINVAL;
+    leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+    if ((mon > 12) || (day == 0)) return -EINVAL;
+    if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr))) return -EINVAL;
+    if ((hrs >= 24) || (min >= 60) || (sec >= 60)) return -EINVAL;
+    if ((yrs -= epoch) > 255) return -EINVAL;   
+    local_rtc_offset = RTC_SECOND_REG + RTC_MINUTE_REG * 60 + RTC_HOUR_REG * 60 * 60 + RTC_DAY_REG * 60 * 60 * 24;
+    set_rtc_offset = _mktime(rtc_tm, 0);
+    spin_unlock (&rtc_lock);
+    return 0;
+}
+
+int set_rtc_alm_time (struct rtc_time *alm_tm)
+{
+    unsigned char hrs, min, sec;
+    unsigned long alm_sec;
+    unsigned int volatile rtc_int_status;
+    
+    spin_lock_irq(&rtc_lock);
+    alm_sec = alm_tm->tm_hour * 3600 + alm_tm->tm_min * 60 + alm_tm->tm_sec;
+    hrs = alm_sec / 3600;
+    min = (alm_sec % 3600) / 60;
+    sec = (alm_sec % 3600) % 60;
+    RTC_HOUR_ALARM_REG = hrs;
+    RTC_MINUTE_ALARM_REG = min;
+    RTC_SECOND_ALARM_REG = sec;
+    RTC_CONTROL_REG = RTC_MATCH_ALARM_ENABLE_BIT;
+    rtc_int_status = RTC_INTERRUPT_STATUS_REG;
+    RTC_INTERRUPT_STATUS_REG = rtc_int_status;                      
+    spin_unlock_irq(&rtc_lock);    
+    return 0;
+}
+
+static loff_t rtc_lseek(struct file *file, loff_t offset, int origin)
+{
+    return -ESPIPE;
+}
+
+static void mask_rtc_irq_bit(unsigned char bit)
+{
+    unsigned char val;
+    unsigned int volatile rtc_int_status;
+
+    spin_lock_irq(&rtc_lock);
+    val = RTC_CONTROL_REG;
+    val &=  ~bit;
+    RTC_CONTROL_REG = val;
+    rtc_int_status = RTC_INTERRUPT_STATUS_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static void set_rtc_irq_bit(unsigned char bit)
+{
+    unsigned char val;
+    unsigned int volatile rtc_int_status;	
+        
+    spin_lock_irq(&rtc_lock);
+    val = RTC_CONTROL_REG;
+    val |= bit;
+    RTC_CONTROL_REG = val;
+    rtc_int_status = RTC_INTERRUPT_STATUS_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static void get_rtc_alm_time(struct rtc_time *alm_tm)
+{
+    spin_lock_irq(&rtc_lock);
+    alm_tm->tm_sec = RTC_SECOND_ALARM_REG;
+    alm_tm->tm_min = RTC_MINUTE_ALARM_REG;
+    alm_tm->tm_hour = RTC_HOUR_ALARM_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,unsigned long arg)
+{
+    struct rtc_time wtime; 
+
+    switch (cmd)
+    {
+	case RTC_RD_TIME:
+	        memset(&wtime, 0, sizeof(struct rtc_time));
+		get_rtc_time(&wtime);
+		break;
+	case RTC_SET_TIME:
+	{         
+		struct rtc_time rtc_tm;
+		if (!capable(CAP_SYS_TIME))
+		  return -EPERM;
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))
+		  return -EFAULT;
+		set_rtc_time(&rtc_tm);
+		return 0;
+	}	
+        case RTC_ALM_SET:
+        {
+        	struct rtc_time alm_tm; 
+		if (copy_from_user(&alm_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))
+		  return -EFAULT;
+		memset(&wtime, 0, sizeof(struct rtc_time));  
+		set_rtc_alm_time(&alm_tm);
+		return 0;
+	}	
+	case RTC_ALM_READ:
+	        memset(&wtime, 0, sizeof(struct rtc_time));
+		get_rtc_alm_time(&wtime);
+		break;
+	case RTC_AIE_OFF:
+	        mask_rtc_irq_bit(RTC_INTR_ALARM);	
+		return 0;
+	case RTC_AIE_ON:
+	        set_rtc_irq_bit(RTC_INTR_ALARM);
+		return 0;	
+	default:
+		return -EINVAL;
+    }
+    return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+// Eileen , for linux kernel 2.6.24 , 20080417
+// old : static irqreturn_t rtc_fire(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t rtc_fire(int irq, void *dev_id)
+{
+    unsigned int volatile    rtc_int_status;	
+    
+    HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_RTC_BIT_INDEX);
+    HAL_RTC_READ_INTERRUPT_STATUS(rtc_int_status);
+    HAL_RTC_WRITE_INTERRUPT_STATUS(rtc_int_status);
+//    HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_RTC_BIT_INDEX);
+//    return IRQ_HANDLED; 
+    if (rtc_int_status & RTC_AUTO_SECOND_ALARM_INTR_BIT) rtc_interrupt_flag |= RTC_AUTO_SECOND_ALARM_INTR_BIT;
+    if (rtc_int_status & RTC_AUTO_MINUTE_ALARM_INTR_BIT) rtc_interrupt_flag |= RTC_AUTO_MINUTE_ALARM_INTR_BIT;
+    if (rtc_int_status & RTC_AUTO_HOUR_ALARM_INTR_BIT) rtc_interrupt_flag |= RTC_AUTO_HOUR_ALARM_INTR_BIT;
+    if (rtc_int_status & RTC_AUTO_DAY_ALARM_INTR_BIT) rtc_interrupt_flag |= RTC_AUTO_DAY_ALARM_INTR_BIT;
+    if (rtc_int_status & RTC_MATCH_ALARM_INTR_BIT) {rtc_interrupt_flag |= RTC_MATCH_ALARM_INTR_BIT;
+      wake_up_interruptible(&str8100_rtc_wait);
+    }
+    if (rtc_int_status & RTC_BATTERY_LOW_VOLTAGE_INTR_BIT)
+    {
+    	rtc_interrupt_flag |= RTC_BATTERY_LOW_VOLTAGE_INTR_BIT;
+        printk(" str8100 rtc: Low Battery Voltage!!\n");
+    }
+    if (!(rtc_interrupt_flag & RTC_MATCH_ALARM_INTR_BIT)) HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_RTC_BIT_INDEX);
+
+    return IRQ_HANDLED; 
+}
+
+static void rtc_str8100_hwinit(int ctrl, int hour, int min, int sec)
+{    	
+    RTC_CONTROL_REG &= ~(RTC_ENABLE_BIT);	
+    if (ctrl & RTC_MATCH_ALARM_ENABLE_BIT)
+    {
+      RTC_SECOND_ALARM_REG = sec;
+      RTC_MINUTE_ALARM_REG = min;
+      RTC_HOUR_ALARM_REG = hour;    	
+    }else{
+      RTC_SECOND_ALARM_REG = 0;
+      RTC_MINUTE_ALARM_REG = 0;
+      RTC_HOUR_ALARM_REG = 0;
+    } 
+    RTC_CONTROL_REG = ctrl;
+} 
+
+static int rtc_open(struct inode *inode, struct file *file)
+{
+    if (rtc_busy) return -EBUSY;
+
+    rtc_busy = 1;
+    return 0;
+}
+
+static ssize_t rtc_read(struct file * file, char *buf, size_t count, loff_t * ppos)
+{
+    DECLARE_WAITQUEUE(wait, current);
+    unsigned long data;
+    ssize_t retval;
+
+    if (count < sizeof(unsigned long))
+      return -EINVAL;
+
+    add_wait_queue(&str8100_rtc_wait, &wait);
+    set_current_state(TASK_INTERRUPTIBLE);
+    for (;;) {
+	spin_lock(&rtc_lock);
+	data = rtc_interrupt_flag;
+	if (data != 0) {
+	  rtc_interrupt_flag = 0;
+	  break;
+	}
+        spin_unlock(&rtc_lock);
+        if (file->f_flags & O_NONBLOCK) {
+	  retval = -EAGAIN;
+	  goto out;
+	}
+	if (signal_pending(current)) {
+	  retval = -ERESTARTSYS;
+	  goto out;
+	}
+        schedule();
+    }
+    spin_unlock(&rtc_lock);
+    retval = put_user(data, (unsigned long *) buf);
+    if (!retval) retval = sizeof(unsigned long);
+out:
+    mask_rtc_irq_bit(RTC_INTR_ALARM);
+    set_current_state(TASK_RUNNING);
+    remove_wait_queue(&str8100_rtc_wait, &wait);
+    return retval;
+}
+
+static int rtc_release(struct inode *inode, struct file *file)
+{
+    rtc_busy = 0;
+    return 0;
+}
+
+static struct file_operations rtc_fops = {
+    owner:	THIS_MODULE,
+    llseek:	rtc_lseek,
+    ioctl:	rtc_ioctl,
+    open:	rtc_open,
+    read:       rtc_read,
+    release:	rtc_release
+};
+
+static struct miscdevice rtc_dev = { RTC_MINOR, "rtc", &rtc_fops };
+
+static int rtc_proc_output (char *buf)
+{
+    char *p;
+    struct rtc_time tm;
+    
+    p = buf;
+    get_rtc_time(&tm);
+    p += sprintf(p,"rtc_time\t: %02d:%02d:%02d\n"
+		   "rtc_date\t: %04d-%02d-%02d\n"
+	 	   "rtc_epoch\t: %04lu\n",
+		   tm.tm_hour, tm.tm_min, tm.tm_sec,
+		   tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, epoch);
+    get_rtc_alm_time(&tm);
+    p += sprintf(p, "alarm\t\t: ");
+    if (tm.tm_hour <= 24)
+      p += sprintf(p, "%02d:", tm.tm_hour);
+    else
+      p += sprintf(p, "**:");
+    if (tm.tm_min <= 59)
+      p += sprintf(p, "%02d:", tm.tm_min);
+    else
+      p += sprintf(p, "**:");
+    if (tm.tm_sec <= 59)
+      p += sprintf(p, "%02d\n", tm.tm_sec);
+    else
+      p += sprintf(p, "**\n");	
+    return  p - buf;
+}
+
+static int rtc_read_proc(char *page, char **start, off_t off,int count, int *eof, void *data)
+{
+    int len = rtc_proc_output (page);
+    
+    if (len <= off+count) *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len>count) len = count;
+    if (len<0) len = 0;
+    return len;
+}
+
+static int __init str8100_rtc_init(void)
+{
+    int error;
+
+    error = misc_register(&rtc_dev);
+    if (error) {
+      printk(KERN_ERR "rtc: unable to get misc minor\n");
+      return error;
+    }	
+    printk(KERN_INFO "str8100_rtc.o: rtc module version %s\n", STR8100_RTC_VERSION);
+    rtc_str8100_hwinit(0,0,0,0);
+    HAL_RTC_ENABLE();
+    request_irq(INTC_RTC_BIT_INDEX, rtc_fire, 0, DEVICE_NAME, NULL);
+    create_proc_read_entry ("driver/rtc", 0, 0, rtc_read_proc, NULL);
+    local_rtc_offset = 0;
+    set_rtc_offset = current_rtc_time = 0;        
+    return 0;
+}
+
+static void __exit str8100_rtc_exit (void)
+{
+    char buf[64];
+    	
+    HAL_RTC_DISABLE();		
+    // Eileen , for linux kernel 2.6.24 , 20080417
+    // cleanup_sysctl();
+    sprintf (buf,"driver/%s",DEVICE_NAME);
+    remove_proc_entry (buf, NULL);
+    misc_deregister(&rtc_dev);
+    free_irq (INTC_RTC_BIT_INDEX, NULL);
+}
+
+module_init(str8100_rtc_init);
+module_exit(str8100_rtc_exit);
+// Eileen , for linux kernel 2.6.24 , 20080417
+//EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("Rober Hsu");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_setup.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_setup.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_setup.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_setup.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,569 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/mm.h>
+#include <linux/init.h>
+//#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_8250.h>
+#ifdef CONFIG_SPI_STR8100
+#include <mach/star_spi.h>
+#include <linux/spi/spi.h>
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+#include <linux/spi/flash.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#endif
+#endif // CONFIG_SPI_STR8100
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+#include <asm/system.h>
+#include <asm/memory.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+
+
+#if 1 // on ASIC
+#define STR8100_UART_XTAL 24000000
+#else // on FPGA
+#define STR8100_UART_XTAL 13000000
+#endif
+
+#define EARLY_REGISTER_CONSOLE
+#define DEVICE_REGISTER_MULTIPLE
+
+/*
+ * Standard IO mapping
+ */
+static struct map_desc str8100_std_desc[] __initdata = {
+	{
+		.virtual	= SYSVA_FLASH_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_FLASH_SRAM_BANK0_BASE_ADDR),
+		.length		= SZ_8M,
+		.type		= MT_DEVICE
+	}, 	{
+		.virtual	= SYSVA_IDE_DEVICE_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_IDE_DEVICE_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_GDMAC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_GDMAC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_NIC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_NIC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_SPI_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_SPI_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCM_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCM_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_I2C_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_I2C_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_I2S_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_I2S_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_DDRC_SDRC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_DDRC_SDRC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_SMC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_SMC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_IDE_CONTROLLER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_IDE_CONTROLLER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_MISC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_MISC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_POWER_MANAGEMENT_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_POWER_MANAGEMENT_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_UART0_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_UART0_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_UART1_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_UART1_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_TIMER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_TIMER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_WATCHDOG_TIMER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_WATCHDOG_TIMER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_RTC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_RTC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_GPIOA_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_GPIOA_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_GPIOB_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_GPIOB_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB11_CONFIG_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB11_CONFIG_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB11_OPERATION_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB11_OPERATION_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB20_CONFIG_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB20_CONFIG_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB20_OPERATION_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB20_OPERATION_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB20_DEVICE_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB20_DEVICE_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_VIC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_VIC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}
+};
+
+#ifdef EARLY_REGISTER_CONSOLE
+static struct uart_port str8100_serial_ports[] = {
+	{
+		.membase	= (char*)(SYSVA_UART0_BASE_ADDR),
+		.mapbase	= (SYSPA_UART0_BASE_ADDR),
+		.irq		= INTC_UART0_BIT_INDEX,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= STR8100_UART_XTAL,
+		.line		= 0,
+		.type		= PORT_16550A,
+		.fifosize	= 16
+	} , {
+		.membase	= (char*)(SYSVA_UART1_BASE_ADDR),
+		.mapbase	= (SYSPA_UART1_BASE_ADDR),
+		.irq		= INTC_UART1_BIT_INDEX,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= STR8100_UART_XTAL,
+		.line		= 1,
+		.type		= PORT_16550A,
+		.fifosize	= 16
+	}
+};
+#else
+static struct resource str8100_uart0_resources[] = {
+	[0] = {
+		.start	= SYSPA_UART0_BASE_ADDR,
+		.end	= SYSPA_UART0_BASE_ADDR + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_UART0_BIT_INDEX,
+		.end	= INTC_UART0_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct resource str8100_uart1_resources[] = {
+	[0] = {
+		.start	= SYSPA_UART1_BASE_ADDR,
+		.end	= SYSPA_UART1_BASE_ADDR + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_UART1_BIT_INDEX,
+		.end	= INTC_UART1_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct plat_serial8250_port str8100_uart0_data[] = {
+	{
+		.membase	= (char*)(SYSVA_UART0_BASE_ADDR),
+		.mapbase	= (SYSPA_UART0_BASE_ADDR),
+		.irq		= INTC_UART0_BIT_INDEX,
+		.uartclk	= STR8100_UART_XTAL,
+		.regshift	= 2,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+	},
+	{  },
+};
+
+static struct plat_serial8250_port str8100_uart1_data[] = {
+	{
+		.membase	= (char*)(SYSVA_UART1_BASE_ADDR),
+		.mapbase	= (SYSPA_UART1_BASE_ADDR),
+		.irq		= INTC_UART1_BIT_INDEX,
+		.uartclk	= STR8100_UART_XTAL,
+		.regshift	= 2,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+	},
+	{  },
+};
+
+static struct platform_device str8100_uart0_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev.platform_data = str8100_uart0_data,
+	.num_resources = 2,
+	.resource = str8100_uart0_resources,
+};
+
+static struct platform_device str8100_uart1_device = {
+	.name = "serial8250",
+	.id = 1,
+	.dev.platform_data = str8100_uart1_data,
+	.num_resources = 2,
+	.resource = str8100_uart1_resources,
+};
+#endif
+
+
+static u64 usb_dmamask = 0xffffffffULL;
+static struct resource str8100_usb11_resources[] = {
+	[0] = {
+		.start	= SYSPA_USB11_CONFIG_BASE_ADDR,
+		.end	= SYSPA_USB11_CONFIG_BASE_ADDR + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_USB11_BIT_INDEX,
+		.end	= INTC_USB11_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device str8100_usb11_device = {
+	.name		= "str8100-ohci",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= str8100_usb11_resources,
+	.num_resources	= ARRAY_SIZE(str8100_usb11_resources),
+};
+
+static struct resource str8100_usb20_resources[] = {
+	[0] = {
+		.start	= SYSPA_USB20_CONFIG_BASE_ADDR,
+		.end	= SYSPA_USB20_CONFIG_BASE_ADDR + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_USB20_BIT_INDEX,
+		.end	= INTC_USB20_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device str8100_usb20_device = {
+	.name		= "str8100-ehci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= str8100_usb20_resources,
+	.num_resources	= ARRAY_SIZE(str8100_usb20_resources),
+};
+
+#ifdef CONFIG_SPI_STR8100
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+static struct mtd_partition str8100_spi_flash_partitions[] = {
+	{
+		.name =		"all",
+		.offset =	CONFIG_ARMBOOT_OFFSET,
+		.size =		0x800000-CONFIG_ARMBOOT_OFFSET,
+	},{
+		.name =		"ARMBOOT",
+		.offset =	CONFIG_ARMBOOT_OFFSET,
+		.size =		CONFIG_KERNEL_OFFSET-CONFIG_ARMBOOT_OFFSET,
+	},{
+		.name =		"Linux Kernel",
+		.offset =	CONFIG_KERNEL_OFFSET,
+		.size =		CONFIG_ROOTFS_OFFSET-CONFIG_KERNEL_OFFSET,
+	},{
+		.name =		"MTD Disk1",
+		.offset =	CONFIG_ROOTFS_OFFSET,
+		.size =		CONFIG_CFG_OFFSET-CONFIG_ROOTFS_OFFSET,
+	},{
+		.name =		"MTD Disk2",
+		.offset =	CONFIG_CFG_OFFSET,
+		.size =		0x800000-CONFIG_CFG_OFFSET,
+	}
+};
+
+static struct flash_platform_data str8100_spi_flash_data = {
+	.name = "m25p80",
+	.parts = str8100_spi_flash_partitions,
+	.nr_parts = ARRAY_SIZE(str8100_spi_flash_partitions),
+	.type = "m25p64",
+};
+
+#if defined(CONFIG_LE88221_CONTROL)
+static struct str8100_spi_dev_attr str8100_spi_le88221_attr = {
+	.spi_serial_mode = STR8100_SPI_SERIAL_MODE_MICROPROCESSOR,
+};
+#endif
+
+static struct spi_board_info str8100_spi_board_info[] = {
+        {
+		.modalias	= "m25p80",
+		.chip_select	= 0,
+		.max_speed_hz	= 25 * 1000 * 1000,
+		.bus_num	= 1,
+		.platform_data = &str8100_spi_flash_data,
+        },
+
+#if defined(CONFIG_LE88221_CONTROL)
+	{
+		.modalias	= "le88221",
+		.chip_select	= 1,
+		.max_speed_hz	= 25 * 1000 * 1000,
+		.bus_num	= 1,
+		.platform_data	= NULL,
+		.controller_data = &str8100_spi_le88221_attr,
+        },
+#endif
+};
+#endif
+
+static u64 spi_dmamask = 0xffffffffUL;
+static struct resource str8100_spi_resources[] = {
+	[0] = {
+		.start	= SYSPA_SPI_BASE_ADDR,
+		.end	= SYSPA_SPI_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_SPI_BIT_INDEX,
+		.end	= INTC_SPI_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device str8100_spi_master_device = {
+	.name		= "str8100_spi",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &spi_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= str8100_spi_resources,
+	.num_resources	= ARRAY_SIZE(str8100_spi_resources),
+};
+#endif // CONFIG_SPI_STR8100
+
+#ifdef DEVICE_REGISTER_MULTIPLE
+static struct platform_device *str8100_devices[] __initdata = {
+#ifndef EARLY_REGISTER_CONSOLE
+	&str8100_uart0_device,
+	&str8100_uart1_device,
+#endif
+#ifdef CONFIG_SPI_STR8100
+	&str8100_spi_master_device,
+#endif
+	&str8100_usb11_device,
+	&str8100_usb20_device
+};
+#endif
+
+static void __init str8100_fixup(struct machine_desc *desc,
+	struct tag *tags, char **cmdline, struct meminfo *mi)
+{      
+   mi->nr_banks = 1;
+	mi->bank[0].start = CONFIG_SYSTEM_DRAM_BASE;
+	mi->bank[0].size = CONFIG_SYSTEM_DRAM_SIZE << 20;
+	//mi->bank[0].node = 0;
+}
+
+/* ######################################################################### */
+#ifdef CONFIG_CPU_ISPAD_ENABLE 
+extern unsigned long __ispad_begin; 
+#endif
+u32 PLL_clock;
+u32 CPU_clock;
+u32 AHB_clock;
+u32 APB_clock;
+EXPORT_SYMBOL(PLL_clock);
+EXPORT_SYMBOL(CPU_clock);
+EXPORT_SYMBOL(AHB_clock);
+EXPORT_SYMBOL(APB_clock);
+// This function is called just after the
+// page table and cpu have been initialized
+
+#include "asm/procinfo.h"
+#include "asm/cacheflush.h"
+#include "asm/system.h"
+void __init str8100_early_init(void)
+{
+   //printk("str8100_early_init()\n");
+        
+	switch (PWRMGT_SYSTEM_CLOCK_CONTROL_REG & 0x3) {
+	case 0x0:
+		PLL_clock = 175000000;
+		break;
+	case 0x1:
+		PLL_clock = 200000000;
+		break;
+	case 0x2:
+		PLL_clock = 225000000;
+		break;
+	case 0x3:
+		PLL_clock = 250000000;
+		break;
+	}
+
+	CPU_clock = PLL_clock / (((PWRMGT_SYSTEM_CLOCK_CONTROL_REG >> 2) & 0x3) + 1);
+	AHB_clock = CPU_clock / (((PWRMGT_SYSTEM_CLOCK_CONTROL_REG >> 4) & 0x3) + 1);
+	APB_clock = AHB_clock / (((PWRMGT_SYSTEM_CLOCK_CONTROL_REG >> 8) & 0x3) + 1);
+
+	printk("PLL clock at %dMHz\n", PLL_clock / 1000000);
+	printk("CPU clock at %dMHz\n", CPU_clock / 1000000);
+	printk("AHB clock at %dMHz\n", AHB_clock / 1000000);
+	printk("APB clock at %dMHz\n", APB_clock / 1000000);
+}
+/* ######################################################################### */
+
+void __init str8100_init(void)
+{
+//   printk("str8100_init()\n");
+   
+#ifdef DEVICE_REGISTER_MULTIPLE
+	platform_add_devices(str8100_devices, ARRAY_SIZE(str8100_devices));
+#ifdef CONFIG_SPI_STR8100
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+	spi_register_board_info(str8100_spi_board_info, ARRAY_SIZE(str8100_spi_board_info));
+#endif
+#endif // CONFIG_SPI_STR8100
+#else // DEVICE_REGISTER_MULTIPLE
+#ifndef EARLY_REGISTER_CONSOLE
+	platform_device_register(&str8100_uart0_device);
+	platform_device_register(&str8100_uart1_device);
+#endif
+#ifdef CONFIG_SPI_STR8100
+	platform_device_register(&str8100_spi_master_device);
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+	spi_register_board_info(str8100_spi_board_info, ARRAY_SIZE(str8100_spi_board_info));
+#endif
+#endif
+	platform_device_register(&str8100_usb11_device);
+	platform_device_register(&str8100_usb20_device);
+#endif
+}
+
+extern void str8100_register_map_desc(struct map_desc *map, int count);
+void __init str8100_map_io(void)
+{
+//   printk("str8100_map_io()\n");
+   
+	iotable_init(str8100_std_desc, ARRAY_SIZE(str8100_std_desc));
+	str8100_register_map_desc(str8100_std_desc, ARRAY_SIZE(str8100_std_desc));
+#ifdef EARLY_REGISTER_CONSOLE
+	early_serial_setup(&str8100_serial_ports[0]);
+	early_serial_setup(&str8100_serial_ports[1]);
+#endif
+}
+
+extern void str8100_init_irq(void);
+extern struct sys_timer str8100_timer;
+
+MACHINE_START(STR8100, "STAR STR8100")
+	.phys_io	= SYSPA_UART0_BASE_ADDR,
+	.io_pg_offst	= ((SYSVA_UART0_BASE_ADDR) >> 18) & 0xfffc, // virtual, physical
+	.fixup		= str8100_fixup,
+	.map_io		= str8100_map_io,
+	.init_irq	= str8100_init_irq,
+	.timer		= &str8100_timer,
+	.boot_params	= 0x0100,
+	.init_machine	= str8100_init,
+MACHINE_END
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str8100/str8100_timer.c linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_timer.c
--- linux-2.6.35.11/arch/arm/mach-str8100/str8100_timer.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str8100/str8100_timer.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/timex.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#if 1
+// for timer clock < 100MHz
+#define uSECS_PER_TICK	(1000000 / APB_clock)
+#define TICKS2USECS(x)  ((x) * uSECS_PER_TICK)
+#else
+// for timer clock >= 100MHz
+#define TICKS_PER_uSEC	(APB_clock / 1000000)
+#define TICKS2USECS(x)  ((x) / TICKS_PER_uSEC)
+#endif
+
+extern u32 APB_clock;
+static u32 timer_counter_value;
+
+static inline unsigned int str8100_read_timer_counter(void)
+{
+	return TIMER1_COUNTER_REG;
+}
+
+static inline unsigned int str8100_read_timer_interrupt_status(void)
+{
+	return TIMER1_TIMER2_INTERRUPT_STATUS_REG;
+}
+
+static inline void str8100_clear_timer_interrupt_status(unsigned int irq)
+{
+	TIMER1_TIMER2_INTERRUPT_STATUS_REG &= ~(1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX);
+}
+
+static void str8100_setup_timer(unsigned int counter_value)
+{
+	unsigned long control_value;
+	unsigned long mask_value;    
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+	mask_value = TIMER1_TIMER2_INTERRUPT_MASK_REG;
+
+	TIMER1_COUNTER_REG = counter_value;
+	TIMER1_AUTO_RELOAD_VALUE_REG = counter_value;
+	TIMER1_MATCH_VALUE1_REG = 0;
+	TIMER1_MATCH_VALUE2_REG = 0;
+
+	// Clock Source: PCLK
+	control_value &= ~(1 << TIMER1_CLOCK_SOURCE_BIT_INDEX);
+
+	// Down Count Mode
+	control_value |= (1 << TIMER1_UP_DOWN_COUNT_BIT_INDEX);
+
+	// un-mask overflow, match2 and match1 interrupt sources
+	mask_value &= ~(0x7);
+
+	// mask match2 and match1 interrupt sources
+	mask_value |= 0x03;
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+	TIMER1_TIMER2_INTERRUPT_MASK_REG = mask_value;
+}
+
+static void str8100_timer_enable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+
+	// enable overflow mode
+	control_value |= (1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value |= (1 << TIMER1_ENABLE_BIT_INDEX);
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+}
+
+static void str8100_timer_disable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER1_TIMER2_CONTROL_REG;
+
+	// disable overflow mode
+	control_value &= ~(1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// disable the timer
+	control_value &= ~(1 << TIMER1_ENABLE_BIT_INDEX);
+
+	TIMER1_TIMER2_CONTROL_REG = control_value;
+}
+
+/*
+ * Returns number of us since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+static unsigned long str8100_gettimeoffset(void)
+{
+	unsigned long ticks1, ticks2;
+	unsigned long interrupt_status;
+
+	/*
+	 * Get the current number of ticks.  Note that there is a race
+	 * condition between us reading the timer and checking for
+	 * an interrupt.  We get around this by ensuring that the
+	 * counter has not reloaded between our two reads.
+	 */
+	ticks2 = str8100_read_timer_counter();
+	do {
+		ticks1 = ticks2;
+		interrupt_status = str8100_read_timer_interrupt_status();
+		ticks2 = str8100_read_timer_counter();
+	} while (ticks2 > ticks1);
+
+	/*
+	 * Number of ticks since last interrupt
+	 */
+	ticks1 = timer_counter_value - ticks2;
+
+	/*
+	 * Interrupt pending?  If so, we've reloaded once already.
+	 */
+	if (interrupt_status) {
+		ticks1 += timer_counter_value;
+	}
+
+	/*
+	 * Convert the ticks to usecs
+	 */
+	return TICKS2USECS(ticks1);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+str8100_timer_interrupt(int irq, void *dev_id /*, struct pt_regs *regs*/)
+{     
+  		
+#ifndef CONFIG_VIC_INTERRUPT
+	str8100_clear_timer_interrupt_status((unsigned int)irq);
+#endif
+	/* scot.patch
+	timer_tick(regs);
+	*/
+	timer_tick();
+		
+	return IRQ_HANDLED;
+}
+
+static struct irqaction str8100_timer_irq = {
+	.name		= "STR8100 Timer Tick",
+/* scott.patch
+	.flags		= SA_INTERRUPT | SA_TIMER,
+*/
+	.flags		= IRQF_DISABLED | IRQF_TIMER, 
+	.handler	= str8100_timer_interrupt,
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+ 
+
+static void __init str8100_timer_init(void)
+{
+	/*
+	 * prepare timer-related values
+	 */
+	timer_counter_value = APB_clock / HZ;
+
+	/*
+	 * setup timer-related values
+	 */
+	str8100_setup_timer(timer_counter_value);
+
+	
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(INTC_TIMER1_BIT_INDEX, &str8100_timer_irq);
+
+	str8100_timer_enable();
+		
+	
+}
+
+struct sys_timer str8100_timer = {
+	.init		= str8100_timer_init,
+#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET	
+	.offset		= str8100_gettimeoffset,
+#endif	
+};
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/Kconfig linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Kconfig
--- linux-2.6.35.11/arch/arm/mach-str9100/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,99 @@
+if ARCH_STR9100
+
+menu "STR9100 Options"
+
+config CONSOLE_BAUD_RATE
+	int "Console Baud Rate"
+	default 115200
+	help
+	  set the console baudrate
+
+config CPU_ISPAD_ENABLE
+	bool "Enable I-Scratch Pad Support"
+	default y
+	help
+	  enable I-Scratch Pad support
+
+choice
+	prompt "DRAM SIZE"
+	default STR9100_DRAM_16M
+
+config STR9100_DRAM_16M
+	bool "16MBytes"
+
+config STR9100_DRAM_32M
+	bool "32MBytes"
+
+config STR9100_DRAM_64M
+	bool "64MBytes"
+
+endchoice
+
+if PCI
+choice
+	prompt "PCI Frequency"
+	default STAR9100_PCI33M
+
+config STR9100_PCI33M
+	bool "PCI_33Mhz"
+
+config STR9100_PCI66M
+	bool "PCI_66Mhz"
+
+endchoice
+endif
+
+config STR9100_RTC
+	bool "STR9100 Real Time Clock Support"
+
+config STR9100_GPIO
+	bool "STR9100 GPIO Support"
+
+config STR9100_GPIO_INTERRUPT
+	bool "Interrupt Library Support"
+	depends on STR9100_GPIO
+
+config STR9100_INFO
+	bool "STR9100 Infomation at /proc/str9100/info"
+
+comment "Flash MAP"
+config STR9100_FLASH_PART
+	bool "STR9100 flash partition setting"
+
+if STR9100_FLASH_PART
+	config ARMBOOT_OFFSET
+	hex "ARMBOOT OFFSET"
+	default 0x0
+	help
+	  The armboot start offset in flash layout
+
+	config KERNEL_OFFSET
+	hex "KERNEL OFFSET"
+	default 0x40000
+	help
+	  The kernel start offset in flash layout
+
+	config ROOTFS_OFFSET
+	hex "ROOTFS OFFSET"
+	default 0x140000
+	help
+	  The rootfs start offset in flash layout
+
+	config CFG_OFFSET
+	hex "CFG OFFSET"
+	default 0x7f0000
+	help
+	  The cfg start offset in flash layout
+endif
+
+comment "Third Party Support"
+
+config STR9100_EWC_SUPPORT
+	bool "EWC(802.11N) Support"
+
+config SWITCH_IOCTL
+	bool "SUPPORT SWITCH IOCTL"
+
+endmenu
+
+endif
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/Makefile linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Makefile
--- linux-2.6.35.11/arch/arm/mach-str9100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,14 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			:= str9100_debug.o str9100_setup.o str9100_timer.o str9100_intc.o str9100_counter.o str9100_misc.o
+obj-m			:=
+obj-n			:=
+obj-			:=
+
+obj-$(CONFIG_PCI) += str9100_pci.o
+obj-$(CONFIG_STR9100_GPIO)	+= str9100_gpio.o
+obj-$(CONFIG_STR9100_RTC)	+= str9100_rtc.o
\ No newline at end of file
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/Makefile.boot linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Makefile.boot
--- linux-2.6.35.11/arch/arm/mach-str9100/Makefile.boot	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/Makefile.boot	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,10 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00C00000
+kernel_phys-y	:= 0x00400000
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_counter.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_counter.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_counter.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_counter.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,214 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/timex.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+u64 volatile str9100_counter_tick;
+EXPORT_SYMBOL(str9100_counter_tick);
+
+static struct proc_dir_entry *str9100_counter_proc_entry;
+
+#if 0
+// this is defined in include/asm/arch-str9100/system.h
+u64 str9100_read_counter(void)
+{
+	return (str9100_counter_tick + TIMER2_COUNTER_REG);
+}
+EXPORT_SYMBOL(str9100_read_counter);
+#endif
+
+static int match1=0;
+static int match2=0;
+static void str9100_setup_counter(void)
+{
+	unsigned long control_value;
+	unsigned long mask_value;    
+	unsigned long val;    
+
+	control_value = TIMER_CONTROL_REG;
+	mask_value = TIMER_INTERRUPT_MASK_REG;
+
+	TIMER2_COUNTER_REG		= 0;
+	TIMER2_AUTO_RELOAD_VALUE_REG	= 0;
+	TIMER2_MATCH_VALUE1_REG		= match1;
+	TIMER2_MATCH_VALUE2_REG		= match2;
+
+	// Clock Source: PCLK
+	control_value &= ~(1 << TIMER2_CLOCK_SOURCE_BIT_INDEX);
+
+	// UP Count Mode
+	control_value &= ~(1 << TIMER2_UP_DOWN_COUNT_BIT_INDEX);
+
+	// un-mask match1, match2, and overflow interrupt sources
+	mask_value &= ~(0x7 << 3);
+
+	// mask match1, match2 interrupt sources
+	//mask_value |= (0x3 << 3);
+	val=0;
+	if(!match1) val|=0x1;
+	if(!match2) val|=0x2;
+	mask_value |= (val<< 3);
+
+	TIMER_CONTROL_REG = control_value;
+	TIMER_INTERRUPT_MASK_REG = mask_value;
+}
+
+static void str9100_counter_enable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER_CONTROL_REG;
+
+	// enable overflow mode
+	control_value |= (1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value |= (1 << TIMER2_ENABLE_BIT_INDEX);
+
+	TIMER_CONTROL_REG = control_value;
+}
+
+static void str9100_counter_disable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER_CONTROL_REG;
+
+	// enable overflow mode
+	control_value &= ~(1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value &= ~(1 << TIMER2_ENABLE_BIT_INDEX);
+
+	TIMER_CONTROL_REG = control_value;
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+str9100_counter_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	// clear counter interrrupt status
+	TIMER_INTERRUPT_STATUS_REG &= ~(1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX);
+	str9100_counter_tick += (1ULL << 32);
+	if(match1){
+		TIMER2_MATCH_VALUE1_REG=TIMER2_COUNTER_REG+match1;
+		TIMER_INTERRUPT_MASK_REG |= (0x1<<3);
+	}
+	if(match2){
+		TIMER2_MATCH_VALUE2_REG=TIMER2_COUNTER_REG+match2;
+		TIMER_INTERRUPT_MASK_REG |= (0x2<<3);
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction str9100_counter_irq = {
+	.name		= "STR9100 Counter Tick",
+	/* scott.patch */
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= str9100_counter_interrupt,
+};
+
+static int str9100_counter_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	return sprintf(page, "str9100_counter_tick: %llu\n", str9100_counter_tick + TIMER2_COUNTER_REG);
+}
+static int
+str9100_counter_write_proc(struct file *file, const char __user *buffer,
+	unsigned long count, void *data)
+{
+	char *str;
+	char *cmd;
+
+	if (count > 0) {
+		str = (char *)buffer,
+		cmd = strsep(&str, "\t \n");
+		if (!cmd) goto err_out;
+		if (strcmp(cmd, "match1") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 10);
+			match1=addr;
+
+		} else if (strcmp(cmd, "match2") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 10);
+			match2=addr;
+
+
+		} else {
+			goto err_out;
+		}
+	}
+	if(match1){
+		TIMER2_MATCH_VALUE1_REG=TIMER2_COUNTER_REG+match1;
+		TIMER_INTERRUPT_MASK_REG |= (0x1<<3);
+	}
+	if(match2){
+		TIMER2_MATCH_VALUE2_REG=TIMER2_COUNTER_REG+match2;
+		TIMER_INTERRUPT_MASK_REG |= (0x2<<3);
+	}
+
+	return count;
+
+err_out:
+	return -EFAULT;
+}
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+int __init str9100_counter_setup(void)
+{
+	str9100_setup_counter();
+	setup_irq(INTC_TIMER2_BIT_INDEX, &str9100_counter_irq);
+	str9100_counter_enable();
+	str9100_counter_proc_entry = create_proc_entry("str9100/counter", S_IFREG | S_IRUGO, NULL);
+	if (str9100_counter_proc_entry) {
+		str9100_counter_proc_entry->read_proc = str9100_counter_read_proc;
+		str9100_counter_proc_entry->write_proc = str9100_counter_write_proc;
+
+	}
+
+	return 0;
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_debug.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_debug.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_debug.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_debug.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/types.h>
+#include <asm/hardware.h>
+
+void debug_puts(const char *s)
+{
+	while (*s) {
+		volatile unsigned int status = 0;
+		do {
+			status = _UART_LSR;
+		} while (!((status & THR_EMPTY) == THR_EMPTY));
+
+		_UART_THR = *s;
+
+		if (*s == '\n') {
+			do {
+				status = _UART_LSR;
+			} while (!((status & THR_EMPTY) == THR_EMPTY));
+
+			_UART_THR = '\r';
+
+		}
+		s++;
+	}
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_gpio.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_gpio.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_gpio.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_gpio.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,532 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/arch/star_gpio.h>
+
+#include <linux/str9100/str9100_gpio.h>
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+#define MAX_GPIO_LINE		21
+void (*gpio_isr[MAX_GPIO_LINE])(int i);
+#endif
+
+/* 
+ * Read GPIO input data from register
+ */
+int str9100_gpio_in(volatile __u32 *data)
+{
+	*data = GPIO_DATA_IN_REG;
+	return 0;
+}
+
+/* 
+ * Write data to  GPIO output register
+ */
+int str9100_gpio_out(__u32 data)
+{
+	GPIO_DATA_OUT_REG = data;
+	return 0;
+}
+
+/* 
+ * Read GPIO direction Register
+ */
+int str9100_gpio_read_direction(volatile __u32 *data)
+{
+	*data = GPIO_PIN_DIR_REG;
+	return 0;
+}
+
+/* 
+ * Write GPIO direction Register
+ */
+int str9100_gpio_write_direction(__u32 data)
+{
+	GPIO_PIN_DIR_REG = data;
+	return 0;
+}
+
+/* 
+ * Write GPIO set Register
+ */
+int str9100_gpio_dataset(__u32 data)
+{
+	GPIO_DATA_SET_REG = data;
+	return 0;
+}
+
+/* 
+ * Write GPIO clear Register
+ */
+int str9100_gpio_dataclear(__u32 data)
+{
+	GPIO_DATA_CLEAR_REG = data;
+	return 0;
+}
+
+/* Read GPIO Data, but only one bit */
+int str9100_gpio_in_bit(volatile __u32 *data, int bit)
+{
+	u32 temp;
+	if (bit >= 0 && bit <= 20) {
+		str9100_gpio_in(&temp);
+		*data = ((temp >> bit)&0x1);
+	}
+	return 0;
+}
+
+/* Write GPIO Data, but only one bit */
+int str9100_gpio_out_bit(__u32 data, int bit)
+{
+	u32 temp;
+	if (bit >= 0 && bit <= 20) {
+		str9100_gpio_in(&temp);
+		temp &= ~(1 <<bit);
+		temp |= (data &0x1)<< bit;
+		str9100_gpio_out(temp);
+	}
+	return 0;
+
+}
+
+int str9100_gpio_read_direction_bit(volatile __u32 *data, int bit)
+{
+	u32 temp;
+	if (bit >= 0 && bit <= 20) {
+		str9100_gpio_read_direction(&temp);
+		*data = ((temp >> bit)&0x1);
+	}
+	return 0;
+}
+
+int str9100_gpio_write_direction_bit(__u32 data, int bit)
+{
+	u32 temp;
+	if (bit >= 0 && bit <= 20) {
+		str9100_gpio_read_direction(&temp);
+		temp &= ~(1 <<bit);
+		temp |= (data &0x1)<< bit;
+		str9100_gpio_write_direction(temp);
+	}
+	return 0;
+}
+
+int str9100_gpio_dataset_bit(__u32 data, int bit)
+{
+	u32 temp=0;
+	if (bit >= 0 && bit <= 20) {
+		temp |= (data &0x1)<< bit;
+		str9100_gpio_dataset(temp);
+	}
+	return 0;
+}
+
+int str9100_gpio_dataclear_bit(__u32 data, int bit)
+{
+	u32 temp=0;
+	if (bit >= 0 && bit <= 20) {
+		temp |= (data &0x1)<< bit;
+		str9100_gpio_dataclear(temp);
+	}
+	return 0;
+}
+
+#define GEN_GPIO_WRITE_SCRIPT(regname)\
+int str9100_gpio_write_##regname##_bit(volatile __u32 data,int bit) \
+{ \
+	u32 temp=0; \
+	if (bit >= 0 && bit <= 20) { \
+		temp |= ((data &0x1)<< bit); \
+		str9100_gpio_write_##regname(temp); \
+	} \
+	return 0; \
+} 
+//EXPORT_SYMBOL(str9100_gpio_write_##regname_bit);
+
+#define GEN_GPIO_READ_SCRIPT(regname) \
+int str9100_gpio_read_##regname##_bit(volatile __u32 *data,int bit) \
+{ \
+	u32 temp; \
+	if (bit >= 0 && bit <= 20) { \
+		str9100_gpio_read_##regname(&temp); \
+		*data = ((temp >> bit)&0x1); \
+	} \
+	return 0; \
+} 
+//EXPORT_SYMBOL(str9100_gpio_read_##regname_bit);
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+int str9100_gpio_read_intrenable(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_ENABLE_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrenable);
+
+int str9100_gpio_write_intrenable(__u32 data)
+{
+	GPIO_INTERRUPT_ENABLE_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrenable);
+
+int str9100_gpio_read_intrrawstate(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_RAW_STATE_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrrawstate);
+
+int str9100_gpio_read_intrmaskedstatus(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_MASKED_STATE_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrmaskedstatus);
+
+int str9100_gpio_read_intrmask(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_MASK_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrmask);
+
+int str9100_gpio_write_intrmask(__u32 data)
+{
+	GPIO_INTERRUPT_MASK_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrmask);
+
+int str9100_gpio_read_intrclear(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_CLEAR_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrclear);
+
+int str9100_gpio_write_intrclear(__u32 data)
+{
+	GPIO_INTERRUPT_CLEAR_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrclear);
+
+int str9100_gpio_read_intrtrigger(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_TRIGGER_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrtrigger);
+
+int str9100_gpio_write_intrtrigger(__u32 data)
+{
+	GPIO_INTERRUPT_TRIGGER_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrtrigger);
+
+int str9100_gpio_read_intrboth(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_BOTH_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrboth);
+
+int str9100_gpio_write_intrboth(__u32 data)
+{
+	GPIO_INTERRUPT_BOTH_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrboth);
+
+int str9100_gpio_read_intrriseneg(volatile __u32 *data)
+{
+	*data = GPIO_INTERRUPT_RISE_NEG_REG;
+	return 0;
+}
+GEN_GPIO_READ_SCRIPT(intrriseneg);
+
+int str9100_gpio_write_intrriseneg(__u32 data)
+{
+	GPIO_INTERRUPT_RISE_NEG_REG = data;
+	return 0;
+}
+GEN_GPIO_WRITE_SCRIPT(intrriseneg);
+
+#endif
+
+#if 0
+EXPORT_SYMBOL(str9100_gpio_in);
+EXPORT_SYMBOL(str9100_gpio_out);
+EXPORT_SYMBOL(str9100_gpio_in_bit);
+EXPORT_SYMBOL(str9100_gpio_out_bit);
+EXPORT_SYMBOL(str9100_gpio_read_direction);
+EXPORT_SYMBOL(str9100_gpio_write_direction);
+EXPORT_SYMBOL(str9100_gpio_read_direction_bit);
+EXPORT_SYMBOL(str9100_gpio_write_direction_bit);
+EXPORT_SYMBOL(str9100_gpio_dataset);
+EXPORT_SYMBOL(str9100_gpio_dataclear);
+EXPORT_SYMBOL(str9100_gpio_dataset_bit);
+EXPORT_SYMBOL(str9100_gpio_dataclear_bit);
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+EXPORT_SYMBOL(str9100_gpio_read_intrenable);
+EXPORT_SYMBOL(str9100_gpio_write_intrenable);
+EXPORT_SYMBOL(str9100_gpio_read_intrrawstate);
+EXPORT_SYMBOL(str9100_gpio_read_intrmaskedstatus);
+EXPORT_SYMBOL(str9100_gpio_read_intrmask);
+EXPORT_SYMBOL(str9100_gpio_write_intrmask);
+EXPORT_SYMBOL(str9100_gpio_read_intrclear);
+EXPORT_SYMBOL(str9100_gpio_write_intrclear);
+EXPORT_SYMBOL(str9100_gpio_read_intrtrigger);
+EXPORT_SYMBOL(str9100_gpio_write_intrtrigger);
+EXPORT_SYMBOL(str9100_gpio_read_intrboth);
+EXPORT_SYMBOL(str9100_gpio_write_intrboth);
+EXPORT_SYMBOL(str9100_gpio_read_intrriseneg);
+EXPORT_SYMBOL(str9100_gpio_write_intrriseneg);
+#endif
+#endif
+
+static int str9100_gpio_proc(char *page, char **start,  off_t off, int count, int *eof, void *data)
+{
+	u32 temp;
+	int num=0;
+
+	str9100_gpio_in(&temp);
+	num += sprintf(page+num, "GPIO IN                : %08x \n", temp);
+
+	str9100_gpio_read_direction(&temp);
+	num += sprintf(page+num, "GPIO Direction         : %08x \n", temp);
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+	str9100_gpio_read_intrenable(&temp);
+	num += sprintf(page+num, "GPIO Interrupt Enable  : %08x \n", temp);
+
+	str9100_gpio_read_intrrawstate(&temp);
+	num += sprintf(page+num, "GPIO Interrupt Raw     : %08x \n", temp);
+
+	str9100_gpio_read_intrtrigger(&temp);
+	num += sprintf(page+num, "GPIO Interrupt Trigger : %08x \n", temp);
+
+	str9100_gpio_read_intrboth(&temp);
+	num += sprintf(page+num, "GPIO Interrupt Both    : %08x \n", temp);
+
+	str9100_gpio_read_intrriseneg(&temp);
+	num += sprintf(page+num, "GPIO Interrupt RiseNeg : %08x \n", temp);
+
+	str9100_gpio_read_intrmask(&temp);
+	num += sprintf(page+num, "GPIO Interrupt MASKED  : %08x \n", temp);
+
+	str9100_gpio_read_intrmaskedstatus(&temp);
+	num += sprintf(page+num, "GPIO Interrupt MASKEDST: %08x \n", temp);
+#endif	
+
+	return num;
+}
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+static void str9100_gpio_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	int i;
+	u32 gpio_intr;
+
+	// Clean System irq status
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	INTC_INTERRUPT_MASK_REG |= (0x1 << INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	str9100_gpio_read_intrrawstate(&gpio_intr);
+	//printk("GPIO INTERRUPT : %08x \n",gpio_intr);
+
+	for (i = 0; i < MAX_GPIO_LINE; i++) {
+		if ((gpio_intr &0x1) == 0x1) {
+			if (gpio_isr[i] != NULL) {
+				gpio_isr[i](i);
+			}
+		}
+		gpio_intr = gpio_intr >> 1;
+	}
+	/* Clear All Interrupt Status */
+	str9100_gpio_write_intrclear(0x1FFFFF);
+	/* Unmask Intc Interrupt Status */
+	INTC_INTERRUPT_MASK_REG &= ~(0x1 << INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+}
+
+/*  
+ * Setup GPIO for Edge Triggle Interrupt mode 
+ */
+void str9100_gpio_set_edgeintr(void (*funcptr)(int),int trig_both,int trig_rising, int gpio_pin)
+{
+	u32 intrtmp;
+	
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIO_LINE) {
+		str9100_gpio_write_direction_bit(PIN_INPUT,gpio_pin);
+
+		/* Set Triggle Level */
+		str9100_gpio_read_intrtrigger(&intrtmp);
+		intrtmp &= ~(0x1 << gpio_pin);
+		intrtmp |= (PIN_TRIG_EDGE << gpio_pin);
+		str9100_gpio_write_intrtrigger(intrtmp);
+
+		/* Set Triggle Both */
+		str9100_gpio_read_intrboth(&intrtmp);
+		intrtmp &= ~(0x1 << gpio_pin);
+		intrtmp |= (trig_both << gpio_pin);
+		str9100_gpio_write_intrboth(intrtmp);
+
+		/* Set Triggle Rising/Falling */
+		str9100_gpio_read_intrriseneg(&intrtmp);
+		intrtmp &= ~(0x1 << gpio_pin);
+		intrtmp |= (trig_rising << gpio_pin);
+		str9100_gpio_write_intrriseneg(intrtmp);
+
+		gpio_isr[gpio_pin] = funcptr;
+
+		// Enable Interrupt
+		str9100_gpio_read_intrenable(&intrtmp);
+		intrtmp |= (0x1 << gpio_pin);
+		str9100_gpio_write_intrenable(intrtmp);
+	}
+}
+/*  
+ * Clear GPIO Triggle Interrupt
+ */
+void str9100_gpio_clear_intr(int gpio_pin)
+{
+	u32 intrtmp;
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIO_LINE) {
+		gpio_isr[gpio_pin] = NULL;
+		// Disable Interrupt
+		str9100_gpio_read_intrenable(&intrtmp);
+		intrtmp &= ~( 0x1 << gpio_pin);
+		str9100_gpio_write_intrenable(intrtmp);
+	}
+}
+
+/*  
+ * Setup GPIO for LEVEL Triggle Interrupt mode 
+ */
+void str9100_gpio_set_levelintr(void (*funcptr)(int),int trig_level, int gpio_pin)
+{
+	u32 intrtmp;
+	if (gpio_pin >= 0 && gpio_pin < MAX_GPIO_LINE) {
+		str9100_gpio_write_direction_bit(PIN_INPUT,gpio_pin);
+		/* Set Triggle Level */
+		str9100_gpio_read_intrtrigger(&intrtmp);
+		intrtmp &= ~(0x1 << gpio_pin);
+		intrtmp |= (PIN_TRIG_LEVEL << gpio_pin);
+		str9100_gpio_write_intrtrigger(intrtmp);
+
+		/* Set Triggle High/Low */
+		str9100_gpio_read_intrriseneg(&intrtmp);
+		intrtmp &= ~(0x1 << gpio_pin);
+		intrtmp |= (trig_level << gpio_pin);
+		str9100_gpio_write_intrriseneg(intrtmp);
+
+		gpio_isr[gpio_pin] = funcptr;
+
+		// Enable Interrupt
+		str9100_gpio_read_intrenable(&intrtmp);
+		intrtmp |= (0x1 << gpio_pin);
+		str9100_gpio_write_intrenable(intrtmp);
+	}
+}
+EXPORT_SYMBOL(str9100_gpio_set_edgeintr);
+EXPORT_SYMBOL(str9100_gpio_clear_intr);
+EXPORT_SYMBOL(str9100_gpio_set_levelintr);
+
+/*  
+ * Display GPIO information at /proc/str9100/gpio
+ */
+
+#ifdef STR9100_GPIO_INTERRUPT_TEST
+void str9100_gpio_intr_test(int i)
+{
+	printk("GPIO Interrupt Service Single Active : %d \n",i);
+}
+#endif
+
+#endif
+static struct proc_dir_entry *proc_str9100_gpio;
+int __init str9100_gpio_init(void)
+{
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+	u32 i, ret;
+#endif
+#ifdef STR9100_GPIO_INTERRUPT_TEST
+	/* test script */
+	u32 temp;
+	str9100_gpio_read_direction(&temp);
+	printk("direction: %08X\n",temp);
+	str9100_gpio_write_direction_bit(PIN_OUTPUT,15);
+	str9100_gpio_read_direction(&temp);
+	printk("direction: %08X\n",temp);
+	str9100_gpio_in(&temp);
+	printk("data: %08X\n",temp);
+#endif
+
+	proc_str9100_gpio = create_proc_read_entry("str9100/gpio", 0, NULL, str9100_gpio_proc, NULL) ;
+
+#ifdef CONFIG_STR9100_GPIO_INTERRUPT
+	for (i = 0; i < MAX_GPIO_LINE; i++) {
+		gpio_isr[i] = NULL;
+	}
+	/* Clear All Interrupt Status */
+	str9100_gpio_write_intrclear(0x1FFFFF);
+	str9100_set_interrupt_trigger(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, INTC_EDGE_TRIGGER, INTC_RISING_EDGE);
+	ret = request_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, str9100_gpio_irq_handler, 0, "str9100_gpio", 0);
+	if (ret < 0) {
+		printk("request_irq fail : %d \n", ret);
+		return 0;
+	} else {
+		printk("GPIO interrupt handler install ok. \n");
+	}
+#endif
+#ifdef STR9100_GPIO_INTERRUPT_TEST
+	str9100_gpio_set_edgeintr(&str9100_gpio_intr_test,PIN_TRIG_SINGLE,PIN_TRIG_RISING,12);
+#endif
+
+	return 0;
+}	
+
+void __exit str9100_gpio_exit(void)
+{
+	free_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX,0);
+}
+
+module_init(str9100_gpio_init);
+module_exit(str9100_gpio_exit);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_intc.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_intc.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_intc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_intc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,193 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <asm/hardware.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+
+#define INTC_TRIGGER_UNKNOWN -1
+
+typedef struct
+{
+	int	mode;
+	int	level;
+} intc_trigger_t;
+
+static intc_trigger_t intc_trigger_table[] =
+{
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 0
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 1
+	{ INTC_EDGE_TRIGGER,	INTC_FALLING_EDGE	},	// 2
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 3
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 4
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 5
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 6
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 7
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 8
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 9
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 10
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 11
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 12
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 13
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 14
+	{ INTC_EDGE_TRIGGER,	INTC_FALLING_EDGE	},	// 15
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 16
+	{ INTC_TRIGGER_UNKNOWN,	INTC_TRIGGER_UNKNOWN	},	// 17
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_HIGH	},	// 18
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 19
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 20
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 21
+	{ INTC_EDGE_TRIGGER,	INTC_RISING_EDGE	},	// 22
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 23
+	{ INTC_LEVEL_TRIGGER,	INTC_ACTIVE_LOW		},	// 24
+};
+
+/*
+ * Configure interrupt trigger mode to be level trigger or edge trigger
+ */
+static inline void str9100_set_irq_mode(unsigned int irq, unsigned int mode)
+{
+	unsigned int val;
+
+	if (irq < 0 || irq > NR_IRQS) {
+		return;
+	}
+
+	if ((mode != INTC_LEVEL_TRIGGER) &&
+		(mode != INTC_EDGE_TRIGGER)) {
+		return;
+	}
+
+	val = INTC_INTERRUPT_TRIGGER_MODE_REG;
+
+	if (mode == INTC_LEVEL_TRIGGER) {
+		if (val & (1UL << irq)) {
+			val &= ~(1UL << irq);
+			INTC_INTERRUPT_TRIGGER_MODE_REG = val;
+		}
+	} else {
+		if (!(val & (1UL << irq))) {
+			val |= (1UL << irq);
+			INTC_INTERRUPT_TRIGGER_MODE_REG = val;
+		}
+	}
+}	
+
+/*
+ * Configure interrupt trigger level to be Active High/Low or Rising/Falling Edge
+ */
+static inline void str9100_set_irq_level(unsigned int irq, unsigned int level)
+{
+	unsigned int val;
+
+	if (irq < 0 || irq > NR_IRQS) {
+		return;
+	}
+
+	if ((level != INTC_ACTIVE_HIGH) &&
+		(level != INTC_ACTIVE_LOW) &&
+		(level != INTC_RISING_EDGE) &&
+		(level != INTC_FALLING_EDGE)) {
+		return;
+	}
+
+	val = INTC_INTERRUPT_TRIGGER_LEVEL_REG;
+
+	if ((level == INTC_ACTIVE_HIGH) ||
+		(level == INTC_RISING_EDGE)) {
+		if (val & (1UL << irq)) {
+			val &= ~(1UL << irq);
+			INTC_INTERRUPT_TRIGGER_LEVEL_REG = val;
+		}
+	} else {
+		if (!(val & (1UL << irq))) {
+			val |= (1UL << irq);
+			INTC_INTERRUPT_TRIGGER_LEVEL_REG = val;
+		}
+	}
+}
+
+/*
+ * Configure interrupt trigger mode and trigger level
+ */
+void str9100_set_interrupt_trigger(unsigned int irq, unsigned int mode, unsigned int level)
+{
+	str9100_set_irq_mode(irq, mode);
+	str9100_set_irq_level(irq, level);
+}
+EXPORT_SYMBOL(str9100_set_interrupt_trigger);
+
+/*
+ * Mask/Disable this interrupt source
+ */
+static void str9100_mask_irq(unsigned int irq)
+{
+	// Mask/Disable this interrupt source
+	INTC_INTERRUPT_MASK_REG |= (1UL << irq);
+}
+
+/*
+ * Un-Mask/Enable this interrupt source
+ */
+static void str9100_unmask_irq(unsigned int irq)
+{
+	// Clear interrupt status of the interrupt source which is edge-triggered
+	INTC_INTERRUPT_CLEAR_EDGE_TRIGGER_REG |= (1UL << irq);
+
+	// Mask/Disable this interrupt source
+	INTC_INTERRUPT_MASK_REG &= ~(1UL << irq);
+}
+
+static struct irq_chip str9100_irqchip = {
+	.ack	= str9100_mask_irq,
+	.mask	= str9100_mask_irq,
+	.unmask	= str9100_unmask_irq,
+};
+
+void __init str9100_init_irq(void)
+{
+	int i;
+
+	INTC_INTERRUPT_MASK_REG = 0xFFFFFFFF;
+	INTC_INTERRUPT_CLEAR_EDGE_TRIGGER_REG = 0xFFFFFFFF;	
+	INTC_FIQ_MODE_SELECT_REG = 0x0;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		if (intc_trigger_table[i].mode != INTC_TRIGGER_UNKNOWN) {
+			str9100_set_irq_mode(i, intc_trigger_table[i].mode);
+			str9100_set_irq_level(i, intc_trigger_table[i].level);
+		}
+	}
+	
+	for (i = 0; i < NR_IRQS;  i++) {
+		set_irq_chip(i, &str9100_irqchip);
+		/* scott.patch */
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+}
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_misc.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_misc.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_misc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_misc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,249 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/mach/map.h>
+#include <asm/hardware.h>
+
+// enable I-Scratchpad
+int str9100_enable_ispad(u32 base_addr)
+{
+	u32 ispad_config = 0;
+	u32 flush_ispad = 0;
+	u32 ispad_size = 4; // 8K on STR9100
+	u32 cp15 = 1, cp15_off = 0;
+
+	// Configure Base
+	ispad_config |= (base_addr & 0xfffffc00);
+
+	// Configure Size
+	ispad_config &= ~(0xf << 2);
+	ispad_config |= ((ispad_size & 0xf) << 2) | (0x1 << 2);
+
+	// Enable
+	ispad_config |= 0x1;
+
+	// 1. set cp15, cr1-1(ECR) register value to 0x1
+	// 2. set up the base and size configuration
+	// 3. Invalidate IScratchpad All(flushed ISpad)
+	// 4. clear cp15, cr1-1(ECR) register value to 0x0
+	__asm__ __volatile__ (
+	"mcr p15,0,%0,c1,c1,0\n\t"
+	"mcr p15,0,%1,c9,c1,1\n\t"
+	"mcr p15,0,%2,c7,c5,5\n\t"
+	"mcr p15,0,%3,c1,c1,0\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	:
+	: "r"(cp15), "r"(ispad_config), "r"(flush_ispad), "r"(cp15_off));
+	
+	return 0;
+}
+
+static struct map_desc str9100_map_desc[64];
+static int str9100_map_desc_count;
+#define REG_DEBUG_CMD_BUFFER_SIZE	128
+#define REG_DEBUG_RESULT_BUFFER_SIZE	256
+static struct proc_dir_entry *star_reg_debug_proc_entry;
+static char str9100_reg_debug_cmd_buf[REG_DEBUG_CMD_BUFFER_SIZE];
+static char str9100_reg_debug_result_buf[REG_DEBUG_RESULT_BUFFER_SIZE];
+
+struct proc_dir_entry *str9100_proc_dir;
+EXPORT_SYMBOL(str9100_proc_dir);
+
+void str9100_register_map_desc(struct map_desc *map, int count)
+{
+	if (count) {
+		if (str9100_map_desc) {
+			int i;
+			for (i = 0; i < count; i++) {
+				str9100_map_desc[i].virtual = map->virtual;
+				str9100_map_desc[i].pfn = map->pfn;
+				str9100_map_desc[i].length = map->length;
+				str9100_map_desc[i].type = map->type;
+				map++;
+			}
+			str9100_map_desc_count = count;
+		}
+	}
+}
+
+u32 str9100_query_map_desc_by_phy(u32 addr)
+{
+	struct map_desc *map;
+	int i;
+	u32 ret_addr = 0;
+	for (i = 0; i < str9100_map_desc_count; i++) {
+		map = &str9100_map_desc[i];
+		if (addr >= (map->pfn << PAGE_SHIFT) && addr < ((map->pfn << PAGE_SHIFT) + map->length)) {
+			ret_addr = map->virtual + (addr - (map->pfn << PAGE_SHIFT));
+			break;
+		}
+	}
+
+	return ret_addr;
+}
+
+u32 str9100_query_map_desc_by_vir(u32 addr)
+{
+	struct map_desc *map;
+	int i;
+	u32 ret_addr = 0;
+	for (i = 0; i < str9100_map_desc_count; i++) {
+		map = &str9100_map_desc[i];
+		if (addr >= map->virtual && addr < (map->virtual + map->length)) {
+			ret_addr = (map->pfn << PAGE_SHIFT) + (addr - map->virtual);
+			break;
+		}
+	}
+
+	return ret_addr;
+}
+
+static int star_reg_debug_read_proc(char *buffer, char **start, off_t offset,
+	int length, int *eof, void *data)
+{
+	int count;
+	int num = 0;
+
+	if (str9100_reg_debug_cmd_buf[0]) {
+		count = strlen(str9100_reg_debug_cmd_buf);
+		sprintf(buffer, str9100_reg_debug_cmd_buf, count);
+		num += count;
+	}
+	if (str9100_reg_debug_result_buf[0]) {
+		count = strlen(str9100_reg_debug_result_buf);
+		sprintf(buffer + num, str9100_reg_debug_result_buf, count);
+		num += count;
+	}
+
+	return num;
+}
+
+static int
+star_reg_debug_write_proc(struct file *file, const char __user *buffer,
+	unsigned long count, void *data)
+{
+	char *str;
+	char *cmd;
+
+	if (count > 0) {
+		str = (char *)buffer,
+		cmd = strsep(&str, "\t \n");
+		if (!cmd) goto err_out;
+		if (strcmp(cmd, "dump") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 16);
+			if (addr & 0x3) goto err_out;
+			vir_addr = str9100_query_map_desc_by_phy(addr);
+			sprintf(str9100_reg_debug_cmd_buf,
+				"dump 0x%08x\n",
+				addr);
+			if (!vir_addr) goto err_out;
+			sprintf(str9100_reg_debug_result_buf,
+				"physical addr: 0x%08x content: 0x%08x\n",
+				addr,
+				*(volatile unsigned int __force *)(vir_addr));
+		} else if (strcmp(cmd, "write") == 0) {
+			u32 addr;
+			u32 vir_addr;
+			u32 data;
+			char *arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			addr = simple_strtoul(arg, &arg, 16);
+			arg = strsep(&str, "\t \n");
+			if (!arg) goto err_out;
+			data = simple_strtoul(arg, &arg, 16);
+			if (addr & 0x3) goto err_out;
+			vir_addr = str9100_query_map_desc_by_phy(addr);
+			if (!vir_addr) goto err_out;
+			*(volatile unsigned int __force *)(vir_addr) = data;
+			sprintf(str9100_reg_debug_cmd_buf,
+				"write 0x%08x 0x%08x\n",
+				addr, data);
+			sprintf(str9100_reg_debug_result_buf,
+				"physical addr: 0x%08x content: 0x%08x\n",
+				addr,
+				*(volatile unsigned int __force *)(vir_addr));
+		} else {
+			goto err_out;
+		}
+	}
+
+	return count;
+
+err_out:
+	return -EFAULT;
+}
+
+static int __init star_reg_debug_proc_init(void)
+{
+	star_reg_debug_proc_entry = create_proc_entry("str9100/reg_debug", S_IFREG | S_IRUGO, NULL);
+	if (star_reg_debug_proc_entry) {
+		star_reg_debug_proc_entry->read_proc = star_reg_debug_read_proc;
+		star_reg_debug_proc_entry->write_proc = star_reg_debug_write_proc;
+	}
+
+	return 0;
+}
+
+static int __init str9100_proc_dir_create(void)
+{
+	str9100_proc_dir = proc_mkdir("str9100", NULL);
+	if (str9100_proc_dir) {
+		str9100_proc_dir->owner = THIS_MODULE;
+	} else {
+		printk("Error: cannot crete str9100 proc dir entry at /proc/str9100\n");
+		return -EINVAL;
+	}
+
+	if (str9100_map_desc_count) {
+		(void)star_reg_debug_proc_init();
+	}
+
+	return 0;
+}
+
+extern int __init str9100_counter_setup(void);
+static int __init str9100_misc_init(void)
+{
+	str9100_proc_dir_create();
+	str9100_counter_setup();
+	return 0;
+}
+
+module_init(str9100_misc_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Star Semi Corporation");
+MODULE_DESCRIPTION("STR9100 MISC");
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_pci.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_pci.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_pci.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,331 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#define CONFIG_CMD(bus, device_fn, where) (0x80000000 | ((bus) << 16) | ((device_fn) << 8) | ((where) & ~3))
+
+static struct pci_dev *pci_bridge = NULL;
+static u32 pci_config_addr;				// PCI configuration register address port
+static u32 pci_config_data;				// PCI configuration register data port
+u32 str9100_pci_irqs[4] = {0, INTC_PCI_INTA_BIT_INDEX, INTC_PCI_INTB_BIT_INDEX, 0};
+
+static int str9100_pci_read_config(struct pci_bus *bus,
+	unsigned int devfn, int where, int size, u32 *val)
+{
+	u32 v = 0;
+	u32 shift;
+	unsigned long flags;
+
+	switch (size) {
+	case 1:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		v = (v >> shift) & 0xff;
+		break;
+
+	case 2:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		v = (v >> shift) & 0xffff;
+
+		break;
+
+	case 4:
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		local_irq_restore(flags);
+		break;
+	}
+
+	*val = v;
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int str9100_pci_write_config(struct pci_bus *bus,
+	unsigned int devfn, int where, int size, u32 val)
+{
+	u32 v;
+	u32 shift;
+	unsigned long flags;
+
+	switch (size) {
+	case 1:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		v = (v & ~(0xff << shift)) | (val << shift);
+		__raw_writel(v, pci_config_data);
+		local_irq_restore(flags);
+		break;
+
+	case 2:
+		shift = (where & 0x3) << 3;
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		v = __raw_readl(pci_config_data);
+		v = (v & ~(0xffff << shift)) | (val << shift);
+		__raw_writel(v, pci_config_data);
+		local_irq_restore(flags);
+		break;
+
+	case 4:
+		local_irq_save(flags);
+		__raw_writel(CONFIG_CMD(bus->number, devfn, where), pci_config_addr);
+		__raw_writel(val, pci_config_data);
+		local_irq_restore(flags);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops str9100_pci_ops = {
+	.read	= str9100_pci_read_config,
+	.write	= str9100_pci_write_config,
+};
+
+static struct resource str9100_pci_io = {
+	.name	= "PCI I/O space",
+	.start	= PCI_IO_SPACE_START,
+	.end	= PCI_IO_SPACE_END, //albert : 20040714
+	.flags	= IORESOURCE_IO,
+};
+
+static struct resource str9100_pci_nprefetch_mem = {
+	.name	= "PCI non-prefetchable",
+	.start	= PCI_NPREFETCH_MEMORY_SPACE_START,
+	.end	= PCI_NPREFETCH_MEMORY_SPACE_END,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource str9100_pci_prefetch_mem = {
+	.name	= "PCI prefetchable",
+	.start	= PCI_PREFETCH_MEMORY_SPACE_START,
+	.end	= PCI_PREFETCH_MEMORY_SPACE_END,
+	.flags	= IORESOURCE_MEM | IORESOURCE_PREFETCH,
+};
+
+static int __init str9100_pci_setup_resources(struct resource **resource)
+{
+	int ret = -1;
+
+	ret = request_resource(&iomem_resource, &str9100_pci_io);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate I/O "
+		       "memory region (%d)\n", ret);
+		goto out;
+	}
+	ret = request_resource(&iomem_resource, &str9100_pci_nprefetch_mem);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate non-prefetchable "
+		       "memory region (%d)\n", ret);
+		goto release_io;
+	}
+	ret = request_resource(&iomem_resource, &str9100_pci_prefetch_mem);
+	if (ret) {
+		printk(KERN_ERR "PCI: unable to allocate prefetchable "
+		       "memory region (%d)\n", ret);
+		goto release_nprefetch_mem;
+	}
+
+	/*
+	 * bus->resource[0] is the IO resource for this bus
+	 * bus->resource[1] is the mem resource for this bus
+	 * bus->resource[2] is the prefetch mem resource for this bus
+	 */
+	resource[0] = &str9100_pci_io;
+	resource[1] = &str9100_pci_nprefetch_mem;
+	resource[2] = &str9100_pci_prefetch_mem;
+
+	ret = 0;
+
+	goto out;
+
+release_nprefetch_mem:
+	release_resource(&str9100_pci_nprefetch_mem);
+release_io:
+	release_resource(&str9100_pci_io);
+out:
+	return ret;
+}
+
+static irqreturn_t PCI_AHB2PCIB_ISR(int irq, void *dev_id, struct pt_regs * regs)
+{
+	u32 status;
+
+	//disable_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX);
+	pci_read_config_dword(pci_bridge, PCI_COMMAND, &status);
+	printk("AHB to bridge interrupt status: 0x%x\n", status);
+	pci_write_config_dword(pci_bridge, PCI_COMMAND, status);
+	//enable_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t PCI_BROKEN_ISR(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 status;
+
+	status = MISC_PCI_BROKEN_STATUS_REG & 0x1f;
+	printk("PCI BROKEN interrupt status: 0x%x\n", status);
+	MISC_PCI_BROKEN_STATUS_REG = status;
+
+	return IRQ_HANDLED;
+}
+
+int __init str9100_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	if (nr != 0) {
+		return 0;
+	}
+
+	if (str9100_pci_setup_resources(sys->resource)) {
+		BUG();
+	}
+
+	return 1;
+}
+
+struct pci_bus *str9100_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	return pci_scan_bus(sys->busnr, &str9100_pci_ops, sys);
+}
+
+void __init str9100_pci_preinit(void)
+{
+	pci_config_addr = SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR + PCI_BRIDGE_CONFIG_ADDR_REG_OFFSET;
+	pci_config_data = SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR + PCI_BRIDGE_CONFIG_DATA_REG_OFFSET;
+
+#if defined(CONFIG_STAR9100_PCI66M)
+	printk("PCI clock at 66M\n");
+	HAL_PWRMGT_ENABLE_PCI_BRIDGE_66MM();
+#elif defined(CONFIG_STAR9100_PCI33M)
+	printk("PCI clock at 33M\n");
+	HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M();
+#else
+	printk("PCI clock at 33M\n");
+	HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M();
+#endif
+}
+
+void __init str9100_pci_postinit(void)
+{
+	pci_bridge = pci_get_device(PCIB_VENDOR_ID, PCIB_DEVICE_ID, NULL);
+	if (pci_bridge == NULL) {
+		printk("PCI Bridge not found\n");
+		return;
+	} else {
+		printk("PCI Bridge found\n");
+	}
+
+	/* scott.patch */
+	request_irq(INTC_PCI_AHB2BRIDGE_BIT_INDEX, PCI_AHB2PCIB_ISR, IRQF_DISABLED, "pci bridge", pci_bridge);
+
+	MISC_PCI_ARBITER_INTERRUPT_MASK_REG &= ~0x1f;
+
+	/* scott.patch */
+	request_irq(INTC_PCI_ARBITOR_BIT_INDEX, PCI_BROKEN_ISR, IRQF_DISABLED, "pci broken", pci_bridge);
+
+	pci_write_config_dword(pci_bridge, PCI_BASE_ADDRESS_0, 0x0); // = 0x0, can NOT use 0x20000000
+	pci_write_config_dword(pci_bridge, PCI_BASE_ADDRESS_1, 0x0); // = 0x0, can NOT use 0x20000000
+
+	// if we enable pci on u-boot
+	// the pci_enable_device will complain with resource collisions
+	// use this to fixup
+	{
+		int i;
+		struct resource *r;
+
+		for (i = 0; i < 6; i++) {
+			r = pci_bridge->resource + i;
+			r->start = 0;
+			r->end = 0;
+		}
+	}
+
+	pci_enable_device(pci_bridge);
+	pci_set_master(pci_bridge);
+}
+
+/*
+ * map the specified device/slot/pin to an IRQ.   Different backplanes may need to modify this.
+ */
+static int __init str9100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/* slot,  pin,	irq
+	 * 0      1     0
+	 * 1      1     5
+	 * 2      1     6
+	 * 3      1     0
+	 */
+	irq = str9100_pci_irqs[((slot + pin - 1) & 3)];
+
+	printk("PCI map irq: %02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
+		slot, pin, irq);
+
+	return irq;
+}
+
+static struct hw_pci str9100_pci __initdata = {
+	.swizzle		= pci_std_swizzle,
+	.map_irq		= str9100_pci_map_irq,
+	.nr_controllers		= 1,
+	.setup			= str9100_pci_setup,
+	.scan			= str9100_pci_scan_bus,
+	.preinit		= str9100_pci_preinit,
+	.postinit		= str9100_pci_postinit,
+};
+
+static int __init str9100_pci_init(void)
+{
+	pci_common_init(&str9100_pci);
+	return 0;
+}
+
+subsys_initcall(str9100_pci_init);
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_rtc.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_rtc.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_rtc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_rtc.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,493 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/sysctl.h>
+#include <linux/rtc.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <asm/arch/star_rtc.h>
+#include <asm/arch/star_intc.h>
+
+#define STR9100_RTC_DATE        "20060628"
+#define STR9100_RTC_VERSION     "2.0.0"
+#define DEVICE_NAME             "rtc"
+#define SECS_PER_HOUR           (60 * 60)
+#define SECS_PER_DAY            (SECS_PER_HOUR * 24)
+#define TM_YEAR_BASE            1900
+#define EPOCH_YEAR              1970
+#define RTC_INTR_ALARM		0x20
+
+extern spinlock_t rtc_lock;
+
+static int rtc_busy = 0;
+static unsigned long epoch = 1900;
+static unsigned int  rtc_interrupt_flag = 0;
+static time_t local_rtc_offset, set_rtc_offset, current_rtc_time;
+static DECLARE_WAIT_QUEUE_HEAD(str9100_rtc_wait);
+
+# define __isleap(year) ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+
+static const unsigned char days_in_mo[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+                                                                                
+static const unsigned short int __mon_yday[2][13] =
+{
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
+static int offtime (const time_t *t, long int offset, struct rtc_time *tp)
+{
+    long int days, rem, y;
+    const unsigned short int *ip;
+				                                                                                
+    days = *t / SECS_PER_DAY;
+    rem = *t % SECS_PER_DAY;
+    rem += offset;
+    while (rem < 0)
+    {
+         rem += SECS_PER_DAY;
+   	 --days;
+    }
+    while (rem >= SECS_PER_DAY)
+    {
+         rem -= SECS_PER_DAY;
+  	 ++days;
+    }
+    tp->tm_hour = rem / SECS_PER_HOUR;
+    rem %= SECS_PER_HOUR;
+    tp->tm_min = rem / 60;
+    tp->tm_sec = rem % 60;
+    tp->tm_wday = (4 + days) % 7;
+    if (tp->tm_wday < 0)
+      tp->tm_wday += 7;
+    y = 1970;
+#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))
+#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
+    while (days < 0 || days >= (__isleap (y) ? 366 : 365))
+    {
+   	 long int yg = y + days / 365 - (days % 365 < 0);  
+   	 days -= ((yg - y) * 365 + LEAPS_THRU_END_OF (yg - 1)- LEAPS_THRU_END_OF (y - 1));
+   	 y = yg;
+    }
+    tp->tm_year = y - 1900;
+    if (tp->tm_year != y - 1900)
+      return 0;
+    tp->tm_yday = days;
+    ip = __mon_yday[__isleap(y)];
+    for (y = 11; days < (long int) ip[y]; --y)
+       continue;
+    days -= ip[y];
+    tp->tm_mon = y;
+    tp->tm_mday = days + 1;
+    return 1;
+}
+
+static time_t ydhms_tm_diff (int year, int yday, int hour, int min, int sec, const struct rtc_time *tp)
+{
+    if (!tp) return 1;
+    else {
+      int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
+      int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
+      int a100 = a4 / 25 - (a4 % 25 < 0);
+      int b100 = b4 / 25 - (b4 % 25 < 0);
+      int a400 = a100 >> 2;
+      int b400 = b100 >> 2;
+      int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
+      time_t years = year - (time_t) tp->tm_year;
+      time_t days = (365 * years + intervening_leap_days + (yday - tp->tm_yday));
+      return (60 * (60 * (24 * days+(hour - tp->tm_hour))+(min - tp->tm_min))+(sec - tp->tm_sec));
+    }
+}
+
+static time_t _mktime(struct rtc_time *tp, time_t *offset)
+{
+    time_t t;
+    struct rtc_time tm;
+    int sec = tp->tm_sec;
+    int min = tp->tm_min;
+    int hour = tp->tm_hour;
+    int mday = tp->tm_mday;
+    int mon = tp->tm_mon;
+    int year_requested = tp->tm_year;
+
+    int mon_remainder = mon % 12;
+    int negative_mon_remainder = mon_remainder < 0;
+    int mon_years = mon / 12 - negative_mon_remainder;
+    int year = year_requested + mon_years;
+    int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
+  	       [mon_remainder + 12 * negative_mon_remainder])
+  	       + mday - 1);
+    if (year < 69) return -1;
+    tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
+    tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
+    t = ydhms_tm_diff (year, yday, hour, min, sec, &tm);
+    if (year == 69)
+    {
+      if (t < 0 || t > 2 * 24 * 60 * 60) return -1;
+    }
+    *tp = tm;
+    return t;
+}
+
+void get_rtc_time (struct rtc_time *rtc_tm)
+{
+    time_t update_time;
+    static time_t old_time = 0;	
+    
+    spin_lock (&rtc_lock);
+    update_time =  RTC_SECOND_REG + RTC_MINUTE_REG * 60 + RTC_HOUR_REG * 60 * 60 + RTC_DAY_REG * 60 * 60 * 24 - local_rtc_offset + set_rtc_offset;
+    if (old_time > 0)
+    {
+      printk ("\n\n Old time is %d, last time is %d, diff is %d\n",old_time,update_time,update_time-old_time);
+      printk (" Throughput is %d B/s, %d KB/s\n\n",106096775/(update_time-old_time),(106096775/1024)/(update_time-old_time));
+    }
+    old_time = update_time;
+    offtime(&update_time, 0, rtc_tm);	
+    if ((rtc_tm->tm_year += (epoch - 1900)) <= 69)
+      rtc_tm->tm_year += 100; 
+    spin_unlock (&rtc_lock);
+}
+
+int set_rtc_time (struct rtc_time *rtc_tm)
+{
+    unsigned char mon, day, hrs, min, sec, leap_yr;
+    unsigned int yrs;
+    
+    spin_lock (&rtc_lock);
+    yrs = rtc_tm->tm_year + 1900;
+    mon = rtc_tm->tm_mon + 1;  
+    day = rtc_tm->tm_mday;
+    hrs = rtc_tm->tm_hour;
+    min = rtc_tm->tm_min;
+    sec = rtc_tm->tm_sec; 
+    if (yrs < 1970) return -EINVAL;
+    leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+    if ((mon > 12) || (day == 0)) return -EINVAL;
+    if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr))) return -EINVAL;
+    if ((hrs >= 24) || (min >= 60) || (sec >= 60)) return -EINVAL;
+    if ((yrs -= epoch) > 255) return -EINVAL;   
+    local_rtc_offset = RTC_SECOND_REG + RTC_MINUTE_REG * 60 + RTC_HOUR_REG * 60 * 60 + RTC_DAY_REG * 60 * 60 * 24;
+    set_rtc_offset = _mktime(rtc_tm, 0);
+    spin_unlock (&rtc_lock);
+    return 0;
+}
+
+int set_rtc_alm_time (struct rtc_time *alm_tm)
+{
+    unsigned char hrs, min, sec;
+    unsigned long alm_sec;
+    unsigned int volatile rtc_int_status;
+    
+    spin_lock_irq(&rtc_lock);
+    alm_sec = alm_tm->tm_hour * 3600 + alm_tm->tm_min * 60 + alm_tm->tm_sec;
+    hrs = alm_sec / 3600;
+    min = (alm_sec % 3600) / 60;
+    sec = (alm_sec % 3600) % 60;
+    RTC_ALARM_HOUR_REG = hrs;
+    RTC_ALARM_MINUTE_REG = min;
+    RTC_ALARM_SECOND_REG = sec;
+    RTC_CONTROL_REG = RTC_MATCH_ALARM_ENABLE_BIT;
+    rtc_int_status = RTC_INTERRUPT_STATE_REG;
+    RTC_INTERRUPT_STATE_REG = rtc_int_status;                      
+    spin_unlock_irq(&rtc_lock);    
+    return 0;
+}
+
+static loff_t rtc_lseek(struct file *file, loff_t offset, int origin)
+{
+    return -ESPIPE;
+}
+
+static void mask_rtc_irq_bit(unsigned char bit)
+{
+    unsigned char val;
+    unsigned int volatile rtc_int_status;
+
+    spin_lock_irq(&rtc_lock);
+    val = RTC_CONTROL_REG;
+    val &=  ~bit;
+    RTC_CONTROL_REG = val;
+    rtc_int_status = RTC_INTERRUPT_STATE_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static void set_rtc_irq_bit(unsigned char bit)
+{
+    unsigned char val;
+    unsigned int volatile rtc_int_status;	
+        
+    spin_lock_irq(&rtc_lock);
+    val = RTC_CONTROL_REG;
+    val |= bit;
+    RTC_CONTROL_REG = val;
+    rtc_int_status = RTC_INTERRUPT_STATE_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static void get_rtc_alm_time(struct rtc_time *alm_tm)
+{
+    spin_lock_irq(&rtc_lock);
+    alm_tm->tm_sec = RTC_ALARM_SECOND_REG;
+    alm_tm->tm_min = RTC_ALARM_MINUTE_REG;
+    alm_tm->tm_hour = RTC_ALARM_HOUR_REG;
+    spin_unlock_irq(&rtc_lock);
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,unsigned long arg)
+{
+    struct rtc_time wtime; 
+
+    switch (cmd)
+    {
+	case RTC_RD_TIME:
+	        memset(&wtime, 0, sizeof(struct rtc_time));
+		get_rtc_time(&wtime);
+		break;
+	case RTC_SET_TIME:
+	{         
+		struct rtc_time rtc_tm;
+		if (!capable(CAP_SYS_TIME))
+		  return -EPERM;
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))
+		  return -EFAULT;
+		set_rtc_time(&rtc_tm);
+		return 0;
+	}	
+        case RTC_ALM_SET:
+        {
+        	struct rtc_time alm_tm; 
+		if (copy_from_user(&alm_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))
+		  return -EFAULT;
+		memset(&wtime, 0, sizeof(struct rtc_time));  
+		set_rtc_alm_time(&alm_tm);
+		return 0;
+	}	
+	case RTC_ALM_READ:
+	        memset(&wtime, 0, sizeof(struct rtc_time));
+		get_rtc_alm_time(&wtime);
+		break;
+	case RTC_AIE_OFF:
+	        mask_rtc_irq_bit(RTC_INTR_ALARM);	
+		return 0;
+	case RTC_AIE_ON:
+	        set_rtc_irq_bit(RTC_INTR_ALARM);
+		return 0;	
+	default:
+		return -EINVAL;
+    }
+    return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+static void rtc_fire(int irq, void *dev_id, struct pt_regs *regs)
+{
+    unsigned int volatile    rtc_int_status;	
+    
+    HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_RTC_BIT_INDEX);
+    HAL_RTC_READ_INTERRUPT_STATUS(rtc_int_status);
+    HAL_RTC_WRITE_INTERRUPT_STATUS(rtc_int_status);
+    if (rtc_int_status & RTC_AUTO_SECOND_ALARM_INTERRUPT_BIT) rtc_interrupt_flag |= RTC_AUTO_SECOND_ALARM_INTERRUPT_BIT;
+    if (rtc_int_status & RTC_AUTO_MINUTE_ALARM_INTERRUPT_BIT) rtc_interrupt_flag |= RTC_AUTO_MINUTE_ALARM_INTERRUPT_BIT;
+    if (rtc_int_status & RTC_AUTO_HOUR_ALARM_INTERRUPT_BIT) rtc_interrupt_flag |= RTC_AUTO_HOUR_ALARM_INTERRUPT_BIT;
+    if (rtc_int_status & RTC_AUTO_DAY_ALARM_INTERRUPT_BIT) rtc_interrupt_flag |= RTC_AUTO_DAY_ALARM_INTERRUPT_BIT;
+    if (rtc_int_status & RTC_MATCH_ALARM_INTERRUPT_BIT) {rtc_interrupt_flag |= RTC_MATCH_ALARM_INTERRUPT_BIT;
+      wake_up_interruptible(&str9100_rtc_wait);
+    }
+    if (rtc_int_status & RTC_BATTERY_LOW_VOLTAGE_INTR_BIT)
+    {
+      rtc_interrupt_flag |= RTC_BATTERY_LOW_VOLTAGE_INTR_BIT;
+      printk("str9100 rtc: Low Battery Voltage!!\n");
+    }
+    if (!(rtc_interrupt_flag & RTC_MATCH_ALARM_INTERRUPT_BIT)) HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_RTC_BIT_INDEX);
+}
+
+static void rtc_str9100_hwinit(int ctrl, int hour, int min, int sec)
+{    	
+    RTC_CONTROL_REG &= ~(RTC_ENABLE_BIT);	
+    if (ctrl & RTC_MATCH_ALARM_ENABLE_BIT)
+    {
+      RTC_ALARM_SECOND_REG = sec;
+      RTC_ALARM_MINUTE_REG = min;
+      RTC_ALARM_HOUR_REG = hour;    	
+    }else{
+      RTC_ALARM_SECOND_REG = 0;
+      RTC_ALARM_MINUTE_REG = 0;
+      RTC_ALARM_HOUR_REG = 0;
+    } 
+    RTC_CONTROL_REG = ctrl;
+} 
+
+static int rtc_open(struct inode *inode, struct file *file)
+{
+    if (rtc_busy) return -EBUSY;
+
+    rtc_busy = 1;
+    return 0;
+}
+
+static ssize_t rtc_read(struct file * file, char *buf, size_t count, loff_t * ppos)
+{
+    DECLARE_WAITQUEUE(wait, current);
+    unsigned long data;
+    ssize_t retval;
+
+    if (count < sizeof(unsigned long))
+      return -EINVAL;
+
+    add_wait_queue(&str9100_rtc_wait, &wait);
+    set_current_state(TASK_INTERRUPTIBLE);
+    for (;;) {
+	spin_lock(&rtc_lock);
+	data = rtc_interrupt_flag;
+	if (data != 0) {
+	  rtc_interrupt_flag = 0;
+	  break;
+	}
+        spin_unlock(&rtc_lock);
+        if (file->f_flags & O_NONBLOCK) {
+	  retval = -EAGAIN;
+	  goto out;
+	}
+	if (signal_pending(current)) {
+	  retval = -ERESTARTSYS;
+	  goto out;
+	}
+        schedule();
+    }
+    spin_unlock(&rtc_lock);
+    retval = put_user(data, (unsigned long *) buf);
+    if (!retval) retval = sizeof(unsigned long);
+out:
+    mask_rtc_irq_bit(RTC_INTR_ALARM);
+    set_current_state(TASK_RUNNING);
+    remove_wait_queue(&str9100_rtc_wait, &wait);
+    return retval;
+}
+
+static int rtc_release(struct inode *inode, struct file *file)
+{
+    rtc_busy = 0;
+    return 0;
+}
+
+static struct file_operations rtc_fops = {
+    owner:	THIS_MODULE,
+    llseek:	rtc_lseek,
+    ioctl:	rtc_ioctl,
+    open:	rtc_open,
+    read:       rtc_read,
+    release:	rtc_release
+};
+
+static struct miscdevice rtc_dev = { RTC_MINOR, "rtc", &rtc_fops };
+
+static int rtc_proc_output (char *buf)
+{
+    char *p;
+    struct rtc_time tm;
+    
+    p = buf;
+    get_rtc_time(&tm);
+    p += sprintf(p,"rtc_time\t: %02d:%02d:%02d\n"
+		   "rtc_date\t: %04d-%02d-%02d\n"
+	 	   "rtc_epoch\t: %04lu\n",
+		   tm.tm_hour, tm.tm_min, tm.tm_sec,
+		   tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, epoch);
+    get_rtc_alm_time(&tm);
+    p += sprintf(p, "alarm\t\t: ");
+    if (tm.tm_hour <= 24)
+      p += sprintf(p, "%02d:", tm.tm_hour);
+    else
+      p += sprintf(p, "**:");
+    if (tm.tm_min <= 59)
+      p += sprintf(p, "%02d:", tm.tm_min);
+    else
+      p += sprintf(p, "**:");
+    if (tm.tm_sec <= 59)
+      p += sprintf(p, "%02d\n", tm.tm_sec);
+    else
+      p += sprintf(p, "**\n");	
+    return  p - buf;
+}
+
+static int rtc_read_proc(char *page, char **start, off_t off,int count, int *eof, void *data)
+{
+    int len = rtc_proc_output (page);
+    
+    if (len <= off+count) *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len>count) len = count;
+    if (len<0) len = 0;
+    return len;
+}
+
+static int __init str9100_rtc_init(void)
+{
+    int error;
+
+    error = misc_register(&rtc_dev);
+    if (error) {
+      printk(KERN_ERR "rtc: unable to get misc minor\n");
+      return error;
+    }	
+    printk(KERN_INFO "STR9100 Real Time Clock Driver v" STR9100_RTC_VERSION "\n");
+    rtc_str9100_hwinit(0,0,0,0);
+    HAL_RTC_ENABLE();
+    request_irq(INTC_RTC_BIT_INDEX, rtc_fire, 0, DEVICE_NAME, NULL);
+    create_proc_read_entry ("driver/rtc", 0, 0, rtc_read_proc, NULL);
+    local_rtc_offset = 0;
+    set_rtc_offset = current_rtc_time = 0;        
+    return 0;
+}
+
+static void __exit str9100_rtc_exit (void)
+{
+    char buf[64];
+    	
+    HAL_RTC_DISABLE();		
+    cleanup_sysctl();
+    sprintf (buf,"driver/%s",DEVICE_NAME);
+    remove_proc_entry (buf, NULL);
+    misc_deregister(&rtc_dev);
+    free_irq (INTC_RTC_BIT_INDEX, NULL);
+}
+
+module_init(str9100_rtc_init);
+module_exit(str9100_rtc_exit);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_setup.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_setup.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_setup.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_setup.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,357 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_8250.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+#include <asm/system.h>
+#include <asm/memory.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#define STR9100_UART_XTAL 14769230
+
+#define EARLY_REGISTER_CONSOLE
+
+/*
+ * Standard IO mapping
+ */
+static struct map_desc str9100_std_desc[] __initdata = {
+	{
+		.virtual	= SYSVA_FLASH_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_FLASH_BASE_ADDR),
+		.length		= SZ_8M,
+		.type		= MT_DEVICE
+	}, 	{
+		.virtual	= SYSVA_SMC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_SMC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_DDR_SDRAM_CONTROLLER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_DDR_SDRAM_CONTROLLER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_DMAC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_DMAC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_GSW_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_GSW_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_HNAT_SRAM_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_HNAT_SRAM_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_MISC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_MISC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_POWER_MANAGEMENT_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_POWER_MANAGEMENT_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_UART_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_UART_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_TIMER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_TIMER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_WATCHDOG_TIMER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_WATCHDOG_TIMER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_RTC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_RTC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_GPIO_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_GPIO_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_INTC_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_INTC_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCMCIA_CONTROLLER_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCMCIA_CONTROLLER_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB11_CONFIG_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB11_CONFIG_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB11_OPERATION_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB11_OPERATION_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB20_CONFIG_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB20_CONFIG_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= SYSVA_USB20_OPERATION_BASE_ADDR,
+		.pfn		= __phys_to_pfn(SYSPA_USB20_OPERATION_BASE_ADDR),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}
+};
+
+#ifdef EARLY_REGISTER_CONSOLE
+static struct uart_port str9100_serial_ports[] = {
+	{
+		.membase	= (char*)(SYSVA_UART_BASE_ADDR),
+		.mapbase	= (SYSPA_UART_BASE_ADDR),
+		.irq		= INTC_UART_BIT_INDEX,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= STR9100_UART_XTAL,
+		.line		= 0,
+		.type		= PORT_16550A,
+		.fifosize	= 16
+	}
+};
+#else
+static struct resource str9100_uart0_resources[] = {
+	[0] = {
+		.start	= SYSPA_UART_BASE_ADDR,
+		.end	= SYSPA_UART_BASE_ADDR + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_UART_BIT_INDEX,
+		.end	= INTC_UART_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct plat_serial8250_port str9100_uart0_data[] = {
+	{
+		.membase	= (char*)(SYSVA_UART_BASE_ADDR),
+		.mapbase	= (SYSPA_UART_BASE_ADDR),
+		.irq		= INTC_UART_BIT_INDEX,
+		.uartclk	= STR9100_UART_XTAL,
+		.regshift	= 2,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+	},
+	{  },
+};
+
+static struct platform_device str9100_uart0_device = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev.platform_data	= str9100_uart0_data,
+	.num_resources		= 2,
+	.resource		= str9100_uart0_resources,
+};
+#endif
+
+static u64 usb_dmamask = 0xffffffffULL;
+static struct resource str9100_usb11_resources[] = {
+	[0] = {
+		.start	= SYSPA_USB11_CONFIG_BASE_ADDR,
+		.end	= SYSPA_USB11_CONFIG_BASE_ADDR + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_USB11_BIT_INDEX,
+		.end	= INTC_USB11_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device str9100_usb11_device = {
+	.name		= "str9100-ohci",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= str9100_usb11_resources,
+	.num_resources	= ARRAY_SIZE(str9100_usb11_resources),
+};
+
+static struct resource str9100_usb20_resources[] = {
+	[0] = {
+		.start	= SYSPA_USB20_CONFIG_BASE_ADDR,
+		.end	= SYSPA_USB20_CONFIG_BASE_ADDR + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INTC_USB20_BIT_INDEX,
+		.end	= INTC_USB20_BIT_INDEX,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device str9100_usb20_device = {
+	.name		= "str9100-ehci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= str9100_usb20_resources,
+	.num_resources	= ARRAY_SIZE(str9100_usb20_resources),
+};
+
+static struct platform_device *str9100_devices[] __initdata = {
+#ifndef EARLY_REGISTER_CONSOLE
+	&str9100_uart0_device,
+#endif
+	&str9100_usb11_device,
+	&str9100_usb20_device
+};
+
+static void __init str9100_fixup(struct machine_desc *desc,
+	struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+        mi->nr_banks = 1;
+	mi->bank[0].start = CONFIG_SYSTEM_DRAM_BASE;
+	mi->bank[0].size = CONFIG_SYSTEM_DRAM_SIZE << 20;
+	mi->bank[0].node = 0;
+}
+
+/* ######################################################################### */
+#ifdef CONFIG_CPU_ISPAD_ENABLE 
+extern unsigned long __ispad_begin; 
+extern int str9100_enable_ispad(unsigned long); 
+#endif
+u32 CPU_clock;
+u32 AHB_clock;
+u32 APB_clock;
+// This function is called just after the
+// page table and cpu have been initialized
+void __init str9100_early_init(void)
+{
+	switch ((PWRMGT_RESET_LATCH_CONFIGURATION_REG >> 6) & 0x03) {
+	case 0x00:
+		CPU_clock = 175000000;
+		break;
+
+	case 0x01:
+		CPU_clock = 200000000;
+		break;
+
+	case 0x02:
+		CPU_clock = 225000000;
+		break;
+
+	case 0x03:
+		CPU_clock = 250000000;
+		break;
+	}
+
+	AHB_clock = CPU_clock >> 1;
+	APB_clock = AHB_clock >> 1;
+
+	printk("CPU clock at %dMHz\n", CPU_clock / 1000000);
+	printk("AHB clock at %dMHz\n", AHB_clock / 1000000);
+	printk("APB clock at %dMHz\n", APB_clock / 1000000);
+
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+	str9100_enable_ispad((unsigned long)&__ispad_begin);
+#endif
+}
+/* ######################################################################### */
+
+void __init str9100_init(void)
+{
+#if 1
+	platform_add_devices(str9100_devices, ARRAY_SIZE(str9100_devices));
+#else
+#ifndef EARLY_REGISTER_CONSOLE
+	platform_device_register(&str9100_uart0_device);
+#endif
+	platform_device_register(&str9100_usb11_device);
+	platform_device_register(&str9100_usb20_device);
+#endif
+}
+
+extern void str9100_register_map_desc(struct map_desc *map, int count);
+void __init str9100_map_io(void)
+{
+	iotable_init(str9100_std_desc, ARRAY_SIZE(str9100_std_desc));
+	str9100_register_map_desc(str9100_std_desc, ARRAY_SIZE(str9100_std_desc));
+#ifdef EARLY_REGISTER_CONSOLE
+	early_serial_setup(&str9100_serial_ports[0]);
+#endif
+}
+
+extern void str9100_init_irq(void);
+extern struct sys_timer str9100_timer;
+
+MACHINE_START(STR9100, "STAR STR9100")
+	.phys_io	= SYSPA_UART_BASE_ADDR,
+	.io_pg_offst	= ((SYSVA_UART_BASE_ADDR) >> 18) & 0xfffc, // virtual, physical
+	.fixup		= str9100_fixup,
+	.map_io		= str9100_map_io,
+	.init_irq	= str9100_init_irq,
+	.timer		= &str9100_timer,
+	.boot_params	= 0x0100,
+	.init_machine	= str9100_init,
+MACHINE_END
+
diff -Nur linux-2.6.35.11/arch/arm/mach-str9100/str9100_timer.c linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_timer.c
--- linux-2.6.35.11/arch/arm/mach-str9100/str9100_timer.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mach-str9100/str9100_timer.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,219 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/timex.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#if 1
+// for timer clock < 100MHz
+#define uSECS_PER_TICK	(1000000 / APB_clock)
+#define TICKS2USECS(x)  ((x) * uSECS_PER_TICK)
+#else
+// for timer clock >= 100MHz
+#define TICKS_PER_uSEC	(APB_clock / 1000000)
+#define TICKS2USECS(x)  ((x) / TICKS_PER_uSEC)
+#endif
+
+extern u32 APB_clock;
+static u32 timer_counter_value;
+
+static inline unsigned int str9100_read_timer_counter(void)
+{
+	return TIMER1_COUNTER_REG;
+}
+
+static inline unsigned int str9100_read_timer_interrupt_status(void)
+{
+	return TIMER_INTERRUPT_STATUS_REG;
+}
+
+static inline void str9100_clear_timer_interrupt_status(unsigned int irq)
+{
+	TIMER_INTERRUPT_STATUS_REG &= ~(1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX);
+}
+
+static void str9100_setup_timer(unsigned int counter_value)
+{
+	unsigned long control_value;
+	unsigned long mask_value;    
+
+	control_value = TIMER_CONTROL_REG;
+	mask_value = TIMER_INTERRUPT_MASK_REG;
+
+	TIMER1_COUNTER_REG = counter_value;
+	TIMER1_AUTO_RELOAD_VALUE_REG = counter_value;
+	TIMER1_MATCH_VALUE1_REG = 0;
+	TIMER1_MATCH_VALUE2_REG = 0;
+
+	// Clock Source: PCLK
+	control_value &= ~(1 << TIMER1_CLOCK_SOURCE_BIT_INDEX);
+
+	// Down Count Mode
+	control_value |= (1 << TIMER1_UP_DOWN_COUNT_BIT_INDEX);
+
+	// un-mask overflow, match2 and match1 interrupt sources
+	mask_value &= ~(0x7);
+
+	// mask match2 and match1 interrupt sources
+	mask_value |= 0x03;
+
+	TIMER_CONTROL_REG = control_value;
+	TIMER_INTERRUPT_MASK_REG = mask_value;
+}
+
+static void str9100_timer_enable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER_CONTROL_REG;
+
+	// enable overflow mode
+	control_value |= (1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// enable the timer
+	control_value |= (1 << TIMER1_ENABLE_BIT_INDEX);
+
+	TIMER_CONTROL_REG = control_value;
+}
+
+static void str9100_timer_disable(void)
+{
+	unsigned long control_value;
+
+	control_value = TIMER_CONTROL_REG;
+
+	// disable overflow mode
+	control_value &= ~(1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX);
+
+	// disable the timer
+	control_value &= ~(1 << TIMER1_ENABLE_BIT_INDEX);
+
+	TIMER_CONTROL_REG = control_value;
+}
+
+/*
+ * Returns number of us since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+static unsigned long str9100_gettimeoffset(void)
+{
+	unsigned long ticks1, ticks2;
+	unsigned long interrupt_status;
+
+	/*
+	 * Get the current number of ticks.  Note that there is a race
+	 * condition between us reading the timer and checking for
+	 * an interrupt.  We get around this by ensuring that the
+	 * counter has not reloaded between our two reads.
+	 */
+	ticks2 = str9100_read_timer_counter();
+	do {
+		ticks1 = ticks2;
+		interrupt_status = str9100_read_timer_interrupt_status();
+		ticks2 = str9100_read_timer_counter();
+	} while (ticks2 > ticks1);
+
+	/*
+	 * Number of ticks since last interrupt
+	 */
+	ticks1 = timer_counter_value - ticks2;
+
+	/*
+	 * Interrupt pending?  If so, we've reloaded once already.
+	 */
+	if (interrupt_status) {
+		ticks1 += timer_counter_value;
+	}
+
+	/*
+	 * Convert the ticks to usecs
+	 */
+	return TICKS2USECS(ticks1);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+str9100_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+
+	str9100_clear_timer_interrupt_status((unsigned int)irq);
+	/* 2008/05/12 Richard 
+	timer_tick(regs);
+	 */
+	timer_tick();
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction str9100_timer_irq = {
+	.name		= "STR9100 Timer Tick",
+/* 2008/05/12 Richard
+	.flags		= SA_INTERRUPT | SA_TIMER,
+ */
+	.flags          = IRQF_DISABLED | IRQF_TIMER,
+	.handler	= str9100_timer_interrupt,
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+static void __init str9100_timer_init(void)
+{
+	/*
+	 * prepare timer-related values
+	 */
+	timer_counter_value = APB_clock / HZ;
+
+	/*
+	 * setup timer-related values
+	 */
+	str9100_setup_timer(timer_counter_value);
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(INTC_TIMER1_BIT_INDEX, &str9100_timer_irq);
+
+	str9100_timer_enable();
+}
+
+struct sys_timer str9100_timer = {
+	.init		= str9100_timer_init,
+	.offset		= str9100_gettimeoffset,
+};
+
diff -Nur linux-2.6.35.11/arch/arm/Makefile linux-2.6.35.11-ts7500//arch/arm/Makefile
--- linux-2.6.35.11/arch/arm/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -18,6 +18,7 @@
 OBJCOPYFLAGS	:=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 GZFLAGS		:=-9
 #KBUILD_CFLAGS	+=-pipe
+KBUILD_CFLAGS	+=-pipe -gdwarf-2
 # Explicitly specifiy 32-bit ARM ISA since toolchain default can be -mthumb:
 KBUILD_CFLAGS	+=$(call cc-option,-marm,)
 
@@ -186,6 +187,10 @@
 machine-$(CONFIG_MACH_SPEAR310)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
+machine-$(CONFIG_ARCH_STR9100)    := str9100
+machine-$(CONFIG_ARCH_STR8100)    := str8100
+
+
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff -Nur linux-2.6.35.11/arch/arm/mm/cache-fa.S linux-2.6.35.11-ts7500//arch/arm/mm/cache-fa.S
--- linux-2.6.35.11/arch/arm/mm/cache-fa.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/cache-fa.S	2011-02-26 20:32:46.000000000 -0500
@@ -1,3 +1,4 @@
+#if (1)
 /*
  *  linux/arch/arm/mm/cache-fa.S
  *
@@ -34,6 +35,7 @@
 #define CACHE_DSIZE	16384 
 #endif 
 
+
 /* FIXME: put optimal value here. Current one is just estimation */
 #define CACHE_DLIMIT	(CACHE_DSIZE * 2)
 
@@ -142,7 +144,9 @@
 	cmp	r0, r1
 	blo	1b
 	mov	r0, #0
+/*
 	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+*/
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
 
@@ -157,7 +161,7 @@
  *	- start  - virtual start address
  *	- end	 - virtual end address
  */
-fa_dma_inv_range:
+ENTRY(fa_dma_inv_range)
 	tst	r0, #CACHE_DLINESIZE - 1
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 	mcrne	p15, 0, r0, c7, c14, 1		@ clean & invalidate D entry
@@ -180,7 +184,7 @@
  *	- start  - virtual start address
  *	- end	 - virtual end address
  */
-fa_dma_clean_range:
+ENTRY(fa_dma_clean_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	add	r0, r0, #CACHE_DLINESIZE
@@ -229,6 +233,10 @@
 	mov	pc, lr
 ENDPROC(fa_dma_unmap_area)
 
+
+
+
+
 	__INITDATA
 
 	.type	fa_cache_fns, #object
@@ -243,3 +251,408 @@
 	.long	fa_dma_unmap_area
 	.long	fa_dma_flush_range
 	.size	fa_cache_fns, . - fa_cache_fns
+#else
+
+/* Most of the following is from 2.6.24-cavium */
+
+/*
+ *  linux/arch/arm/mm/cache-fa.S
+ *
+ *  Copyright (C) 2005 Faraday Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Processors: FA520 FA526 FA626	
+ * 03/31/2005 :	Luke Lee created, modified from cache-v4wb.S
+ * 04/06/2005 :	1. Read CR0-1 and determine the cache size dynamically,
+ *		   to suit all Faraday CPU series
+ *	        2. Fixed all functions
+ * 04/08/2005 :	insert CONFIG_CPU_ICACHE_DISABLE and CONFIG_CPU_DCACHE_DISABLE
+ * 04/12/2005 :	TODO: make this processor dependent or a self-modifying code to 
+ *	        inline cache len/size info into the instructions, as reading cache 
+ *	        size and len info in memory could cause another cache miss.
+ * 05/05/2005 :	Modify fa_flush_user_cache_range to comply APCS.
+ * 05/19/2005 :	Adjust for boundary conditions.
+ */
+//#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <mach/hardware.h>
+#include <asm/page.h>
+#include "proc-macros.S"
+
+#define CACHE_DLINESIZE	   16
+#define CACHE_DSIZE	   16384
+#define CACHE_ILINESIZE	   16
+#define CACHE_ISIZE	   16384
+
+/*
+ *	initialize_cache_info()
+ *
+ *	Automatic detection of DSIZE, DLEN, ISIZE, ILEN variables according to 
+ *	system register CR0-1
+ *	Destroyed register: r0, r1, r2, r3, ip
+ */
+	.align
+ENTRY(fa_initialize_cache_info)
+	mov	r3, #1				@ r3 always = 1
+	adr	ip, __fa_cache_ilen
+	
+	mrc	p15, 0, r0, c0, c0, 1
+	/* ILEN */
+	and	r1, r0, #3			@ bits [1:0]
+	add	r1, r1, #3			@ cache line size is at least 8 bytes (2^3)
+	mov	r2, r3, lsl r1			@ r2 = 1<<r1
+	str	r2, [ip], #4
+	/* ISIZE */
+	mov	r1, r0, lsr #6			@ bits [8:6]
+	and	r1, r1, #7
+	add	r1, r1, #9			@ cache size is at least 512 bytes (2^9)
+	mov	r2, r3, lsl r1
+	str	r2, [ip], #4
+	/* DLEN */
+	mov	r1, r0, lsr #12
+	and	r1, r1, #3			@ bits [13:12]
+	add	r1, r1, #3			@ cache line size is at least 8 bytes (2^3)
+	mov	r2, r3, lsl r1			@ r2 = 1<<r1
+	str	r2, [ip], #4
+	/* DSIZE */
+	mov	r1, r0, lsr #18			@ bits [20:18]
+	and	r1, r1, #7
+	add	r1, r1, #9			@ cache size is at least 512 bytes (2^9)
+	mov	r2, r3, lsl r1
+	str	r2, [ip]
+	mov	pc, lr
+
+	/* Warning : Do not change the order ! Successive codes depends on this */
+	.align
+	.globl __fa_cache_ilen, __fa_cache_isize, __fa_cache_dlen, __fa_cache_dsize
+__fa_cache_ilen:
+	.word	0				@ instruction cache line length
+__fa_cache_isize:
+	.word	0				@ instruction cache size
+__fa_cache_dlen:
+	.word	0				@ data cahce line length	
+__fa_cache_dsize:
+	.word	0				@ data cache size
+
+/*
+ *	flush_user_cache_all()
+ *
+ *	Clean and invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(fa_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(fa_flush_kern_cache_all)
+	mov	ip, #0
+	
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	
+__flush_whole_cache:
+	
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	ip, #0
+#  ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#  else
+	mcr	p15, 0, ip, c7,c14, 0		@ clean/invalidate D cache
+#  endif
+#endif /*CONFIG_CPU_DCACHE_DISABLE*/
+	
+#ifndef CONFIG_CPU_FA_WB_DISABLE	
+	mcr	p15, 0, ip, c7, c10, 4		@ drain write buffer
+#endif
+	
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, ip, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif
+	
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start - start address (inclusive, page aligned)
+ *	- end	- end address (exclusive, page aligned)
+ *	- flags	- vma_area_struct flags describing address space
+ */
+ENTRY(fa_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	tst	r2, #VM_EXEC			@ executable region?
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE	
+	cmp	r3, #CACHE_DSIZE		@ total size >= limit?
+	bhs	__flush_whole_cache		@ flush whole D cache
+
+1:
+	
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+#else
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	bls	1b
+#endif	/* CONFIG_CPU_DCACHE_DISABLE */
+	
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	tst	r2, #VM_EXEC
+	mcreq	p15, 0, r4, c7, c10, 4		@ drain write buffer
+#endif
+
+#ifdef CONFIG_CPU_FA_BTB
+        tst     r2, #VM_EXEC
+	mov	ip, #0
+	mcrne	p15, 0, ip, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(fa_flush_kern_dcache_page)
+	add	r1, r0, #PAGE_SZ
+	/* fall through */
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(fa_coherent_kern_range)
+	/* fall through */
+
+/*
+ *	coherent_user_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(fa_coherent_user_range)
+	bic	r0, r0, #CACHE_DLINESIZE-1
+
+#if !(defined(CONFIG_CPU_DCACHE_DISABLE) && defined(CONFIG_CPU_ICACHE_DISABLE))
+1:
+#ifndef CONFIG_CPU_DCACHE_DISABLE	
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+#else
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+#endif
+#endif /* CONFIG_CPU_DCACHE_DISABLE */
+	
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	bls	1b				@ Luke Lee 05/19/2005 blo->bls	
+#endif /* !(defined(CONFIG_CPU_DCACHE_DISABLE) && defined(CONFIG_CPU_ICACHE_DISABLE)) */
+
+	mov	ip, #0
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, ip, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif
+
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#endif
+	
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(fa_dma_inv_range)
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE	
+
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	tst	r0, #CACHE_DLINESIZE -1
+	bic	r0, r0, #CACHE_DLINESIZE -1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean boundary D entry
+	mcr	p15, 0, r1, c7, c10, 1		@ clean boundary D entry
+#else
+	bic	r0, r0, #CACHE_DLINESIZE -1	
+#endif
+	
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	bls	1b				@ Luke Lee 05/19/2005 blo->bls
+#endif /* CONFIG_CPU_DCACHE_DISABLE */
+
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#endif	
+	mov	pc, lr
+
+	
+	
+	
+	
+	
+	
+	
+/***** The following was lifted from 2.6.34 */   
+/*
+ *	flush_kern_dcache_area(void *addr, size_t size)
+ *
+ *	Ensure that the data held in the page kaddr is written back
+ *	to the page in question.
+ *
+ *	- addr	- kernel address
+ *	- size	- size of region
+ */
+ENTRY(fa_flush_kern_dcache_area)
+	add	r1, r0, r1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D line
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	mov	pc, lr
+   
+/*
+ *	dma_map_area(start, size, dir)
+ *	- start	- kernel virtual start address
+ *	- size	- size of region
+ *	- dir	- DMA direction
+ */
+ENTRY(fa_dma_map_area)
+	add	r1, r1, r0
+	cmp	r2, #DMA_TO_DEVICE
+	beq	fa_dma_clean_range
+	bcs	fa_dma_inv_range
+	b	fa_dma_flush_range
+ENDPROC(fa_dma_map_area)
+
+/*
+ *	dma_unmap_area(start, size, dir)
+ *	- start	- kernel virtual start address
+ *	- size	- size of region
+ *	- dir	- DMA direction
+ */
+ENTRY(fa_dma_unmap_area)
+	mov	pc, lr
+ENDPROC(fa_dma_unmap_area)   
+
+
+/********************/
+	
+	
+	
+	
+	
+	
+
+	
+	
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean (write back) the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(fa_dma_clean_range)
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE	
+
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	bls	1b				@ Luke Lee 05/19/2005 blo->bls
+
+#endif
+#endif /* CONFIG_CPU_DCACHE_DISABLE */
+
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mov	r0, #0	
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#endif	
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ *
+ *	This is actually the same as fa_coherent_kern_range()
+ */
+	.globl	fa_dma_flush_range
+	.set	fa_dma_flush_range, fa_coherent_kern_range
+
+	__INITDATA
+
+	.type	fa_cache_fns, #object
+ENTRY(fa_cache_fns)
+	.long	fa_flush_kern_cache_all
+	.long	fa_flush_user_cache_all
+	.long	fa_flush_user_cache_range
+	.long	fa_coherent_kern_range
+	.long	fa_coherent_user_range
+	.long	fa_flush_kern_dcache_page
+	.long	fa_dma_inv_range
+	.long	fa_dma_clean_range
+	.long	fa_dma_flush_range
+	.size	fa_cache_fns, . - fa_cache_fns
+   
+
+   
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mm/copypage-fa.c linux-2.6.35.11-ts7500//arch/arm/mm/copypage-fa.c
--- linux-2.6.35.11/arch/arm/mm/copypage-fa.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/copypage-fa.c	2011-02-26 20:32:46.000000000 -0500
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/highmem.h>
 
+#include <asm/page.h>
 /*
  * Faraday optimised copy_user_page
  */
diff -Nur linux-2.6.35.11/arch/arm/mm/dma-mapping.c linux-2.6.35.11-ts7500//arch/arm/mm/dma-mapping.c
--- linux-2.6.35.11/arch/arm/mm/dma-mapping.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/dma-mapping.c	2011-02-26 20:32:46.000000000 -0500
@@ -576,7 +576,8 @@
  * @nents: number of buffers to map (returned from dma_map_sg)
  * @dir: DMA transfer direction (same as was passed to dma_map_sg)
  */
-void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
+void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist 
+*sg,
 			int nents, enum dma_data_direction dir)
 {
 	struct scatterlist *s;
diff -Nur linux-2.6.35.11/arch/arm/mm/flush.c linux-2.6.35.11-ts7500//arch/arm/mm/flush.c
--- linux-2.6.35.11/arch/arm/mm/flush.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/flush.c	2011-02-26 20:32:46.000000000 -0500
@@ -290,7 +290,7 @@
 		 * userspace address only.
 		 */
 		flush_pfn_alias(pfn, vmaddr);
-		__flush_icache_all();
+		__flush_icache_all(); 
 	}
 
 	/*
diff -Nur linux-2.6.35.11/arch/arm/mm/Kconfig linux-2.6.35.11-ts7500//arch/arm/mm/Kconfig
--- linux-2.6.35.11/arch/arm/mm/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -142,6 +142,54 @@
 	  Say Y if you want support for the ARM922T processor.
 	  Otherwise, say N.
 
+# FA520/FA526/FA626
+
+choice
+	prompt "Faraday processor (ARM9 compatible) type"
+	default CPU_FA526
+	depends on ARCH_STR9100 || ARCH_STR8100
+
+#config CPU_FA520
+#       bool  "FA520 processor"
+#       depends on ARCH_STR9100 || ARCH_STR8100
+#       select CPU_32v4
+#       select CPU_ABRT_EV4
+#       select CPU_CACHE_FA
+#       select CPU_CACHE_VIVT
+#       select CPU_COPY_V4WB
+#       select CPU_TLB_FA
+#       help
+#         //TODO: FA520 help info
+
+config CPU_FA526
+	bool  "FA526 processor"
+	depends on ARCH_STR9100 || ARCH_STR8100
+	select CPU_32v4
+   select CPU_PABRT_LEGACY
+	select CPU_ABRT_EV4
+   select CPU_CP15_MMU
+   select CPU_CACHE_FA
+   select CPU_CACHE_VIVT
+	select CPU_COPY_FA if MMU
+	select CPU_TLB_FA if MMU
+	help
+	  //TODO: FA526 help info
+
+#config CPU_FA626
+#       bool  "FA626 processor"
+#       depends on ARCH_STR9100 || ARCH_STR8100
+#       select CPU_32v4
+#       select CPU_ABRT_EV4
+#       select CPU_CACHE_FA
+#       select CPU_CACHE_VIPT
+#       select CPU_COPY_V4WB
+#       select CPU_TLB_FA
+#       help
+#         //TODO: FA626 help info
+
+endchoice
+     
+     
 # ARM925T
 config CPU_ARM925T
  	bool "Support ARM925T processor" if ARCH_OMAP1
@@ -180,22 +228,22 @@
 	  Otherwise, say N.
 
 # FA526
-config CPU_FA526
-	bool
-	select CPU_32v4
-	select CPU_ABRT_EV4
-	select CPU_PABRT_LEGACY
-	select CPU_CACHE_VIVT
-	select CPU_CP15_MMU
-	select CPU_CACHE_FA
-	select CPU_COPY_FA if MMU
-	select CPU_TLB_FA if MMU
-	help
-	  The FA526 is a version of the ARMv4 compatible processor with
-	  Branch Target Buffer, Unified TLB and cache line size 16.
-
-	  Say Y if you want support for the FA526 processor.
-	  Otherwise, say N.
+#config CPU_FA526
+#	bool
+#	select CPU_32v4
+#	select CPU_ABRT_EV4
+#	select CPU_PABRT_LEGACY
+#	select CPU_CACHE_VIVT
+#	select CPU_CP15_MMU
+#	select CPU_CACHE_FA
+#	select CPU_COPY_FA if MMU
+#	select CPU_TLB_FA if MMU
+#	help
+#	  The FA526 is a version of the ARMv4 compatible processor with
+#	  Branch Target Buffer, Unified TLB and cache line size 16.
+#
+#	  Say Y if you want support for the FA526 processor.
+#	  Otherwise, say N.
 
 # ARM940T
 config CPU_ARM940T
@@ -566,6 +614,7 @@
 	  and invalidate instruction cache entry. Branch target buffer is
 	  also supported.
 
+      
 config CPU_TLB_V6
 	bool
 
@@ -664,14 +713,16 @@
 
 config CPU_ICACHE_DISABLE
 	bool "Disable I-Cache (I-bit)"
-	depends on CPU_CP15 && !(CPU_ARM610 || CPU_ARM710 || CPU_ARM720T || CPU_ARM740T || CPU_XSCALE || CPU_XSC3)
+#	depends on CPU_CP15 && !(CPU_ARM610 || CPU_ARM710 || CPU_ARM720T || CPU_ARM740T || CPU_XSCALE || CPU_XSC3 || CPU_FA520 || CPU_FA526 || CPU_FA626)
+   depends on CPU_CP15
 	help
 	  Say Y here to disable the processor instruction cache. Unless
 	  you have a reason not to or are unsure, say N.
 
 config CPU_DCACHE_DISABLE
 	bool "Disable D-Cache (C-bit)"
-	depends on CPU_CP15
+#	depends on CPU_CP15 && !(CPU_FA520 || CPU_FA526 || CPU_FA626)
+ 	depends on CPU_CP15  
 	help
 	  Say Y here to disable the processor data cache. Unless
 	  you have a reason not to or are unsure, say N.
@@ -697,6 +748,19 @@
 	  Say Y here to use the data cache in writethrough mode. Unless you
 	  specifically require this or are unsure, say N.
 
+config CPU_FA_BTB
+ 	bool "BTB support (EXPERIMENTAL)"
+ 	depends on CPU_FA520 || CPU_FA526 || CPU_FA626
+ 	default y
+ 	help
+ 	//TODO: FA BTB
+
+config CPU_FA_WB_DISABLE
+ 	bool "Disable write buffer (EXPERIMENTAL)"
+ 	depends on CPU_FA520 || CPU_FA526 || CPU_FA626
+ 	help
+ 	//TODO: FA write buffer     
+     
 config CPU_CACHE_ROUND_ROBIN
 	bool "Round robin I and D cache replacement algorithm"
 	depends on (CPU_ARM926T || CPU_ARM946E || CPU_ARM1020) && (!CPU_ICACHE_DISABLE || !CPU_DCACHE_DISABLE)
diff -Nur linux-2.6.35.11/arch/arm/mm/proc-fa526.S linux-2.6.35.11-ts7500//arch/arm/mm/proc-fa526.S
--- linux-2.6.35.11/arch/arm/mm/proc-fa526.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/proc-fa526.S	2011-02-26 20:32:46.000000000 -0500
@@ -1,3 +1,4 @@
+#if (1)
 /*
  *  linux/arch/arm/mm/proc-fa526.S: MMU functions for FA526
  *
@@ -138,6 +139,7 @@
 #endif
 	mov	pc, lr
 
+   
 	__INIT
 
 	.type	__fa526_setup, #function
@@ -246,3 +248,428 @@
 	.long	fa_user_fns
 	.long	fa_cache_fns
 	.size	__fa526_proc_info, . - __fa526_proc_info
+   
+#else
+/*
+ *  linux/arch/arm/mm/proc-fa526.S: MMU functions for FA526
+ *
+ *  Copyright (C) 2005 Faraday Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache and TLB
+ * functions on the fa526.
+ *
+ *  Written by : Luke Lee
+ */
+#include <linux/linkage.h>
+//#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/pgtable.h>
+/* scott.test
+#include <asm/procinfo.h>
+*/
+#include <mach/hardware.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+#include "proc-macros.S"
+
+#define CACHE_DLINESIZE	   16
+
+	.text
+/*
+ * cpu_fa526_proc_init()
+ */
+ENTRY(cpu_fa526_proc_init)
+	/* MMU is already ON here, ICACHE, DCACHE conditionally disabled */
+
+        mov     r0, #1
+	nop
+	nop
+        mcr     p15, 0, r0, c1, c1, 0		@ turn-on ECR
+	nop
+	nop
+
+	mrc	p15, 0, r0, c1, c0, 0		@ read ctrl register
+
+#ifdef CONFIG_CPU_FA_BTB
+	orr	r0, r0, #CR_Z
+#else
+	bic	r0, r0, #CR_Z	
+#endif
+#ifdef CONFIG_CPU_FA_WB_DISABLE
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c10, 4		@ drain write buffer
+	nop
+	nop
+	bic	r0, r0, #CR_W
+#else
+	orr	r0, r0, #CR_W
+#endif
+#ifdef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CR_C
+#else
+	orr	r0, r0, #CR_C	
+#endif
+#ifdef CONFIG_CPU_ICACHE_DISABLE
+	bic	r0, r0, #CR_I
+#else
+	orr	r0, r0, #CR_I	
+#endif
+	
+	nop
+	nop
+    	mcr	p15, 0, r0, c1, c0, 0
+	nop
+	nop
+
+	mov	r5, lr
+	bl	fa_initialize_cache_info	@ destroy r0~r4	
+	mov	pc, r5				@ return
+
+
+/*
+ * cpu_fa526_proc_fin()
+ */
+ENTRY(cpu_fa526_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+
+	bl	fa_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+
+	nop
+	nop
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_fa526_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	4
+ENTRY(cpu_fa526_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+#ifndef CONFIG_CPU_FA_WB_DISABLE	
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#endif	
+	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+
+	bic	ip, ip, #0x0800			@ BTB off
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	nop
+	nop
+	mov	pc, r0
+
+/*
+ * cpu_fa526_do_idle()
+ */
+	.align	4
+ENTRY(cpu_fa526_do_idle)
+
+#ifdef CONFIG_CPU_FA_IDLE
+	nop
+	nop
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt (IDLE mode)
+#endif
+	mov	pc, lr
+
+
+ENTRY(cpu_fa526_dcache_clean_area)
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+#endif	
+	mov	pc, lr
+	
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_fa526_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	4
+
+	.globl	fault_address
+fault_address:	
+	.long	0
+	
+ENTRY(cpu_fa526_switch_mm)
+
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE	
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+	mcr	p15, 0, ip, c7, c14, 0		@ Clean and invalidate whole DCache
+#endif
+#endif /*CONFIG_CPU_DCACHE_DISABLE*/
+	
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif	
+
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#endif	
+
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, ip, c7, c5, 6		@ invalidate BTB since mm changed
+	nop
+	nop
+#endif
+	bic	r0, r0, #0xff			@ clear bits [7:0]
+	bic	r0, r0, #0x3f00			@ clear bits [13:8]
+	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
+	mcr	p15, 0, ip, c8, c7, 0		@ invalidate UTLB
+	nop
+	nop
+	mov	pc, lr
+
+/*
+ * cpu_fa526_set_pte_ext(ptep, pte, ext)
+ *
+ * Set a PTE and flush it out
+ */
+	.align	4
+ENTRY(cpu_fa526_set_pte_ext)
+	str	r1, [r0], #-2048		@ linux version
+	
+	eor	r1, r1, #L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_WRITE | L_PTE_DIRTY
+
+	bic	r2, r1, #PTE_SMALL_AP_MASK
+	bic	r2, r2, #PTE_TYPE_MASK
+	orr	r2, r2, #PTE_TYPE_SMALL
+
+	tst	r1, #L_PTE_USER			@ User?
+	orrne	r2, r2, #PTE_SMALL_AP_URO_SRW
+
+	tst	r1, #L_PTE_WRITE | L_PTE_DIRTY	@ Write and Dirty?
+	orreq	r2, r2, #PTE_SMALL_AP_UNO_SRW
+
+	tst	r1, #L_PTE_PRESENT | L_PTE_YOUNG	@ Present and Young?
+	movne	r2, #0
+
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	eor	r3, r2, #0x0a			@ C & small page?  1010
+	tst	r3, #0x0b			@		   1011
+	biceq	r2, r2, #4
+#endif
+	str	r2, [r0]			@ hardware version
+
+	mov	r2, #0
+	mcr	p15, 0, r2, c7, c10, 0		@ clean D cache	all
+	
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mcr	p15, 0, r2, c7, c10, 4		@ drain WB
+#endif
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, r2, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif
+	mov	pc, lr
+	
+   
+#ifdef CONFIG_DEBUG_LL
+str_fa526_setup: .asciz "str_fa526_setup\n"   
+str_fa526_setup_done: .asciz "str_fa526_setup_done\n"
+.align 4
+#endif   
+	__INIT
+
+	.type	__fa526_setup, #function
+__fa526_setup:
+#ifdef CONFIG_DEBUG_LL
+   adr	r0, str_fa526_setup
+	bl	printascii
+#endif
+	/* On return of this routine, r0 must carry correct flags for CFG register */	
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+
+	mcr	p15, 0, r0, c7, c5, 5		@ invalidate IScratchpad RAM
+
+        mov     r0, #1
+        mcr     p15, 0, r0, c1, c1, 0		@ turn-on ECR
+
+	mrc	p15, 0, r0, c9, c1, 0		@ DScratchpad
+	bic	r0, r0, #1
+	mcr	p15, 0, r0, c9, c1, 0
+	mrc	p15, 0, r0, c9, c1, 1		@ IScratchpad
+	bic	r0, r0, #1
+	mcr	p15, 0, r0, c9, c1, 1
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c1, c1, 0		@ turn-off ECR
+	
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, r0, c7, c5, 6		@ invalidate BTB All
+	nop
+	nop
+#endif		
+		
+	mov	r0, #0x1f			@ Domains 0, 1 = manager, 2 = client
+	mcr	p15, 0, r0, c3, c0		@ load domain access register
+	
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+	ldr	r5, fa526_cr1_clear
+	bic	r0, r0, r5
+	ldr	r5, fa526_cr1_set
+	orr	r0, r0, r5
+
+#ifdef CONFIG_CPU_FA_BTB
+	orr	r0, r0, #CR_Z
+#else
+	bic	r0, r0, #CR_Z	
+#endif
+#ifdef CONFIG_CPU_FA_WB_DISABLE
+	mov	r12, #0
+	mcr	p15, 0, r12, c7, c10, 4		@ drain write buffer
+	nop
+	nop
+	bic	r0, r0, #CR_W			@ .... .... .... 1...
+#else
+	orr	r0, r0, #CR_W
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+   adr	r0, str_fa526_setup_done
+	bl	printascii
+#endif
+
+	mov	pc, lr
+	.size	__fa526_setup, . - __fa526_setup
+
+	/*
+	 * .RVI ZFRS BLDP WCAM
+	 * ..11 0001 .111 1101
+	 * 
+	 */
+	.type	fa526_cr1_clear, #object
+	.type	fa526_cr1_set, #object
+fa526_cr1_clear:
+	.word	0x3f3f
+fa526_cr1_set:
+	.word	0x317D
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	fa526_processor_functions, #object
+fa526_processor_functions:
+	.word	v4_early_abort
+	.word	legacy_pabort            @ Ian added	
+	.word	cpu_fa526_proc_init
+	.word	cpu_fa526_proc_fin
+	.word	cpu_fa526_reset
+	.word   cpu_fa526_do_idle
+	.word	cpu_fa526_dcache_clean_area
+	.word	cpu_fa526_switch_mm
+	.word	cpu_fa526_set_pte_ext
+	.size	fa526_processor_functions, . - fa526_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_fa526_name, #object
+cpu_fa526_name:
+	.ascii	"FA526"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+	.ascii	"\0"
+	.size	cpu_fa526_name, . - cpu_fa526_name
+
+	.align
+
+	.section ".proc.info.init", #alloc, #execinstr
+
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+#define __PMD_SECT_BUFFERABLE	0
+#else
+#define __PMD_SECT_BUFFERABLE	PMD_SECT_BUFFERABLE
+#endif
+
+	.type	__fa526_proc_info,#object
+__fa526_proc_info:
+	.long	0x66015261
+	.long	0xff01fff1
+	.long   PMD_TYPE_SECT | \
+		__PMD_SECT_BUFFERABLE | \
+		PMD_SECT_CACHEABLE | \
+		PMD_BIT4 | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	.long   PMD_TYPE_SECT | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	b	__fa526_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF
+	.long	cpu_fa526_name
+	.long	fa526_processor_functions
+	.long	fa_tlb_fns
+	.long	fa_user_fns
+	.long	fa_cache_fns
+	.size	__fa526_proc_info, . - __fa526_proc_info
+#endif
diff -Nur linux-2.6.35.11/arch/arm/mm/tlb-fa.S linux-2.6.35.11-ts7500//arch/arm/mm/tlb-fa.S
--- linux-2.6.35.11/arch/arm/mm/tlb-fa.S	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/mm/tlb-fa.S	2011-02-26 20:32:46.000000000 -0500
@@ -1,3 +1,4 @@
+#if (0)
 /*
  *  linux/arch/arm/mm/tlb-fa.S
  *
@@ -73,3 +74,103 @@
 	.long	fa_flush_kern_tlb_range
 	.long	fa_tlb_flags
 	.size	fa_tlb_fns, . - fa_tlb_fns
+#else
+/*
+ *  linux/arch/arm/mm/tlb-fa.S
+ *
+ *  Copyright (C) 2005 Faraday Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  ARM architecture version 4, Faraday variation. 
+ *  This assume an unified TLBs, with a write buffer, and branch target buffer (BTB)
+ *
+ *  Processors: FA520 FA526 FA626
+ *  03/31/2005 : Created by Luke Lee, modified from tlb-v4wbi.S
+ *  05/06/2005 : Fixed buggy CPU versions that did not invalidate the associated
+ *               data cache entries when invalidating TLB entries.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/asm-offsets.h>
+//#include <asm/constants.h>
+#include <asm/tlbflush.h>
+#include "proc-macros.S"
+
+
+/*
+ *	flush_user_tlb_range(start, end, mm)
+ *
+ *	Invalidate a range of TLB entries in the specified address space.
+ *
+ *	- start - range start address
+ *	- end   - range end address
+ *	- mm    - mm_struct describing address space
+ */
+	.align	4
+ENTRY(fa_flush_user_tlb_range)
+	
+	vma_vm_mm ip, r2
+	act_mm	r3				@ get current->active_mm
+	eors	r3, ip, r3			@ == mm ?
+	movne	pc, lr				@ no, we dont do anything
+	mov	r3, #0
+
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mcr	p15, 0, r3, c7, c10, 4		@ drain WB
+#endif
+
+	vma_vm_flags r2, r2
+	bic	r0, r0, #0x0ff
+	bic	r0, r0, #0xf00
+
+1:	mcr	p15, 0, r0, c8, c7, 1		@ invalidate UTLB entry
+	add	r0, r0, #PAGE_SZ
+	cmp	r0, r1
+	bls	1b				@ Luke Lee 05/19/2005 blo -> bls
+
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, r3, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif	
+	mov	pc, lr
+
+
+ENTRY(fa_flush_kern_tlb_range)
+	mov	r3, #0
+
+	mcr	p15, 0, r3, c7, c10, 0		@ clean Dcache all 06/03/2005
+		
+#ifndef CONFIG_CPU_FA_WB_DISABLE
+	mcr	p15, 0, r3, c7, c10, 4		@ drain WB
+#endif
+
+	bic	r0, r0, #0x0ff
+	bic	r0, r0, #0xf00
+1:
+	mcr	p15, 0, r0, c8, c7, 1		@ invalidate UTLB entry
+	add	r0, r0, #PAGE_SZ
+	cmp	r0, r1
+	bls	1b				@ Luke Lee 05/19/2005 blo -> bls
+
+#ifdef CONFIG_CPU_FA_BTB
+	mcr	p15, 0, r3, c7, c5, 6		@ invalidate BTB
+	nop
+	nop
+#endif
+	mov	pc, lr
+
+
+	__INITDATA
+
+	.type	fa_tlb_fns, #object
+ENTRY(fa_tlb_fns)
+	.long	fa_flush_user_tlb_range
+	.long	fa_flush_kern_tlb_range
+	.long	fa_tlb_flags
+	.size	fa_tlb_fns, . - fa_tlb_fns
+
+#endif
diff -Nur linux-2.6.35.11/arch/arm/tools/mach-types linux-2.6.35.11-ts7500//arch/arm/tools/mach-types
--- linux-2.6.35.11/arch/arm/tools/mach-types	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//arch/arm/tools/mach-types	2011-02-26 20:32:46.000000000 -0500
@@ -2950,3 +2950,6 @@
 netviz			MACH_NETVIZ		NETVIZ			2964
 flexibity		MACH_FLEXIBITY		FLEXIBITY		2965
 wlan_computer		MACH_WLAN_COMPUTER	WLAN_COMPUTER		2966
+str8100                 ARCH_STR8100            STR8100                 2001
+                                                                                
+
diff -Nur linux-2.6.35.11/drivers/base/core.c linux-2.6.35.11-ts7500//drivers/base/core.c
--- linux-2.6.35.11/drivers/base/core.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/base/core.c	2011-02-26 20:32:46.000000000 -0500
@@ -1323,6 +1323,8 @@
 
 int __init devices_init(void)
 {
+   //printk("devices_init(), calling kset_create_and_add(devices)\n");
+   
 	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
 	if (!devices_kset)
 		return -ENOMEM;
@@ -1336,6 +1338,7 @@
 	if (!sysfs_dev_char_kobj)
 		goto char_kobj_err;
 
+//printk("devices_init() done OK\n");
 	return 0;
 
  char_kobj_err:
diff -Nur linux-2.6.35.11/drivers/base/init.c linux-2.6.35.11-ts7500//drivers/base/init.c
--- linux-2.6.35.11/drivers/base/init.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/base/init.c	2011-02-26 20:32:46.000000000 -0500
@@ -20,18 +20,28 @@
 void __init driver_init(void)
 {
 	/* These are the core pieces */
+   //printk("calling devtmpfs_init()\n");
 	devtmpfs_init();
+   //printk("calling devices_init()\n");
 	devices_init();
+   //printk("calling buses_init()\n");
 	buses_init();
+   //printk("calling classes_init()\n");
 	classes_init();
+   //printk("calling firmware_init()\n");
 	firmware_init();
+   //printk("calling hypervisor_init()\n");
 	hypervisor_init();
-
+   
 	/* These are also core pieces, but must come after the
 	 * core core pieces.
 	 */
+   // printk("calling platform_bus_init()\n");
 	platform_bus_init();
+   //printk("calling system_bus_init()\n");
 	system_bus_init();
+   //printk("calling cpu_dev_init()\n");
 	cpu_dev_init();
+   //printk("calling memory_dev_init()\n");
 	memory_dev_init();
 }
diff -Nur linux-2.6.35.11/drivers/base/platform.c linux-2.6.35.11-ts7500//drivers/base/platform.c
--- linux-2.6.35.11/drivers/base/platform.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/base/platform.c	2011-02-26 20:32:46.000000000 -0500
@@ -1021,11 +1021,17 @@
 {
 	int error;
 
+   //printk("platform_bus_init() calling early_platform_cleanup()\n");
+   
 	early_platform_cleanup();
 
+   //printk("platform_bus_init() calling device_register()\n");
+   
 	error = device_register(&platform_bus);
 	if (error)
 		return error;
+   //printk("platform_bus_init() calling bus_register()\n");
+   
 	error =  bus_register(&platform_bus_type);
 	if (error)
 		device_unregister(&platform_bus);
diff -Nur linux-2.6.35.11/drivers/base/sys.c linux-2.6.35.11-ts7500//drivers/base/sys.c
--- linux-2.6.35.11/drivers/base/sys.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/base/sys.c	2011-02-26 20:32:46.000000000 -0500
@@ -500,6 +500,7 @@
 
 int __init system_bus_init(void)
 {
+   //printk("system_bus_init(), calling kset_create_and_add(system)\n");
 	system_kset = kset_create_and_add("system", NULL, &devices_kset->kobj);
 	if (!system_kset)
 		return -ENOMEM;
diff -Nur linux-2.6.35.11/drivers/char/mem.c linux-2.6.35.11-ts7500//drivers/char/mem.c
--- linux-2.6.35.11/drivers/char/mem.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/char/mem.c	2011-02-26 20:32:46.000000000 -0500
@@ -898,6 +898,8 @@
 	int minor;
 	int err;
 
+   //printk("chr_dev_init(), calling bdi_init()\n");
+   
 	err = bdi_init(&zero_bdi);
 	if (err)
 		return err;
diff -Nur linux-2.6.35.11/drivers/i2c/busses/i2c-str8100.c linux-2.6.35.11-ts7500//drivers/i2c/busses/i2c-str8100.c
--- linux-2.6.35.11/drivers/i2c/busses/i2c-str8100.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/i2c/busses/i2c-str8100.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,929 @@
+ /*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <linux/sysctl.h>
+
+#include <mach/star_intc.h>
+#include <mach/star_i2c.h>
+#include <mach/star_misc.h>
+#include <mach/star_powermgt.h>
+
+#include "i2c-str8100.h"
+
+#define STR8100_I2C_DATE          "20060613"
+#define STR8100_I2C_VERSION       "1.0.0"
+
+#define I2C_K                     1000
+#define I2C_M                     1000000
+
+//extern u32 PLL_clock;
+//extern u32 CPU_clock;
+//extern u32 AHB_clock;
+extern u32 APB_clock;
+#define I2C_PCLK                  APB_clock
+/*#if 1 // for ASIC
+#define I2C_PCLK                  200000000
+#else // for FPGA
+#define I2C_PCLK                  13000000
+#endif
+*/
+#define TWI_TIMEOUT	          2*(HZ)
+
+#define I2C_100KHZ	  100000
+#define I2C_200KHZ	  200000
+#define I2C_300KHZ	  300000
+#define I2C_400KHZ	  400000
+
+static i2c_transfer_t i2c_cmd_transfer;
+
+unsigned int debug=0;
+module_param(debug, uint, 0);
+MODULE_PARM_DESC(debug, "STR8100 I2C debug option (0:off 1:on, default=0)");
+
+static unsigned int current_clock;
+unsigned int clock=400000;
+module_param(clock, uint, 0);
+MODULE_PARM_DESC(clock, "STR8100 I2C clock in Hz (default=400000)");
+
+static wait_queue_head_t waitqueue;	/* wait queue for read/write to complete */
+
+extern void str8100_set_interrupt_trigger (unsigned int, unsigned int, unsigned int, unsigned int);
+#define u_int32 unsigned int
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_I2c_Is_Bus_Idle
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 Hal_I2c_Is_Bus_Idle(void)
+{
+    /*
+     * Return value :
+     *    1 : Bus Idle
+     *    0 : Bus Busy
+     */    
+    return ((I2C_CONTROLLER_REG & (0x1 << 6)) ? 0 : 1);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_I2c_Is_Action_Done
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 Hal_I2c_Is_Action_Done(void)
+{
+    /*
+     * Return value :
+     *    1 : Action Done
+     *    0 : Action is NOT Done
+     */    
+    return ((I2C_INTERRUPT_STATUS_REG & I2C_ACTION_DONE_FLAG) ? 1 : 0);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:  Hal_I2c_Dispatch_Transfer
+ * PURPOSE:
+ *
+ ******************************************************************************/
+void Hal_I2c_Dispatch_Transfer(i2c_transfer_t *i2c_transfer)
+{
+    u_int32 volatile    i2c_control;
+    u_int32 volatile    i2c_control_reg;
+
+
+    /*
+     * Wait unti I2C Bus is idle and the previous action is done
+     */
+//    while (!Hal_I2c_Is_Bus_Idle() && !Hal_I2c_Is_Action_Done());
+    int retries = 2000;    
+   
+    while (!Hal_I2c_Is_Bus_Idle() && !Hal_I2c_Is_Action_Done() && retries--);	
+         udelay(1000); 
+
+    if (retries == 0) {
+      printk ("%s: Bus idle fail!!\n",__FUNCTION__);  
+      return;
+    }
+
+
+    // Configure transfer command, write data length, and read data length
+    i2c_control = ((i2c_transfer->transfer_cmd & 0x3) << 4) |
+                  ((i2c_transfer->write_data_len & 0x3) << 2) |
+                  ((i2c_transfer->read_data_len & 0x3) << 0);
+    
+    // Note we enable I2C again!!
+    i2c_control_reg = I2C_CONTROLLER_REG;
+    
+    i2c_control_reg &= ~(0x3F);
+    i2c_control_reg |= (i2c_control & 0x3F) | ((u_int32)0x1 << 31);
+
+    I2C_CONTROLLER_REG = i2c_control_reg;
+
+    // Write output data
+    I2C_WRITE_DATA_REG = i2c_transfer->write_data;
+
+    // Configure slave address
+    I2C_SLAVE_ADDRESS_REG = i2c_transfer->slave_addr & 0xFE;
+
+    // Start IC transfer
+    HAL_I2C_START_TRANSFER();
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2c_Read_Only_Command
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 I2c_Read_Only_Command(u_int32 slave_addr, u_int32 read_data_len, 
+                              u_int32 *read_data)
+{
+    long timeout;
+
+
+    // Clear previous I2C interrupt status
+    IO_OUT_WORD(I2C_INTERRUPT_STATUS_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+    // Enable I2C interrupt sources
+    IO_OUT_WORD(I2C_INTERRUPT_ENABLE_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+
+    /*
+     * Configure this I2C command tranfer settings
+     */
+    i2c_cmd_transfer.transfer_cmd = I2C_READ_ONLY_CMD;
+    
+    i2c_cmd_transfer.write_data_len = 0;
+    
+    i2c_cmd_transfer.read_data_len = read_data_len & 0x3;
+
+    i2c_cmd_transfer.slave_addr = slave_addr & 0xFF;
+
+    i2c_cmd_transfer.write_data = 0;
+
+    i2c_cmd_transfer.error_status = 0;
+
+    i2c_cmd_transfer.action_done = 0;
+
+
+    /*
+     * Issue this command
+     */
+    Hal_I2c_Dispatch_Transfer(&i2c_cmd_transfer);
+
+
+    // Check if this I2C bus action is done or not
+/*    while (1)
+    {
+        Sys_Interrupt_Disable_Save_Flags(&cpsr_flags);
+   
+        if ((i2c_cmd_transfer.action_done) || (i2c_cmd_transfer.error_status))
+        {
+            break;
+        }
+
+        Sys_Interrupt_Restore_Flags(cpsr_flags);
+    }
+
+    Sys_Interrupt_Restore_Flags(cpsr_flags);
+*/
+    timeout = interruptible_sleep_on_timeout(&waitqueue, TWI_TIMEOUT);
+    if (timeout == 0) return 0x99; 
+
+    // I2C Bus error!!
+    if (i2c_cmd_transfer.error_status && (i2c_cmd_transfer.error_status != 0xFF))
+    {
+        return (i2c_cmd_transfer.error_status);
+    }
+
+    // Get the read data byte
+    i2c_cmd_transfer.read_data = IO_IN_WORD(I2C_READ_DATA_REG_ADDR);
+    
+    switch (read_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFF;//8
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFF;//16
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFFFF;//24
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+        default :
+        
+            break;
+    }
+
+
+    // Set the data for return
+    *read_data = i2c_cmd_transfer.read_data;
+
+    return (0);
+}
+
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2c_Write_Only_Command
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 I2c_Write_Only_Command(u_int32 slave_addr, u_int32 write_data_len,
+                               u_int32 write_data)
+{
+    long timeout;
+
+
+    // Clear previous I2C interrupt status
+    IO_OUT_WORD(I2C_INTERRUPT_STATUS_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+    // Enable I2C interrupt sources
+    IO_OUT_WORD(I2C_INTERRUPT_ENABLE_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+
+    /*
+     * Configure this I2C command tranfer settings
+     */
+    i2c_cmd_transfer.transfer_cmd = I2C_WRITE_ONLY_CMD;
+    
+    i2c_cmd_transfer.write_data_len = write_data_len & 0x3;
+    
+    i2c_cmd_transfer.read_data_len = 0;
+
+    i2c_cmd_transfer.slave_addr = slave_addr & 0xFF;
+
+    switch (write_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFF;
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+            i2c_cmd_transfer.write_data = write_data;
+
+        default :
+
+            i2c_cmd_transfer.write_data = write_data;
+            
+            break;
+    }
+
+    i2c_cmd_transfer.error_status = 0;
+
+    i2c_cmd_transfer.action_done = 0;
+
+
+    /*
+     * Issue this command
+     */
+    Hal_I2c_Dispatch_Transfer(&i2c_cmd_transfer);
+
+
+    // Check if this I2C bus action is done or not
+/*    while (1)
+    {
+        Sys_Interrupt_Disable_Save_Flags(&cpsr_flags);
+   
+        if ((i2c_cmd_transfer.action_done) || (i2c_cmd_transfer.error_status))
+        {
+            break;
+        }
+
+        Sys_Interrupt_Restore_Flags(cpsr_flags);
+    }
+
+    Sys_Interrupt_Restore_Flags(cpsr_flags);
+*/
+    timeout = interruptible_sleep_on_timeout(&waitqueue, TWI_TIMEOUT);
+    if (timeout == 0) return 0x99; 
+
+    // I2C Bus error!!
+    if (i2c_cmd_transfer.error_status && (i2c_cmd_transfer.error_status != 0xFF))
+    {
+        return (i2c_cmd_transfer.error_status);
+    }
+    else
+    {
+        return (0);
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2c_Write_Read_Command
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 I2c_Write_Read_Command(u_int32 slave_addr, 
+                               u_int32 write_data_len, u_int32 write_data,
+                               u_int32 read_data_len, u_int32 *read_data)
+{
+    long timeout;
+
+
+    // Clear previous I2C interrupt status
+    IO_OUT_WORD(I2C_INTERRUPT_STATUS_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+    // Enable I2C interrupt sources
+    IO_OUT_WORD(I2C_INTERRUPT_ENABLE_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+
+    /*
+     * Configure this I2C command tranfer settings
+     */
+    i2c_cmd_transfer.transfer_cmd = I2C_WRITE_READ_CMD;
+    
+    i2c_cmd_transfer.write_data_len = write_data_len & 0x3;
+    
+    i2c_cmd_transfer.read_data_len = read_data_len & 0x3;
+
+    i2c_cmd_transfer.slave_addr = slave_addr & 0xFF;
+
+    switch (write_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFF;
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+            i2c_cmd_transfer.write_data = write_data;
+
+        default :
+
+            i2c_cmd_transfer.write_data = write_data;
+            
+            break;
+    }
+
+    i2c_cmd_transfer.error_status = 0;
+
+    i2c_cmd_transfer.action_done = 0;
+
+
+    /*
+     * Issue this command
+     */
+    Hal_I2c_Dispatch_Transfer(&i2c_cmd_transfer);
+
+
+    // Check if this I2C bus action is done or not
+/*    while (1)
+    {
+        Sys_Interrupt_Disable_Save_Flags(&cpsr_flags);
+   
+        if ((i2c_cmd_transfer.action_done) || (i2c_cmd_transfer.error_status))
+        {
+            break;
+        }
+
+        Sys_Interrupt_Restore_Flags(cpsr_flags);
+    }
+
+    Sys_Interrupt_Restore_Flags(cpsr_flags);
+*/
+    timeout = interruptible_sleep_on_timeout(&waitqueue, TWI_TIMEOUT);
+    if (timeout == 0) return 0x99; 
+
+    // I2C Bus error!!
+    if (i2c_cmd_transfer.error_status && (i2c_cmd_transfer.error_status != 0xFF))
+    {
+        return (i2c_cmd_transfer.error_status);
+    }
+
+    // Get the read data byte
+    i2c_cmd_transfer.read_data = IO_IN_WORD(I2C_READ_DATA_REG_ADDR);
+    
+    switch (read_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFF;
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+        default :
+            break;
+    }
+
+
+    // Set the data for return
+    *read_data = i2c_cmd_transfer.read_data;
+
+    return (0);
+}
+
+
+
+/******************************************************************************
+ *
+ * FUNCTION:  I2c_Read_Write_Command
+ * PURPOSE:
+ *
+ ******************************************************************************/
+u_int32 I2c_Read_Write_Command(u_int32 slave_addr, 
+                               u_int32 read_data_len, u_int32 *read_data,
+                               u_int32 write_data_len, u_int32 write_data)
+{
+    long timeout;
+
+
+    // Clear previous I2C interrupt status
+    IO_OUT_WORD(I2C_INTERRUPT_STATUS_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+    // Enable I2C interrupt sources
+    IO_OUT_WORD(I2C_INTERRUPT_ENABLE_REG_ADDR, I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG);
+
+
+    /*
+     * Configure this I2C command tranfer settings
+     */
+    i2c_cmd_transfer.transfer_cmd = I2C_READ_WRITE_CMD;
+    
+    i2c_cmd_transfer.write_data_len = write_data_len & 0x3;
+    
+    i2c_cmd_transfer.read_data_len = read_data_len & 0x3;
+
+    i2c_cmd_transfer.slave_addr = slave_addr & 0xFF;
+
+    switch (write_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFF;
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.write_data = write_data & 0xFFFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+            i2c_cmd_transfer.write_data = write_data;
+
+        default :
+        
+            i2c_cmd_transfer.write_data = write_data;
+            
+            break;
+    }
+
+    i2c_cmd_transfer.error_status = 0;
+
+    i2c_cmd_transfer.action_done = 0;
+
+
+    /*
+     * Issue this command
+     */
+    Hal_I2c_Dispatch_Transfer(&i2c_cmd_transfer);
+
+
+    // Check if this I2C bus action is done or not
+/*    while (1)
+    {
+        Sys_Interrupt_Disable_Save_Flags(&cpsr_flags);
+   
+        if ((i2c_cmd_transfer.action_done) || (i2c_cmd_transfer.error_status))
+        {
+            break;
+        }
+
+        Sys_Interrupt_Restore_Flags(cpsr_flags);
+    }
+
+    Sys_Interrupt_Restore_Flags(cpsr_flags);
+*/
+    timeout = interruptible_sleep_on_timeout(&waitqueue, TWI_TIMEOUT);
+    if (timeout == 0) return 0x99; 
+
+
+    // I2C Bus error!!
+    if (i2c_cmd_transfer.error_status && (i2c_cmd_transfer.error_status != 0xFF))
+    {
+        return (i2c_cmd_transfer.error_status);
+    }
+
+    // Get the read data byte
+    i2c_cmd_transfer.read_data = IO_IN_WORD(I2C_READ_DATA_REG_ADDR);
+    
+    switch (read_data_len & 0x3)
+    {
+        case I2C_DATA_LEN_1_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFF;
+            
+            break;
+
+        case I2C_DATA_LEN_2_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_3_BYTE :
+        
+            i2c_cmd_transfer.read_data &= 0xFFFFFF;
+            
+            break;
+
+        case I2C_DATA_LEN_4_BYTE :
+
+        default :
+
+            break;
+    }
+
+    // Set the data for return
+    *read_data = i2c_cmd_transfer.read_data;
+
+    return (0);
+}
+//====================================================================================
+// Eileen , for linux kernel 2.6.24 , 20080416
+// old :static void str8100_i2c_init()
+static void str8100_i2c_init(void)
+{ 
+//	unsigned long clock = 100 * (priv->twi_cwgr + 1) * I2C_K; 
+
+	current_clock=clock;
+//	if(debug)
+		printk("%s: current_clock=%ul, CLKDIV=%d\n",__FUNCTION__,current_clock,(I2C_PCLK / (2 * current_clock) - 1));
+	
+	HAL_MISC_ENABLE_I2C_PINS();
+		
+	HAL_PWRMGT_ENABLE_I2C_CLOCK();
+		
+#if 0
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);   
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);   
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX);
+#endif
+//	I2C_CONTROLLER_REG = (0 << 6) | (0 << 24) | (0 << 31);
+	I2C_CONTROLLER_REG = 0 ;
+//	I2C_TIME_OUT_REG = (((I2C_PCLK / (2 * clock) - 1)<<8)|(1 << 7)|0x40);
+	I2C_TIME_OUT_REG = (((I2C_PCLK / (2 * current_clock) - 1)<<8)|(1 << 7)|0x10);
+	I2C_INTERRUPT_ENABLE_REG = 0;
+	I2C_INTERRUPT_STATUS_REG = I2C_BUS_ERROR_FLAG | I2C_ACTION_DONE_FLAG;
+	HAL_I2C_ENABLE_I2C();
+		
+}
+/*
+typedef union __data_t{
+	struct{
+		unsigned char byte[4];
+	} byte;
+	unsigned int u32;
+} data;
+
+unsigned int i2c_read_len(unsigned int addr, unsigned char *buf, unsigned int len){
+	data	data;
+	if((ret=I2c_Read_Only_Command(addr,&data.u32,len)))
+		return ret;
+		
+	switch(rem_len){
+	case 1:
+		*tmp_buf=byte[0];tmp_buf++;
+		break;
+	case 2:
+		*tmp_buf=byte[1];tmp_buf++;
+		*tmp_buf=byte[0];tmp_buf++;
+		break;
+	case 3:
+		*tmp_buf=byte[2];tmp_buf++;
+		*tmp_buf=byte[1];tmp_buf++;
+		*tmp_buf=byte[0];tmp_buf++;
+		break;
+	case 4:
+		*tmp_buf=byte[3];tmp_buf++;
+		*tmp_buf=byte[2];tmp_buf++;
+		*tmp_buf=byte[1];tmp_buf++;
+		*tmp_buf=byte[0];tmp_buf++;
+		break;
+	default:
+		return 99;
+	}
+	return 0;
+}
+*/
+static int
+i2c_read(unsigned int addr, unsigned char *buf, unsigned int len)
+{
+	unsigned int i;
+	unsigned int data;
+	int ret;
+
+	if (len == 0) return 0;
+
+	for(i=0;i<len;i++){
+//	if(I2c_Write_Read_Command((addr<<1),0,0,3,&data)){
+//	if(I2c_Eeprom_AT24C16A_Read_Byte(0x0a,7,0,&data)){
+		if((ret=I2c_Read_Only_Command((addr<<1),0,&data))){
+			if(debug)
+				printk("Error %s: ret=0x%x\n",__FUNCTION__,ret);
+			return -EIO;
+		}
+		buf[i] = data;
+	}
+
+	return 0;
+}
+
+static int
+i2c_write(unsigned int addr, unsigned char *buf, unsigned int len)
+{
+	unsigned int i,data=0;
+	int ret;
+	if (len == 0) return 0;
+
+	if (len >4) return -EIO;
+	
+	for(i=0;i<len;i++) data=data|(buf[i]<<(i<<3));
+
+		if((ret=I2c_Write_Only_Command((addr<<1),len-1,data))){
+			if(debug)
+				printk("Error %s: ret=0x%x\n",__FUNCTION__,ret);
+			return -EIO;
+		}
+
+	return 0;
+}
+
+static int str8100_xfer(struct i2c_adapter *adapter, struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *p;
+	int i, err = 0;
+
+	// Eileen , for linux kernel 2.6.24 , 20080416
+	// old : if(clock!=current_clock) str8100_i2c_init(adapter);
+	if(clock!=current_clock) str8100_i2c_init(); 
+	
+	if(debug)
+		printk("\n%s: num=%d\n",__FUNCTION__,num);
+	for (i = 0; !err && i < num; i++) {
+		if(debug)
+			printk("%s: %s msgs[%d] addr=%x len=%d\n",__FUNCTION__,(msgs[i].flags & I2C_M_RD)?"read":"write",i,msgs[i].addr,msgs[i].len);
+		p = &msgs[i];
+		if (!p->len) continue;
+		if (p->flags & I2C_M_RD)
+			err = i2c_read(p->addr, p->buf, p->len);
+		else
+			err = i2c_write(p->addr, p->buf, p->len);
+	}
+
+	/* Return the number of messages processed, or the error code.
+	*/
+	if (err == 0)
+		err = num;
+
+	return err;
+}
+
+static u32 str8100_func(struct i2c_adapter *adapter)
+{
+/*    return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE
+		| I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA
+		| I2C_FUNC_SMBUS_BLOCK_DATA;
+*/
+//    return I2C_FUNC_I2C;
+	return I2C_FUNC_SMBUS_EMUL|I2C_FUNC_I2C | I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE
+		| I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA
+		| I2C_FUNC_SMBUS_BLOCK_DATA;
+}
+
+static int str8100_ioctl(struct i2c_adapter *adapter,unsigned int cmd, unsigned long arg)
+{
+	unsigned int s_msg;    
+    
+	if(debug)
+		printk("===> %s: \n",__FUNCTION__);
+	if (copy_from_user(&s_msg, (unsigned int *)arg, sizeof(unsigned int))) 
+		return -EFAULT;
+	if ((clock != s_msg) && s_msg>= I2C_100KHZ && s_msg<= I2C_400KHZ){
+		clock=s_msg;
+		str8100_i2c_init();
+	}
+	return 0;   
+}
+
+
+//MKL: adapter ====================================================================
+// Eileen , for linux kernel 2.6.24 , 20080416
+// old : static irqreturn_t str8100_i2c_int(int irq, void *private, struct pt_regs *regs)
+static irqreturn_t str8100_i2c_int(int irq, void *private)
+{
+	unsigned int volatile interrupt_status;	
+    
+	interrupt_status = *((u32 volatile *)I2C_INTERRUPT_STATUS_REG_ADDR);
+	*((u32 volatile *)I2C_INTERRUPT_STATUS_REG_ADDR) = interrupt_status;
+	i2c_cmd_transfer.action_done = (interrupt_status & I2C_ACTION_DONE_FLAG) ? 1 : 0;
+	i2c_cmd_transfer.error_status = (interrupt_status & I2C_BUS_ERROR_FLAG) ? ((interrupt_status >> 8) & 0xFF) : 0;
+	if(debug)
+		printk("%s: i2c_cmd_transfer.error_status=0x%x\n",__FUNCTION__,i2c_cmd_transfer.error_status);
+	if (i2c_cmd_transfer.error_status && (i2c_cmd_transfer.error_status != 0xFF))
+	HAL_I2C_DISABLE_I2C();  
+	wake_up_interruptible(&waitqueue);
+	return IRQ_HANDLED;
+}
+
+#define I2C_HW_STR8100	0x1b0000
+static struct i2c_algorithm str8100_algorithm = {
+//    name:"str8100 i2c",
+//    id:I2C_ALGO_SMBUS,
+    master_xfer: str8100_xfer,
+    algo_control: str8100_ioctl, 
+    functionality: str8100_func,
+};
+
+static struct i2c_adapter str8100_i2c_adapter = {
+	name:              "Str8100 i2c",
+	id:                I2C_HW_STR8100,
+	algo:              &str8100_algorithm,
+};
+
+static ctl_table str8100_i2c_table[]={
+	{	//.ctl_name = DEV_I2C_CLOCK,
+		.procname = "str8100_clock",
+		.data=&clock,
+		.maxlen=sizeof(clock),
+		.mode = 0644,
+		.proc_handler=&proc_dointvec
+	},
+	{	//.ctl_name = DEV_I2C_DEBUG,
+		.procname = "str8100_debug",
+		.data=&debug,
+		.maxlen=sizeof(debug),
+		.mode = 0644,
+		.proc_handler=&proc_dointvec
+	},
+	//{ .ctl_name = 0 }
+};
+
+static ctl_table i2c_dir_table[] = {
+	{ //.ctl_name	= DEV_I2C,
+	  .procname	= "i2c",
+	  .mode		= 0555,
+	  .child	= str8100_i2c_table },
+	//{ .ctl_name = 0 }
+};
+
+static ctl_table i2c_root_table[] = {
+	{ //.ctl_name	= CTL_DEV,
+	  .procname	= "dev",
+	  .mode		= 0555,
+	  .child	= i2c_dir_table },
+	//{ .ctl_name = 0 }
+};
+static struct ctl_table_header *i2c_table_header;//=NULL;
+
+int  str8100_i2c_dev_init(void)
+{
+    
+	int rc;
+
+	printk(KERN_INFO "%s: i2c module version %s\n",__FUNCTION__, STR8100_I2C_VERSION); 
+
+	init_waitqueue_head(&waitqueue);
+	str8100_i2c_init();
+	if ((rc = i2c_add_adapter(&str8100_i2c_adapter))) {
+		printk(KERN_ERR "%s: Adapter %s registration failed\n",__FUNCTION__, str8100_i2c_adapter.name);
+	}
+	if (request_irq(INTC_I2C_BIT_INDEX, str8100_i2c_int, 0, "HS STR8100_I2C", NULL)) {
+		printk("%s: unable to get IRQ %d\n",__FUNCTION__, INTC_I2C_BIT_INDEX);
+		return -EAGAIN;
+	}
+	// Eileen , for linux kernel 2.6.24 , 20080416
+	// old : i2c_table_header = register_sysctl_table(i2c_root_table, 1);
+	i2c_table_header = register_sysctl_table(i2c_root_table);
+	
+	if(!i2c_table_header)
+		printk("%s: unable register sysctl\n",__FUNCTION__);
+	
+	return rc; 
+}
+
+static __init int i2c_init(void) 
+{
+	if(debug)
+		printk("%s: \n",__FUNCTION__);
+	return str8100_i2c_dev_init();
+}
+
+static __exit void i2c_exit(void) 
+{ 
+	int rc;
+	if(debug)
+		printk("%s: \n",__FUNCTION__);
+	if ((rc = i2c_del_adapter(&str8100_i2c_adapter))) printk(KERN_ERR "%s: i2c_del_adapter failed (%i), that's bad!\n",__FUNCTION__, rc);	
+	unregister_sysctl_table(i2c_table_header);
+	free_irq(INTC_I2C_BIT_INDEX,NULL);
+	
+}
+
+module_init(i2c_init);
+module_exit(i2c_exit);
+
+MODULE_AUTHOR("Mac Lin");
+MODULE_DESCRIPTION("I2C driver for Str8100");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.35.11/drivers/i2c/busses/i2c-str8100.h linux-2.6.35.11-ts7500//drivers/i2c/busses/i2c-str8100.h
--- linux-2.6.35.11/drivers/i2c/busses/i2c-str8100.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/i2c/busses/i2c-str8100.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,23 @@
+#ifndef STR8100_I2C_H
+#define STR8100_I2C_H
+
+typedef struct _i2c_transfer_s_
+{
+  unsigned int transfer_cmd;    
+  unsigned int write_data_len;    
+  unsigned int read_data_len;    
+  unsigned int write_data;    
+  unsigned int read_data;    
+  unsigned int slave_addr;    
+  unsigned int action_done;    
+  unsigned int error_status;
+}i2c_transfer_t;
+
+
+/*
+ * define 32 bit IO access macros
+ */ 
+#define IO_OUT_WORD(reg, data)     ((*((volatile u_int32 *)(reg))) = (u_int32)(data))
+#define IO_IN_WORD(reg)            (*((volatile u_int32 *)(reg)))
+
+#endif
diff -Nur linux-2.6.35.11/drivers/i2c/busses/Kconfig linux-2.6.35.11-ts7500//drivers/i2c/busses/Kconfig
--- linux-2.6.35.11/drivers/i2c/busses/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/i2c/busses/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -323,6 +323,11 @@
 	help
 	  The unit of the TWI clock is kHz.
 
+
+config I2C_STR8100
+ 	tristate "STR8100 I2C"
+ 	depends on ARCH_STR8100 
+
 config I2C_CPM
 	tristate "Freescale CPM1 or CPM2 (MPC8xx/826x)"
 	depends on (CPM1 || CPM2) && OF_I2C
diff -Nur linux-2.6.35.11/drivers/i2c/busses/Makefile linux-2.6.35.11-ts7500//drivers/i2c/busses/Makefile
--- linux-2.6.35.11/drivers/i2c/busses/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/i2c/busses/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -59,6 +59,7 @@
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
 obj-$(CONFIG_I2C_OCTEON)	+= i2c-octeon.o
 obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
+obj-$(CONFIG_I2C_STR8100)	+= i2c-str8100.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
diff -Nur linux-2.6.35.11/drivers/Makefile linux-2.6.35.11-ts7500//drivers/Makefile
--- linux-2.6.35.11/drivers/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -113,3 +113,4 @@
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-y				+= star/
diff -Nur linux-2.6.35.11/drivers/net/e1000/e1000_main.c linux-2.6.35.11-ts7500//drivers/net/e1000/e1000_main.c
--- linux-2.6.35.11/drivers/net/e1000/e1000_main.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/e1000/e1000_main.c	2011-02-26 20:32:46.000000000 -0500
@@ -883,7 +883,12 @@
 			if (pci_resource_len(pdev, i) == 0)
 				continue;
 			if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+            hw.io_base = (unsigned long)ioremap(pci_resource_start(pdev, i),
+			                pci_resource_len(pdev, i));
+#else            
 				hw->io_base = pci_resource_start(pdev, i);
+#endif            
 				break;
 			}
 		}
diff -Nur linux-2.6.35.11/drivers/net/fast_bridge.c linux-2.6.35.11-ts7500//drivers/net/fast_bridge.c
--- linux-2.6.35.11/drivers/net/fast_bridge.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/fast_bridge.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,184 @@
+#include <linux/stddef.h>
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/rtnetlink.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/pagemap.h>
+#include <linux/proc_fs.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/capability.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/pkt_sched.h>
+#include <linux/list.h>
+#include <linux/reboot.h>
+#ifdef NETIF_F_TSO
+#include <net/checksum.h>
+#endif
+#ifdef SIOCGMIIPHY
+#include <linux/mii.h>
+#endif
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#endif
+#ifdef NETIF_F_HW_VLAN_TX
+#include <linux/if_vlan.h>
+#endif
+
+static struct net_device *fast_bridge_dev1;
+static struct net_device *fast_bridge_dev2;
+static int fast_bridge_dev1_ready;
+static int fast_bridge_dev2_ready;
+
+static struct proc_dir_entry *fast_bridge_proc_entry;
+int fast_bridge_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data);
+int fast_bridge_write_proc(struct file *file, const char *buffer, unsigned long count, void *data);
+
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+__attribute__((section(".ispad"))) \
+int fast_bridge_forward_skb(struct sk_buff *skb)
+#else
+int fast_bridge_forward_skb(struct sk_buff *skb)
+#endif
+{
+#if 0
+	skb->h.raw = skb->nh.raw = skb->data;
+	skb->mac_len = skb->nh.raw - skb->mac.raw;
+#endif
+
+	if (!fast_bridge_dev1_ready || !fast_bridge_dev2_ready) {
+#if 0
+		kfree_skb(skb);
+#endif
+		return -1;
+	}
+
+	if (skb->dev != fast_bridge_dev1 && skb->dev != fast_bridge_dev2) {
+		return -1;
+	}
+
+	if (skb->dev == fast_bridge_dev1) {
+		skb->dev = fast_bridge_dev2;
+	} else if (skb->dev == fast_bridge_dev2) {
+		skb->dev = fast_bridge_dev1;
+	}
+	skb->ip_summed = CHECKSUM_NONE;
+	skb_push(skb, ETH_HLEN);
+#if 1
+	dev_queue_xmit(skb);
+#else
+   // not in 2.6.34!!!
+	skb->dev->hard_start_xmit(skb, skb->dev);
+#endif
+
+	return 0;
+}
+
+int fast_bridge_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	return 0;
+}
+
+int fast_bridge_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char *str;
+	char *dev1;
+	char *dev2;
+
+	if (count > 0) {
+		str = (char *)buffer;
+		dev1 = strsep(&str, "\t \n");
+		if (!dev1) goto out;
+		dev2 = strsep(&str, "\t \n");
+		if (!dev2) goto out;
+		/* scott.nic
+		fast_bridge_dev1 = dev_get_by_name(dev1);
+		*/
+		fast_bridge_dev1 = dev_get_by_name(&init_net, dev1);
+		if (!fast_bridge_dev1) goto out;
+
+		/* scott.nic
+		fast_bridge_dev2 = dev_get_by_name(dev2);
+		*/
+		fast_bridge_dev2 = dev_get_by_name(&init_net, dev2);
+		if (!fast_bridge_dev2) {
+			dev_put(fast_bridge_dev1);
+			goto out;
+		}
+		/* scott.nic
+		rtnl_shlock();
+		*/
+		if (!(fast_bridge_dev1->flags & IFF_UP)) {
+			dev_open(fast_bridge_dev1);
+		}
+		if (!(fast_bridge_dev2->flags & IFF_UP)) {
+			dev_open(fast_bridge_dev2);
+		}
+		if (!(fast_bridge_dev1->flags & IFF_PROMISC)) {
+			dev_set_promiscuity(fast_bridge_dev1, 1);
+		}
+		if (!(fast_bridge_dev2->flags & IFF_PROMISC)) {
+			dev_set_promiscuity(fast_bridge_dev2, 1);
+		}
+		fast_bridge_dev1_ready = 1;
+		fast_bridge_dev2_ready = 1;
+		/* scott.nic
+		rtnl_shunlock();
+		*/
+	}
+
+	return count;
+
+out:
+	return -EFAULT;
+}
+
+static void fast_bridge_proc_init(void)
+{
+	fast_bridge_proc_entry = create_proc_entry("fast_bridge", S_IFREG | S_IRUGO | S_IWUSR, NULL);
+	if (fast_bridge_proc_entry) {
+		fast_bridge_proc_entry->read_proc = fast_bridge_read_proc;
+		fast_bridge_proc_entry->write_proc = fast_bridge_write_proc;
+		fast_bridge_proc_entry->data = NULL;
+	}
+}
+
+static int __init fast_bridge_init_module(void)
+{
+	fast_bridge_proc_init();
+	return 0;
+}
+
+static void __exit fast_bridge_exit_module(void)
+{
+
+}
+
+module_init(fast_bridge_init_module);
+module_exit(fast_bridge_exit_module);
+
+MODULE_AUTHOR("KC Huang");
+MODULE_DESCRIPTION("FAST SIMPLE BRIDGE");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.35.11/drivers/net/Kconfig linux-2.6.35.11-ts7500//drivers/net/Kconfig
--- linux-2.6.35.11/drivers/net/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -2005,6 +2005,10 @@
 
 if NETDEV_1000
 
+config FAST_BRIDGE
+	depends on NET
+	bool "Simple Fast Bridge driver support"
+   
 config ACENIC
 	tristate "Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support"
 	depends on PCI
@@ -2840,6 +2844,10 @@
 
 endif # NETDEV_10000
 
+source "drivers/net/str9100/Kconfig"
+
+source "drivers/net/str8100/Kconfig"
+
 source "drivers/net/tokenring/Kconfig"
 
 source "drivers/net/wireless/Kconfig"
diff -Nur linux-2.6.35.11/drivers/net/Makefile linux-2.6.35.11-ts7500//drivers/net/Makefile
--- linux-2.6.35.11/drivers/net/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -8,6 +8,9 @@
 
 obj-$(CONFIG_TI_DAVINCI_EMAC) += davinci_emac.o
 
+obj-$(CONFIG_FAST_BRIDGE) += fast_bridge.o
+obj-$(CONFIG_STAR_GSW) += str9100/
+obj-$(CONFIG_STAR_NIC) += str8100/
 obj-$(CONFIG_E1000) += e1000/
 obj-$(CONFIG_E1000E) += e1000e/
 obj-$(CONFIG_IBM_NEW_EMAC) += ibm_newemac/
diff -Nur linux-2.6.35.11/drivers/net/str8100/Kconfig linux-2.6.35.11-ts7500//drivers/net/str8100/Kconfig
--- linux-2.6.35.11/drivers/net/str8100/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str8100/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,28 @@
+menu "CNS2100 NIC support"
+	depends on ARCH_STR8100 && (NET_ETHERNET || NETDEV_1000)
+
+config STAR_NIC
+	tristate "CNS2100 NIC driver support"
+	help
+
+choice 
+	depends on STAR_NIC 
+        prompt "PHY Driver"
+        default STR_NIC_PHY_VSC8201
+          
+config STAR_NIC_PHY_INTERNAL_PHY
+        bool "Internal 10/100 PHY"
+
+config STAR_NIC_PHY_VSC8601
+        bool "Vitesse 8601"
+        
+config STAR_NIC_PHY_IP101A
+        bool "ICPlus IP101A"
+
+config STAR_NIC_PHY_IP1001
+		bool "ICPlus IP1001"
+          
+endchoice
+
+endmenu
+
diff -Nur linux-2.6.35.11/drivers/net/str8100/Makefile linux-2.6.35.11-ts7500//drivers/net/str8100/Makefile
--- linux-2.6.35.11/drivers/net/str8100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str8100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,34 @@
+################################################################################
+#
+# 
+# Copyright(c) 2005 -  Star semiconduction. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+#
+# Makefile for the Star GSW ethernet driver
+#
+
+obj-$(CONFIG_STAR_NIC) += star_nic_module.o
+star_nic_module-objs := star_nic.o
+
diff -Nur linux-2.6.35.11/drivers/net/str8100/star_nic.c linux-2.6.35.11-ts7500//drivers/net/str8100/star_nic.c
--- linux-2.6.35.11/drivers/net/str8100/star_nic.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str8100/star_nic.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,3070 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/bitops.h>
+#include <asm/irq.h>		// 2006.03.22 richliu add list include file
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/if_ether.h>
+#include <linux/icmp.h>
+#include <linux/udp.h>
+#include <linux/tcp.h>
+#include <linux/if_arp.h>
+#include <net/arp.h>
+
+#include <asm/arch/star_nic.h>
+
+#ifdef CONFIG_PM
+#include <linux/suspend.h>
+#endif
+
+#if 1
+#define DBG_PRINT printk
+#else
+#define DBG_PRINT(arg...)
+#endif
+
+#if 0
+#define DO_PRINT printk
+#define STAR_NIC_PRINT_ISR_STATUS
+#else
+#define DO_PRINT(arg...)
+#endif /* __DEBUG_PRINT_OUT */
+
+// VSC8601 and WavePlus Phy are the same
+#define STAR_NIC_PHY_ADDR	0
+
+#define CONFIG_STAR_NIC_NAPI
+//#define FREE_TX_SKB_MULTI		// FIXME: define this will cause samba fail
+
+#define STAR_NIC_TX_HW_CHECKSUM
+#define STAR_NIC_RX_HW_CHECKSUM
+
+#define STAR_NIC_SG
+
+#if defined(STAR_NIC_SG) && !defined(STAR_NIC_TX_HW_CHECKSUM)
+#define STAR_NIC_TX_HW_CHECKSUM
+#endif
+
+#define STAR_NIC_STATUS_ISR
+#define STAR_NIC_RXQF_ISR
+
+//#ifndef CONFIG_STAR_NIC_NAPI
+#define STAR_NIC_DELAYED_INTERRUPT
+//#endif
+
+#define MAX_PEND_INT_CNT	0x20
+#define MAX_PEND_TIME		0x20
+
+//#ifdef CONFIG_STAR_NIC_PHY_VSC8601
+//#define CONFIG_STAR_JUMBO
+//#endif
+//#define CONFIG_STAR_JUMBO
+#ifdef CONFIG_STAR_JUMBO
+#define MAX_PACKET_LEN		(2038)
+//#define MAX_PACKET_LEN		(9038)
+#else
+#define MAX_PACKET_LEN		(1536)
+#endif
+/* This constant(PKT_MIN_SIZE) can be replaced with ETH_ZLEN defined in
+ * include/linux/if_ether.h */
+#define PKT_MIN_SIZE		60
+
+//#define STAR_NIC_TIMER
+
+/* 
+ * Maximum Transmit/Receive Frame Descriptors for NIC's MAC frame
+ */
+#ifdef FREE_TX_SKB_MULTI
+#define STAR_NIC_MAX_TFD_NUM	48
+#define STAR_NIC_MAX_RFD_NUM	256
+#else
+#define STAR_NIC_MAX_TFD_NUM	48		// FIXME: original 64 will cause UDP fail
+#define STAR_NIC_MAX_RFD_NUM	64
+#endif
+
+
+#define LAN_PORT 1
+
+typedef struct
+{
+	u32		mib_rx_ok_pkt;
+	u32		mib_rx_ok_byte;
+	u32		mib_rx_runt;
+	u32		mib_rx_over_size;
+	u32		mib_rx_no_buffer_drop;
+	u32		mib_rx_crc_err;
+	u32		mib_rx_arl_drop;
+	u32		mib_rx_myvid_drop;
+	u32		mib_rx_csum_err;
+	u32		mib_rx_pause_frame;
+	u32		mib_tx_ok_pkt;
+	u32		mib_tx_ok_byte;
+	u32		mib_tx_pause_frame;
+} mib_info_t;
+
+/* store this information for the driver.. */
+struct star_nic_private {
+	struct napi_struct      napi;
+	struct net_device       *dev;
+	struct net_device_stats stats;
+	spinlock_t lock;
+	int dev_index;
+	u8 phy_addr;
+	u16 phy_id;
+	mib_info_t mib_info;
+};
+
+/*
+ * Network Driver, Receive/Send and Initial Buffer Function
+ */
+typedef struct {
+	// 1st 32Bits
+	u32 data_ptr;
+
+	// 2nd  32Bits
+	u32 length:16;
+	u32 reserved0:7;
+	u32 tco:1;
+	u32 uco:1;
+	u32 ico:1;
+	u32 insv:1;
+	u32 intr:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 cown:1;
+
+	// 3rd 32Bits
+	u32 vid:12;
+	u32 cfi:1;
+	u32 pri:3;
+	u32 epid:16;
+
+	// 4th 32Bits
+	u32 reserved1;
+} __attribute__((packed)) STAR_NIC_TXDESC;
+
+typedef struct {
+	// 1st 32Bits
+	u32 data_ptr;
+
+	// 2nd  32Bits
+	u32 length:16;
+	u32 l4f:1;
+	u32 ipf:1;
+	u32 prot:2;
+	u32 vted:1;
+	u32 mymac:1;
+	u32 hhit:1;
+	u32 rmc:1;
+	u32 crce:1;
+	u32 osize:1;
+	u32 reserved0:2;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 cown:1;
+
+	// 3rd 32Bits
+	u32 vid:12;
+	u32 cfi:1;
+	u32 pri:3;
+	u32 epid:16;
+
+	// 4th 32Bits
+	u32 reserved1;
+} __attribute__((packed)) STAR_NIC_RXDESC;
+
+/* 
+ * Transmit Frame Descriptor Ring for TFDS
+ */
+typedef struct {
+	u32			phy_addr;
+	STAR_NIC_TXDESC		*vir_addr;
+	u32			cur_index; // TX's current will point to Free Descriptors
+#if defined(FREE_TX_SKB_MULTI) || defined(STAR_NIC_TIMER)
+	u32			to_free_index;
+#endif
+	struct sk_buff		*skb_ptr[STAR_NIC_MAX_TFD_NUM]; // TX's sk_buff ptr
+} TXRING_INFO;
+
+/* 
+ * Receive Frame Descriptor Ring for RFDS
+ */
+typedef struct {
+	u32			phy_addr;
+	STAR_NIC_RXDESC		*vir_addr;
+	u32			cur_index;
+	struct sk_buff		*skb_ptr[STAR_NIC_MAX_RFD_NUM];	// RX's sk_buff ptr
+} RXRING_INFO;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,32)
+#define IRQ_RETURN void
+#define IRQ_HANDLED 
+static const char star_nic_driver_version[] =
+	"Star NIC Driver(for Linux Kernel 2.4) - Star Semiconductor\n";
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define IRQ_RETURN irqreturn_t
+static const char star_nic_driver_version[] =
+	"Star NIC Driver(for Linux Kernel 2.6) - Star Semiconductor\n";
+#endif
+
+//========================================================
+#ifdef CONFIG_STAR_NIC_PHY_INTERNAL_PHY
+#define FE_PHY_LED_MODE (0x1 << 12)
+#define CONFIG_INTERNEL_PHY_PATCH
+#endif
+
+#ifdef CONFIG_INTERNEL_PHY_PATCH
+#define INTERNAL_PHY_PATCH_CHECKCNT	16
+#define INTERNAL_PHY_PATCH_CHECK_PERIOD	1000 //ms
+static struct timer_list internal_phy_timer;
+static void internal_phy_patch_check(int);
+static void internal_phy_update(unsigned long data);
+#endif
+//========================================================
+
+extern void fa_dma_inv_range(unsigned long s, unsigned long e);
+extern void fa_dma_clean_range(unsigned long s, unsigned long e);
+
+#define increase_cyclic(var, limit) {\
+				var++; \
+				if (var>=limit) var=0;\
+			}
+
+//static struct net_device *CUR_NAPI_DEV;
+static struct net_device *STAR_NIC_LAN_DEV;
+
+static int install_isr_account = 0;
+static int is_qf = 0; // determine queue full state
+
+static spinlock_t star_nic_send_lock;
+
+static TXRING_INFO txring;
+static RXRING_INFO rxring;
+
+static struct proc_dir_entry *star_nic_proc_entry;
+
+static u8 default_mac_addr[] = { 0x08, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e };
+
+typedef struct
+{   
+	u32 vid;	//0~4095
+	u32 control;	//ENABLE or DISABLE
+} my_vlan_entry_t;
+
+static my_vlan_entry_t my_vlan_id[4] =
+{
+	{ 2, 0},	//value for my_vid0
+	{ 2, 1},	//value for my_vid1
+	{ 1, 1},	//value for my_vid2
+	{ 1, 0}		//value for my_vid3
+};
+
+
+#ifdef CONFIG_STAR_NIC_NAPI
+static void star_nic_receive_packet(int mode, int *work_done, int work_to_do);
+#else
+static void star_nic_receive_packet(int mode);
+#endif
+
+static void star_nic_phy_powerdown(struct net_device *dev);
+static void star_nic_phy_powerup(struct net_device *dev);
+
+#ifdef STAR_NIC_TIMER
+static struct timer_list star_nic_timer;
+static void star_nic_timer_func(unsigned long data)
+{
+	int i;
+	int txsd_index;
+	int txsd_current;
+	int skb_free_count = 0;
+	STAR_NIC_TXDESC volatile *txdesc_ptr;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	HAL_NIC_READ_TXSD(txsd_current);
+	txsd_index = (txsd_current - (u32)txring.phy_addr) >> 4;
+	if (txsd_index > txring.to_free_index) {
+		skb_free_count = txsd_index - txring.to_free_index;
+	} else if (txsd_index <= txring.to_free_index) {
+		skb_free_count = STAR_NIC_MAX_TFD_NUM + txsd_index - txring.to_free_index;
+	}
+	for (i = 0; i < skb_free_count; i++) {
+		txdesc_ptr = txring.vir_addr + txring.to_free_index;
+		if (txdesc_ptr->cown == 0) {
+			break;
+		}
+		if (txring.skb_ptr[txring.to_free_index]) {
+			dev_kfree_skb_any(txring.skb_ptr[txring.to_free_index]);
+			txring.skb_ptr[txring.to_free_index] = NULL;
+		}
+		txring.to_free_index++;
+		if (txring.to_free_index == STAR_NIC_MAX_TFD_NUM) {
+			txring.to_free_index = 0;
+		}
+	}
+	local_irq_restore(flags);
+}
+#endif
+
+#if 0
+#define between(x, start, end) ((x)>=(start) && (x)<=(end))
+static void print_packet(unsigned char *data, int len) 
+{
+	int i, j;
+
+	printk("packet length: %d%s:\n", len, len>100?"(only show the first 100 bytes)":"");
+	if (len > 100) {
+		len = 100;
+	}
+	for (i = 0; len;) {
+		if (len >=16) {
+			for (j=0;j<16;j++) {
+				printk("%02x ", data[i++]);
+			}
+			printk("| ");
+			i -= 16;
+			for(j=0;j<16;j++) {
+				if (between(data[i], 0x21, 0x7e) ) {
+					printk("%c", data[i++]);
+				} else {
+					printk(".");
+					i++;
+				}
+			}
+			printk("\n");
+			len -= 16;
+		} else {
+			/* last line */
+			for (j = 0; j < len; j++) {
+				printk("%02x ", data[i++]);
+			}
+			for (;j < 16; j++) {
+				printk("   ");
+			}
+			printk("| ");
+			i -= len;
+			for (j = 0;j < len; j++) {
+				if (between(data[i], 0x21, 0x7e)) {
+					printk("%c", data[i++]);
+				} else {
+					printk(".");
+					i++;
+				}
+			}
+			for (; j < 16; j++) {
+				printk(" ");
+			}
+			printk("\n");
+			len = 0;
+		}
+	}
+
+	return;
+}
+#endif /* Disable function print_packet */ 
+
+#ifdef STAR_NIC_DEBUG
+static void star_nic_show_format_reg(u32 val)
+{
+	int i;
+
+	for (i = 31; i >= 0; i--) {
+		if (val & ((unsigned long)1 << i)) {
+			printk("[%02d:1] ", i);
+		} else {
+			printk("[%02d:0] ", i);
+		}
+		if ((i % 8) == 0) {
+			printk("\n");
+		}
+	}
+	printk("==================================================================\n");
+}
+
+static void star_nic_show_reg(void)
+{
+	u32 reg_val;
+
+	printk("\n");
+
+	reg_val = NIC_MEM_MAP_VALUE(0x000);
+	printk("NIC REG OFF 0x000: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x004);
+	printk("NIC REG OFF 0x004: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x008);
+	printk("NIC REG OFF 0x008: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x00C);
+	printk("NIC REG OFF 0x00C: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x010);
+	printk("NIC REG OFF 0x010: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x014);
+	printk("NIC REG OFF 0x014: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x018);
+	printk("NIC REG OFF 0x018: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x01C);
+	printk("NIC REG OFF 0x01C: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x020);
+	printk("NIC REG OFF 0x020: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x024);
+	printk("NIC REG OFF 0x024: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x028);
+	printk("NIC REG OFF 0x028: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x030);
+	printk("NIC REG OFF 0x030: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x034);
+	printk("NIC REG OFF 0x034: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x038);
+	printk("NIC REG OFF 0x038: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x03C);
+	printk("NIC REG OFF 0x03C: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x040);
+	printk("NIC REG OFF 0x040: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x044);
+	printk("NIC REG OFF 0x044: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x048);
+	printk("NIC REG OFF 0x048: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x04C);
+	printk("NIC REG OFF 0x04C: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x050);
+	printk("NIC REG OFF 0x050: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x054);
+	printk("NIC REG OFF 0x054: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x058);
+	printk("NIC REG OFF 0x058: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+
+	reg_val = NIC_MEM_MAP_VALUE(0x05C);
+	printk("NIC REG OFF 0x05C: 0x%08x\n", reg_val);
+	star_nic_show_format_reg(reg_val);
+}
+#endif
+
+static void star_nic_mib_reset(void)
+{
+	u32 v;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	v = NIC_MIB_RX_OK_PKT_CNTR;
+	v = NIC_MIB_RX_OK_BYTE_CNTR;
+	v = NIC_MIB_RX_RUNT_BYTE_CNTR;
+	v = NIC_MIB_RX_OSIZE_DROP_PKT_CNTR;
+	v = NIC_MIB_RX_NO_BUF_DROP_PKT_CNTR;
+	v = NIC_MIB_RX_CRC_ERR_PKT_CNTR;
+	v = NIC_MIB_RX_ARL_DROP_PKT_CNTR;
+	v = NIC_MIB_MYVLANID_MISMATCH_DROP_PKT_CNTR;
+	v = NIC_MIB_RX_CHKSUM_ERR_PKT_CNTR;
+	v = NIC_MIB_RX_PAUSE_FRAME_PKT_CNTR;
+	v = NIC_MIB_TX_OK_PKT_CNTR;
+	v = NIC_MIB_TX_OK_BYTE_CNTR;
+	v = NIC_MIB_TX_PAUSE_FRAME_CNTR;
+	local_irq_restore(flags);
+}
+
+static void star_nic_mib_read(struct net_device *dev)
+{
+	struct star_nic_private *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	local_irq_save(flags);
+	priv->mib_info.mib_rx_ok_pkt		+= NIC_MIB_RX_OK_PKT_CNTR;
+	priv->mib_info.mib_rx_ok_byte		+= NIC_MIB_RX_OK_BYTE_CNTR;
+	priv->mib_info.mib_rx_runt		+= NIC_MIB_RX_RUNT_BYTE_CNTR;
+	priv->mib_info.mib_rx_over_size		+= NIC_MIB_RX_OSIZE_DROP_PKT_CNTR;
+	priv->mib_info.mib_rx_no_buffer_drop	+= NIC_MIB_RX_NO_BUF_DROP_PKT_CNTR;
+	priv->mib_info.mib_rx_crc_err		+= NIC_MIB_RX_CRC_ERR_PKT_CNTR;
+	priv->mib_info.mib_rx_arl_drop		+= NIC_MIB_RX_ARL_DROP_PKT_CNTR;
+	priv->mib_info.mib_rx_myvid_drop	+= NIC_MIB_MYVLANID_MISMATCH_DROP_PKT_CNTR;
+	priv->mib_info.mib_rx_csum_err		+= NIC_MIB_RX_CHKSUM_ERR_PKT_CNTR;
+	priv->mib_info.mib_rx_pause_frame	+= NIC_MIB_RX_PAUSE_FRAME_PKT_CNTR;
+	priv->mib_info.mib_tx_ok_pkt		+= NIC_MIB_TX_OK_PKT_CNTR;
+	priv->mib_info.mib_tx_ok_byte		+= NIC_MIB_TX_OK_BYTE_CNTR;
+	priv->mib_info.mib_tx_pause_frame	+= NIC_MIB_TX_PAUSE_FRAME_CNTR;
+	local_irq_restore(flags);
+}
+
+static int star_nic_write_phy(u8 phy_addr, u8 phy_reg, u16 write_data)
+{
+	int i;
+
+	if (phy_addr > 31) {
+		return 0;
+	}
+
+	//clear previous rw_ok status
+	NIC_PHY_CONTROL_REG0 = (0x1 << 15);
+ 
+	NIC_PHY_CONTROL_REG0 = ((phy_addr & 0x1F) |   
+		((phy_reg & 0x1F) << 8) |
+		(0x1 << 13) |
+		((write_data & 0xFFFF) << 16));
+
+	for (i = 0; i < 10000; i++) {
+		// if write command completed
+		if ((NIC_PHY_CONTROL_REG0) & (0x1 << 15)) {
+			// clear the rw_ok status, and clear other bits value
+			NIC_PHY_CONTROL_REG0 = (0x1 << 15);
+			return (0);    /* for ok indication */
+		}
+		udelay(1000);
+	}
+
+	printk("star_nic_write_phy() failed!! phy_addr:0x%x phy_reg:0x%x write_data:0x%x\n",
+		phy_addr, phy_reg, write_data);
+	return (-1);    /* for failure indication */
+}
+
+static int star_nic_read_phy(u8 phy_addr, u8 phy_reg, u16 *read_data)
+{
+	u32 status;
+	int i;
+
+	if (phy_addr > 31) {
+		return 0;
+	}
+
+	// clear previous rw_ok status
+	NIC_PHY_CONTROL_REG0 = (0x1 << 15);
+
+	NIC_PHY_CONTROL_REG0 = ((phy_addr & 0x1F) | 
+		((phy_reg & 0x1F) << 8) | 
+		(0x1 << 14));    
+
+	for (i = 0; i < 10000; i++) {
+		status = NIC_PHY_CONTROL_REG0;
+		if (status & (0x1 << 15)) {
+			// clear the rw_ok status, and clear other bits value
+			NIC_PHY_CONTROL_REG0 = (0x1 << 15);
+			*read_data = (u16)((status >> 16) & 0xFFFF);
+			return (0);    /* for ok indication */
+		}
+		udelay(1000);
+	}
+
+	printk("star_nic_read_phy() failed!! phy_addr:0x%x phy_reg:0x%x\n",
+		phy_addr, phy_reg);
+	return (-1);    /* for failure indication */
+}
+
+static int star_nic_dma_config(struct net_device *dev)
+{
+	u32 dma_config = 0;
+
+	dma_config = NIC_DMA_CONFIG_REG;
+
+#if 1
+	/* Config TX DMA */ 
+	dma_config &=  ~(0x3 << 6); //TX auto polling :1  us
+	//dma_config |=  (0x1 << 6); //TX auto polling :10 us
+	dma_config |=  (0x2 << 6); //TX auto polling :100us
+	//dma_config |=  (0x3 << 6); //TX auto polling :1000us
+	dma_config |=  (0x1 << 5); //TX auto polling C-bit enable
+	dma_config &=  ~(0x1 << 4); //TX can transmit packets,No suspend
+#endif
+
+#if 1
+	/* Config RX DMA */
+	dma_config &=  ~(0x3 << 2); //RX auto polling :1  us
+	//dma_config |=  (0x1 << 2); //RX auto polling :10 us
+	dma_config |=  (0x2 << 2); //RX auto polling :100us
+	//dma_config |=  (0x3 << 2); //RX auto polling :1000us
+	dma_config |=  (0x1 << 1); //RX auto polling C-bit enable
+	dma_config &=  ~0x1; //RX can receive packets, No suspend
+#endif
+
+	// 4N+2(for Linux)
+	dma_config &= ~(0x1 << 16);
+	// 4N
+	//dma_config |= (0x1 << 16);
+
+	NIC_DMA_CONFIG_REG = dma_config;
+
+	return 0;
+}
+
+static int star_nic_mac_config(struct net_device *dev)
+{
+	u32 mac_config;
+
+	mac_config = NIC_MAC_CONTROL_REG;
+
+#ifdef STAR_NIC_TX_HW_CHECKSUM
+	// Tx ChkSum offload On: TCP/UDP/IP
+	mac_config |= (0x1 << 26);
+#else
+	// Tx ChkSum offload Off: TCP/UDP/IP
+	mac_config &= ~(0x1 << 26);
+#endif
+
+#ifdef STAR_NIC_RX_HW_CHECKSUM
+	// Rx ChkSum offload On: TCP/UDP/IP
+	mac_config |= (0x1 << 25);
+#else
+	// Rx ChkSum offload Off: TCP/UDP/IP
+	mac_config &= ~(0x1 << 25);
+#endif
+
+	mac_config |= (0x1 << 24);	// Accept CSUM error pkt
+	//mac_config &= ~(0x1 << 24);	// Discard CSUM error pkt
+
+	//mac_config |= (0x1 << 23);	// IST Enable
+	mac_config &= ~(0x1 << 23);	// IST disable
+
+	mac_config |= (0x1 << 22);	// Strip vlan tag
+	//mac_config &= ~(0x1 << 22);	// Keep vlan tag
+
+	mac_config |= (0x1 << 21);	// Accept CRC error pkt
+	//mac_config &= ~(0x1 << 21);	// Disacrd CRC error pkt
+
+	mac_config |= (0x1 << 20);	// CRC strip
+	//mac_config &= ~(0x1 << 20);	// Keep CRC
+
+#ifdef CONFIG_STAR_JUMBO
+	mac_config |= (0x1 << 18);	// Accept oversize pkt
+#else
+	mac_config &= ~(0x1 << 18);	// Discard oversize pkt
+#endif
+
+	mac_config &= ~(0x3 << 16);	// clear, set 1518
+
+#ifdef CONFIG_STAR_JUMBO
+	mac_config |= (0x3 << 16);	//set reserved, for jumbo frame
+#else
+	mac_config |= (0x2 << 16);	// 1536
+	//mac_config |= (0x1 << 16);	// 1522
+#endif
+
+	// IPG
+	mac_config |= (0x1f << 10);
+
+	// Do not skip 16 consecutive collisions pkt
+	mac_config |= (0x1 << 9);	// allow to re-tx
+	//mac_config &= ~(0x1 << 9);	// drop pkt
+
+	mac_config |= (0x1 << 8);	// Fast retry
+	//mac_config &= ~(0x1 << 8);	// standard
+
+	NIC_MAC_CONTROL_REG = mac_config;
+
+	return 0;
+}
+
+static int star_nic_fc_config(struct net_device *dev)
+{
+	u32 fc_config;
+
+	fc_config = NIC_FLOW_CONTROL_CONFIG_REG;
+
+	// Send pause on frame threshold
+	fc_config &= ~(0xfff << 16);	// Clear
+	fc_config |= (0x360 << 16);	// Set
+
+	//fc_config |= (0x1 << 8);	// Enable UC_PAUSE
+	fc_config &= ~(0x1 << 8);	// Disable UC_PAUSE
+
+	fc_config |= (0x1 << 7);	// Enable Half Duplex backpressure
+	//fc_config &= ~(0x1 << 7);	// Disable Half Duplex backpressure
+
+    	//fc_config |= (0x1 << 6);	// CRS-based BP
+	fc_config &= ~(0x1 << 6);	// Collision-based BP
+
+	//fc_config |= (0x1 << 5);	// Enable max BP collision
+	fc_config &= ~(0x1 << 5);	// Disable max BP collision
+
+	// max BP collision count
+	fc_config &= ~(0x1f);		// Clear
+	fc_config |= (0xc);		// Set
+
+	NIC_FLOW_CONTROL_CONFIG_REG = fc_config;
+
+	return 0;
+}
+
+static int star_nic_phy_config(struct net_device *dev)
+{
+	struct star_nic_private *priv = netdev_priv(dev);
+	u32 phy_config = NIC_PHY_CONTROL_REG1;
+#ifdef CONFIG_STAR_NIC_PHY_VSC8601
+	u32 phy_addr=0;
+#endif /* CONFIG_STAR_NIC_PHY_VSC8601 */
+	//int i;
+
+#ifdef CONFIG_STAR_NIC_PHY_INTERNAL_PHY 
+	printk("Star Internal PHY\n");
+
+#if 0
+	{
+		u16 phy_data;
+		// restart the internal phy
+		star_nic_write_phy(STAR_NIC_PHY_ADDR, 0, 0x8000);
+		while (1) {
+			star_nic_read_phy(STAR_NIC_PHY_ADDR, 0, &phy_data);
+			if ( (phy_data&0x8000) ==0x0000) { // phy now at normal mode
+				break;
+			}
+		}
+	}
+#endif
+
+	priv->phy_addr = STAR_NIC_PHY_ADDR;
+	// set phy addr for auto-polling
+	phy_config |= (priv->phy_addr & 0x1f) << 24;
+
+	// set internal phy mode
+	// internel 10/100 phy
+	phy_config |= 0x1 << 18;
+
+	// MII
+	phy_config &= ~(0x1 << 17);
+
+	// MAC mode
+	phy_config &= ~(0x1 << 16);
+
+	// config PHY LED bit[13:12]
+	star_nic_read_phy(priv->phy_addr, 31, (u16 *)(&phy_config));
+	phy_config &= ~(0x3 << 12); // clear LED control
+	phy_config |= FE_PHY_LED_MODE;
+	star_nic_write_phy(priv->phy_addr, 31, phy_config);
+#endif
+#ifdef CONFIG_STAR_NIC_PHY_VSC8601
+	u16 phy_data;
+
+	printk("VSC8601 Chip\n");
+
+	// phy addr for auto-polling
+	phy_config |= ((phy_addr & 0x1f) << 24);
+
+	// set external phy mode
+	phy_config &= ~(0x1 << 18);
+
+	// set RGMII
+	phy_config |= (0x1 << 17);
+
+	// set MII interface
+	phy_config &= ~(0x1 << 16);
+
+	NIC_PHY_CONTROL_REG1 = phy_config;
+//=========================================================
+
+	priv->phy_addr = STAR_NIC_PHY_ADDR;
+	// set phy addr for auto-polling
+	phy_config |= (priv->phy_addr & 0x1f) << 24;
+
+	// set external phy mode
+	// MII/RGMII interface
+	phy_config &= ~(0x1 << 18);
+
+	// RGMII
+	phy_config |= (0x1 << 17);
+
+	// MAC mode
+	phy_config &= ~(0x1 << 16);
+
+	star_nic_read_phy(priv->phy_addr, 3, &phy_data);
+	if ((phy_data & 0x000f) == 0x0000) { // type A chip
+		u16 tmp16;
+
+		printk("VSC8601 Type A Chip\n");
+		star_nic_write_phy(priv->phy_addr, 31, 0x52B5);
+		star_nic_write_phy(priv->phy_addr, 16, 0xAF8A);
+
+		phy_data = 0x0;
+		star_nic_read_phy(priv->phy_addr, 18, &tmp16);
+		phy_data |= (tmp16 & ~0x0);
+		star_nic_write_phy(priv->phy_addr, 18, phy_data);
+
+		phy_data = 0x0008;
+		star_nic_read_phy(priv->phy_addr, 17, &tmp16);
+		phy_data |= (tmp16 & ~0x000C);
+		star_nic_write_phy(priv->phy_addr, 17, phy_data);        	
+
+		star_nic_write_phy(priv->phy_addr, 16, 0x8F8A);        	
+
+		star_nic_write_phy(priv->phy_addr, 16, 0xAF86);        	
+
+		phy_data = 0x0008;
+		star_nic_read_phy(priv->phy_addr, 18, &tmp16);
+		phy_data |= (tmp16 & ~0x000C);
+		star_nic_write_phy(priv->phy_addr, 18, phy_data);        	
+
+		phy_data = 0x0;
+		star_nic_read_phy(priv->phy_addr, 17, &tmp16);
+		phy_data |= (tmp16 & ~0x0);
+		star_nic_write_phy(priv->phy_addr, 17, phy_data);        	
+
+		star_nic_write_phy(priv->phy_addr, 16, 0x8F8A);        	
+
+		star_nic_write_phy(priv->phy_addr, 16, 0xAF82);        	
+
+		phy_data = 0x0;
+		star_nic_read_phy(priv->phy_addr, 18, &tmp16);
+		phy_data |= (tmp16 & ~0x0);
+		star_nic_write_phy(priv->phy_addr, 18, phy_data);        	
+
+		phy_data = 0x0100;
+		star_nic_read_phy(priv->phy_addr, 17, &tmp16);
+		phy_data |= (tmp16 & ~0x0180);
+		star_nic_write_phy(priv->phy_addr, 17, phy_data);        	
+
+		star_nic_write_phy(priv->phy_addr, 16, 0x8F82);        	
+
+		star_nic_write_phy(priv->phy_addr, 31, 0x0);        	
+           
+		//Set port type: single port
+		star_nic_read_phy(priv->phy_addr, 9, &phy_data);        	
+		phy_data &= ~(0x1 << 10);
+		star_nic_write_phy(priv->phy_addr, 9, phy_data);        	
+	} else if ((phy_data & 0x000f) == 0x0001) { // type B chip
+		printk("VSC8601 Type B Chip\n");
+		star_nic_read_phy(priv->phy_addr, 23, &phy_data);
+		phy_data |= ( 0x1 << 8); //set RGMII timing skew
+		star_nic_write_phy(priv->phy_addr, 23, phy_data);
+	}
+
+	// change to extened registers
+	star_nic_write_phy(priv->phy_addr, 31, 0x0001);
+
+	star_nic_read_phy(priv->phy_addr, 28, &phy_data);
+	phy_data &= ~(0x3 << 14); // set RGMII TX timing skew
+	phy_data |= (0x3 << 14); // 2.0ns
+	phy_data &= ~(0x3 << 12); // set RGMII RX timing skew
+	phy_data |= (0x3 << 12); // 2.0ns
+	star_nic_write_phy(priv->phy_addr, 28, phy_data);
+
+	// change to normal registers
+	star_nic_write_phy(priv->phy_addr, 31, 0x0000);
+
+	// set TX and RX clock skew
+	//NIC_TEST_0_REG = (0x2 << 2) | (0x2 << 0);
+
+#endif
+
+#ifdef CONFIG_STAR_NIC_PHY_IP101A
+	// ICPlus IP101A
+	printk("ICPlus IP101A\n");
+	priv->phy_addr = 1;
+	// set phy addr for auto-polling
+	phy_config |= (priv->phy_addr & 0x1f) << 24;
+
+	// set external phy mode
+	// MII/RGMII interface
+	phy_config &= ~(0x1 << 18);
+
+	// MII
+	phy_config &= ~(0x1 << 17);
+
+	// MAC mode
+	phy_config &= ~(0x1 << 16);
+#endif
+
+/* robin 080102 				*/
+/* added ICPlus IP1001 support	*/
+#ifdef CONFIG_STAR_NIC_PHY_IP1001
+u16 phy_data;
+
+u32 phy_addr = 1;
+
+phy_config = NIC_PHY_CONTROL_REG1;
+
+	// set phy addr for auto-polling
+	phy_config |= ((phy_addr & 0x1f) << 24);
+
+	// set external phy mode
+	// MII/RGMII interface
+	phy_config &= ~(0x1 << 18);
+
+	// RGMII
+	phy_config |= (0x1 << 17);
+
+	// MAC mode
+	phy_config &= ~(0x1 << 16);
+
+ NIC_PHY_CONTROL_REG1 = phy_config;
+    star_nic_read_phy(phy_addr,2,&phy_data);
+    //printf("\n phy.reg2=0x%04x",phy_data);
+	
+#if 1//set AN capability
+
+
+    star_nic_read_phy(phy_addr,4,&phy_data);
+
+    phy_data &= ~(0xf<<5);//clear
+    phy_data |= (0x1<<5); //10Half
+    phy_data |= (0x1<<6); //10Full
+    phy_data |= (0x1<<7); //100Half
+    phy_data |= (0x1<<8); //100Full
+//    phy_data &= ~(0x1<<10); //FC off
+    phy_data |= (0x1<<10); //FC on
+    star_nic_write_phy(phy_addr,4,phy_data);
+
+
+    star_nic_read_phy(phy_addr,9,&phy_data);
+
+    phy_data |= (0x1<<9); //1000Full on
+
+    phy_data &= ~(0x1<<10); 
+
+    phy_data |= (0x1<<12); 
+
+    star_nic_write_phy(phy_addr,9,phy_data);
+
+
+
+
+    star_nic_read_phy(phy_addr,16,&phy_data);
+
+    phy_data &= ~(0x1<<11); //Smart function off
+
+    phy_data |=  (0x1<<0); //TX delay
+
+    phy_data |=  (0x1<<1); //RX delay
+
+    star_nic_write_phy(phy_addr,16,phy_data);
+
+    star_nic_read_phy(phy_addr,16,&phy_data);
+    //printf("\n phy.reg16=0x%04x",phy_data);
+
+
+//    Hal_Nic_Read_PHY(NIC_PHY_ADDRESS,20,&phy_data);
+//
+//    phy_data &= ~(0x1<<2); 
+//
+//    phy_data |=  (0x1<<9); 
+//    Hal_Nic_Write_PHY(NIC_PHY_ADDRESS,20,phy_data);
+
+
+
+
+    star_nic_read_phy(phy_addr,0,&phy_data);
+    phy_data |= (0x1<<9); //re-AN
+    star_nic_write_phy(phy_addr,0,phy_data);
+
+
+    star_nic_read_phy(phy_addr,9,&phy_data);
+    //printf("\n phy.reg9=0x%04x",phy_data);
+
+  
+#endif	
+#endif // CONFIG_STAR_NIC_PHY_IP1001
+/* robin 080102 - end of modification */
+
+
+
+	phy_config |= (0x1 << 8); // AN On
+	//phy_config &= ~(0x1 << 8); // AN off
+
+	if (!((phy_config >> 8) & 0x1)) { // AN disbale
+		// Force to FullDuplex mode
+		phy_config &= ~(0x1 << 11); // Half
+
+		// Force to 100Mbps mode
+		phy_config &= ~(0x3 << 9); // clear to 10M
+		phy_config |= (0x1 << 9); // set to 100M
+	}
+
+	// Force TX FlowCtrl On,in 1000M
+	phy_config |= (0x1 << 13);
+
+	// Force TX FlowCtrl On, in 10/100M
+	phy_config |= (0x1 << 12);
+
+	// Enable MII auto polling
+	phy_config &= ~(0x1 << 7); // auto-polling enable
+	//phy_config |= (0x1 << 7); // auto-polling disable
+
+	NIC_PHY_CONTROL_REG1 = phy_config;
+#if 1
+	star_nic_phy_powerdown(dev);
+#endif
+
+	return 0;
+}
+
+static int star_nic_vlan_config(struct net_device *dev)
+{
+	u32 vlan_id;
+
+	//1.Setup MyVLAN ID0_1
+	vlan_id  = 0; //clear
+	vlan_id |= (my_vlan_id[0].vid & 0x0fff);
+	vlan_id |= ((my_vlan_id[1].vid & 0x0fff) << 16);
+	NIC_MY_VLANID_0_1 = vlan_id;
+
+	//2.Setup MyVLAN ID2_3
+	vlan_id  = 0; //clear
+	vlan_id |= (my_vlan_id[2].vid & 0x0fff);
+	vlan_id |= ((my_vlan_id[3].vid & 0x0fff) << 16);
+	NIC_MY_VLANID_2_3 = vlan_id;
+
+	//3.Setup vlan_id control bits
+	NIC_MY_VLANID_CONTROL_REG = ( (my_vlan_id[0].control << 0) |
+		(my_vlan_id[1].control << 1) |
+		(my_vlan_id[2].control << 2) |
+		(my_vlan_id[3].control << 3) );
+
+	return 0;
+}
+
+static int star_nic_arl_config(struct net_device *dev)
+{
+	u32 arl_config;
+
+	arl_config = NIC_ARL_CONFIG_REG;
+	arl_config |= (0x1 << 4); // Misc Mode ON
+	//arl_config &= ~(0x1 << 4); // Misc Mode Off
+	arl_config |= (0x1 << 3); // My MAC only enable
+	arl_config &= ~(0x1 << 2); // Learn SA On
+	arl_config &= ~(0x1 << 1); // Forward MC to CPU
+	arl_config &= ~(0x1); // Hash direct mode
+	NIC_ARL_CONFIG_REG = arl_config;
+
+	return 0;
+}
+
+#if 0
+static void star_nic_interrupt_disable(void)
+{
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_STATUS_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_TXTC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_TXQE_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+}
+#endif /* Disable function star_nic_interrupt_disable */
+
+static void star_nic_interrupt_enable(void)
+{
+#ifdef STAR_NIC_STATUS_ISR
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_STATUS_BIT_INDEX);
+#endif
+	
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+
+#ifdef STAR_NIC_RXQF_ISR
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+#endif
+}
+
+#if 0
+static int star_nic_show_rxdesc(char *page)
+{
+	int i;
+	int num = 0;
+	u32 rxsd_current;
+	int rxsd_index;
+	STAR_NIC_RXDESC volatile *rxdesc_ptr = rxring.vir_addr;
+
+	HAL_NIC_READ_RXSD(rxsd_current);
+	rxsd_index = (rxsd_current - (u32)rxring.phy_addr) >> 4;
+
+	num += sprintf(page + num, "rxring.cur_index: %d\n", rxring.cur_index);
+	num += sprintf(page + num, "rxsd_index:       %d\n", rxsd_index);
+
+	for (i = 0; i < STAR_NIC_MAX_RFD_NUM; i++) {
+		num += sprintf(page + num, "rxring[%02d].cown ==> %d\n", i, rxdesc_ptr->cown);
+		rxdesc_ptr++;
+	}
+
+	return num;
+}
+#endif /* Disable function star_nic_show_rxdesc */
+
+#if 0
+static int star_nic_show_txdesc(char *page)
+{
+	int i;
+	int num = 0;
+	u32 txsd_current;
+	int txsd_index;
+	STAR_NIC_TXDESC volatile *txdesc_ptr = txring.vir_addr;
+
+	HAL_NIC_READ_TXSD(txsd_current);
+	txsd_index = (txsd_current - (u32)txring.phy_addr) >> 4;
+
+	num += sprintf(page + num, "txring.cur_index: %d\n", txring.cur_index);
+	num += sprintf(page + num, "txsd_index:       %d\n", txsd_index);
+
+	for (i = 0; i < STAR_NIC_MAX_TFD_NUM; i++) {
+		num += sprintf(page + num, "txring[%02d].cown ==> %d\n", i, txdesc_ptr->cown);
+		txdesc_ptr++;
+	}
+
+	return num;
+}
+#endif /* star_nic_show_txdesc */
+
+static int star_nic_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+	int num = 0;
+
+	star_nic_mib_read(STAR_NIC_LAN_DEV);
+	num += sprintf(page + num, "mib_rx_ok_pkt          %08d\n", priv->mib_info.mib_rx_ok_pkt);
+	num += sprintf(page + num, "mib_rx_ok_byte         %08d\n", priv->mib_info.mib_rx_ok_byte);
+	num += sprintf(page + num, "mib_rx_runt            %08d\n", priv->mib_info.mib_rx_runt);
+	num += sprintf(page + num, "mib_rx_over_size       %08d\n", priv->mib_info.mib_rx_over_size);
+	num += sprintf(page + num, "mib_rx_no_buffer_drop  %08d\n", priv->mib_info.mib_rx_no_buffer_drop);
+	num += sprintf(page + num, "mib_rx_crc_err         %08d\n", priv->mib_info.mib_rx_crc_err);
+	num += sprintf(page + num, "mib_rx_arl_drop        %08d\n", priv->mib_info.mib_rx_arl_drop);
+	num += sprintf(page + num, "mib_rx_myvid_drop      %08d\n", priv->mib_info.mib_rx_myvid_drop);
+	num += sprintf(page + num, "mib_rx_csum_err        %08d\n", priv->mib_info.mib_rx_csum_err);
+	num += sprintf(page + num, "mib_rx_pause_frame     %08d\n", priv->mib_info.mib_rx_pause_frame);
+	num += sprintf(page + num, "mib_tx_ok_pkt          %08d\n", priv->mib_info.mib_tx_ok_pkt);
+	num += sprintf(page + num, "mib_tx_ok_byte         %08d\n", priv->mib_info.mib_tx_ok_byte);
+	num += sprintf(page + num, "mib_tx_pause_frame     %08d\n", priv->mib_info.mib_tx_pause_frame);
+
+	//num += star_nic_show_rxdesc(page + num);
+	//num += star_nic_show_txdesc(page + num);
+
+	return num;
+}
+
+
+static int
+star_nic_write_proc(struct file *file, const char __user *buffer,
+	unsigned long count, void *data)
+{
+	char *str;
+	char *cmd;
+
+	if (count > 0) {
+		str = (char *)buffer,
+		cmd = strsep(&str, "\t \n");
+		if (!cmd) goto err_out;
+		if (strcmp(cmd, "clear") == 0) {
+			struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+
+			star_nic_mib_read(STAR_NIC_LAN_DEV);
+			memset(&priv->mib_info,0,sizeof(priv->mib_info));
+
+		//} else if (strcmp(cmd, "write") == 0) {
+		} else {
+			goto err_out;
+		}
+	}
+
+	return count;
+
+err_out:
+	return -EFAULT;
+}
+
+static void star_nic_phy_powerdown(struct net_device *dev)
+{
+	struct star_nic_private *priv = netdev_priv(dev);
+	u16 phy_data = 0;
+	// power down the PHY
+	star_nic_read_phy(priv->phy_addr, 0, &phy_data);
+	phy_data |= (0x1 << 11);
+	star_nic_write_phy(priv->phy_addr, 0, phy_data);
+
+	// set hight
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+	// set low
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << 15);
+}
+
+static void star_nic_phy_powerup(struct net_device *dev)
+{
+	struct star_nic_private *priv = netdev_priv(dev);
+	u16 phy_data = 0;
+	// power up the PHY
+	star_nic_read_phy(priv->phy_addr, 0, &phy_data);
+	phy_data &= ~(0x1 << 11);
+	star_nic_write_phy(priv->phy_addr, 0, phy_data);
+
+	// set hight
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+}
+
+static void star_nic_enable(struct net_device *dev)
+{
+#if 0
+	// enable NIC clock
+	HAL_PWRMGT_ENABLE_NIC_CLOCK();
+	NIC_MAC_CONTROL_REG &= ~((u32)0x3 << 30);
+	udelay(100);
+#endif
+
+	star_nic_interrupt_enable();
+	HAL_NIC_RX_DMA_START();
+#if 1
+	star_nic_phy_powerup(dev);
+#endif
+#ifdef CONFIG_INTERNEL_PHY_PATCH
+	printk("%s: starting patch check.\n", __FUNCTION__);
+	internal_phy_patch_check(1);
+	mod_timer(&internal_phy_timer, jiffies + INTERNAL_PHY_PATCH_CHECK_PERIOD / 10);
+#endif
+
+}
+
+static void star_nic_shutdown(struct net_device *dev)
+{
+	if (install_isr_account == 0) {
+		DBG_PRINT("disable port 0\n");
+		HAL_NIC_RX_DMA_STOP();
+		HAL_NIC_TX_DMA_STOP();
+#if 0
+		NIC_MAC_CONTROL_REG |= ((u32)0x1 << 31);
+		while (!(NIC_MAC_CONTROL_REG & (0x1 << 29))) {
+			udelay(1000);
+		}
+		HAL_PWRMGT_DISABLE_NIC_CLOCK();
+		NIC_MAC_CONTROL_REG |= (0x1 <<29);
+#endif
+#ifdef CONFIG_INTERNEL_PHY_PATCH
+	printk("%s: stoping patch check.\n", __FUNCTION__);
+	del_timer_sync(&internal_phy_timer);
+#endif
+	}
+}
+
+IRQ_RETURN star_nic_receive_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+#ifdef CONFIG_STAR_NIC_NAPI
+	if (!test_bit(5, &STAR_NIC_LAN_DEV->state)) 
+	  napi_schedule(&priv->napi);
+#else
+#ifndef CONFIG_VIC_INTERRUPT
+	// TODO: mask interrupt
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_RXRC_BIT_INDEX);
+#endif
+	// MASK Interrupt
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+
+	star_nic_receive_packet(0); // Receive Once
+
+	// TODO: unmask interrupt
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+#endif
+
+	return IRQ_HANDLED;
+}
+
+#ifdef STAR_NIC_RXQF_ISR
+IRQ_RETURN star_nic_rxqf_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+#ifndef CONFIG_VIC_INTERRUPT
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_RXQF_BIT_INDEX);
+#endif
+#ifdef CONFIG_STAR_NIC_NAPI
+	// because in normal state, fsql only invoke once and set_bit is atomic function.
+	// so I don't mask it.
+	set_bit(0, (unsigned long *)&is_qf);
+	if (!test_bit(5, &STAR_NIC_LAN_DEV->state)) 
+	  napi_schedule(&priv->napi);
+#else
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+	
+	star_nic_receive_packet(1); // Receive at Queue Full Mode
+
+	// TODO: unmask interrupt
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_PM
+int inline str8100_nic_resume();
+int inline str8100_nic_suspend(suspend_state_t state);
+#endif
+
+#ifdef STAR_NIC_STATUS_ISR
+
+IRQ_RETURN star_nic_status_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 int_status;
+#ifdef CONFIG_PM
+	extern int nic_suspended;
+	u32 nic_suspended_tmp=nic_suspended;
+#endif
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_STATUS_BIT_INDEX);
+	HAL_NIC_READ_INTERRUPT_STATUS(int_status);
+
+	//printk("%s: NIC status:%08X \n",__FUNCTION__, int_status);
+
+	if (int_status & 0x8) {
+		star_nic_mib_read((struct net_device *)STAR_NIC_LAN_DEV);
+	}
+
+#ifdef CONFIG_PM
+	if ((int_status & 0x10)&&nic_suspended_tmp) {
+//		printk("W\n");
+		str8100_nic_resume();
+	}
+#endif
+	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCES(int_status);
+#ifdef CONFIG_PM
+	if ((int_status & 0x10)&&nic_suspended_tmp) {
+		str8100_nic_suspend(0);
+	}
+#endif
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_NIC_STATUS_BIT_INDEX);
+
+	return IRQ_HANDLED;
+}
+#endif // STAR_NIC_STATUS_ISR
+
+static int star_nic_uninstall_isr(struct net_device *dev)
+{
+	--install_isr_account;
+
+	if (install_isr_account == 0) {
+		printk("star nic uninstall isr\n");
+		free_irq(INTC_NIC_RXRC_BIT_INDEX, STAR_NIC_LAN_DEV);
+
+#ifdef STAR_NIC_RXQF_ISR
+		free_irq(INTC_NIC_RXQF_BIT_INDEX, STAR_NIC_LAN_DEV);
+#endif
+
+#ifdef STAR_NIC_STATUS_ISR
+		free_irq(INTC_NIC_STATUS_BIT_INDEX, STAR_NIC_LAN_DEV);
+#endif
+	}
+
+	return 0;
+}
+
+static int star_nic_install_isr(struct net_device *dev)
+{
+	int retval;
+
+	if (install_isr_account == 0) {
+#ifdef STAR_NIC_DELAYED_INTERRUPT
+		NIC_DELAYED_INT_CONFIG_REG = (1 << 16) | ((MAX_PEND_INT_CNT & 0xFF) << 8) | (MAX_PEND_TIME & 0xFF);
+#endif
+		retval = request_irq(INTC_NIC_RXRC_BIT_INDEX, &star_nic_receive_isr, IRQF_SHARED, "NIC RXRC INT", STAR_NIC_LAN_DEV);
+
+		if (retval) {
+			DO_PRINT("%s: unable to get IRQ %d (irqval=%d).\n", "NIC RXRC INT", INTC_NIC_RXRC_BIT_INDEX, retval);
+			return 1;
+		}
+
+#ifdef STAR_NIC_RXQF_ISR
+		/*  QUEUE full interrupt handler */
+		retval = request_irq(INTC_NIC_RXQF_BIT_INDEX, &star_nic_rxqf_isr, IRQF_SHARED, "NIC RXQF INT", STAR_NIC_LAN_DEV);
+
+		if (retval) {
+			DO_PRINT("%s: unable to get IRQ %d (irqval=%d).\n", "NIC RXQF INT", INTC_NIC_RXQF_BIT_INDEX, retval);
+			return 2;
+		}
+#endif	
+
+#ifdef STAR_NIC_STATUS_ISR
+		/*  NIC Status interrupt handler */
+		retval = request_irq(INTC_NIC_STATUS_BIT_INDEX, &star_nic_status_isr, IRQF_SHARED, "NIC STATUS", STAR_NIC_LAN_DEV);
+
+		if (retval) {
+			DO_PRINT("%s: unable to get IRQ %d (irqval=%d).\n", "NIC STATUS INT", INTC_NIC_STATUS_BIT_INDEX, retval);
+			return 3;
+		}
+		//HAL_NIC_ENABLE_ALL_INTERRUPT_STATUS_SOURCES();
+		HAL_NIC_DISABLE_ALL_INTERRUPT_STATUS_SOURCES();
+		//Enable NIC Status Interrupt: MIB counter th (3)
+		HAL_NIC_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(3);
+
+#endif
+	} // end if(install_isr_account == 0)
+
+	++install_isr_account;
+
+	return 0;
+}
+
+static int star_nic_lan_open(struct net_device *dev)
+{
+	DBG_PRINT("%s:star_nic_lan_open\n", dev->name);
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	//CUR_NAPI_DEV = dev;
+	//
+	struct star_nic_private *priv = netdev_priv(dev);
+	napi_enable(&priv->napi);
+
+	netif_start_queue(dev);
+
+	star_nic_install_isr(dev);
+
+	star_nic_enable(dev);
+
+	return 0;
+}
+
+static struct net_device_stats *star_nic_get_stats(struct net_device *dev)
+{
+	struct star_nic_private *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static void star_nic_timeout(struct net_device *dev)
+{
+	DBG_PRINT("%s:star_nic_timeout\n", dev->name);
+	netif_wake_queue(dev);
+	dev->trans_start = jiffies;
+}
+
+static int star_nic_close(struct net_device *dev)
+{
+#if 1
+	star_nic_phy_powerdown(dev);
+#endif
+	star_nic_uninstall_isr(dev);
+
+/* plany add 20080904 */
+#ifdef CONFIG_STAR_NIC_NAPI
+	struct star_nic_private *priv = netdev_priv(dev);
+	napi_disable(&priv->napi);
+#endif
+	netif_stop_queue(dev);
+	star_nic_shutdown(dev);
+
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	//CUR_NAPI_DEV = STAR_NIC_LAN_DEV;
+
+	return 0;
+}
+
+static inline struct sk_buff *star_nic_alloc_skb(void)
+{
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(MAX_PACKET_LEN + 2);
+
+	if (unlikely(!skb)) {
+		printk("\n dev_alloc_skb fail!! while allocate RFD ring !!\n");
+		return NULL;
+	}
+
+	/* Make buffer alignment 2 beyond a 16 byte boundary
+	 * this will result in a 16 byte aligned IP header after
+	 * the 14 byte MAC header is removed
+	 */
+	skb_reserve(skb, 2);	/* 16 bit alignment */
+
+	return skb;
+}
+
+static void __init star_nic_buffer_free(void)
+{
+	int i;
+
+	if (rxring.vir_addr) {
+		for (i = 0; i < STAR_NIC_MAX_RFD_NUM; i++) {
+			if (rxring.skb_ptr[i]) {
+				dev_kfree_skb(rxring.skb_ptr[i]);
+			}
+		}
+		dma_free_coherent(NULL, STAR_NIC_MAX_RFD_NUM * sizeof(STAR_NIC_RXDESC), rxring.vir_addr, rxring.phy_addr);
+		memset((void *)&rxring, 0, STAR_NIC_MAX_RFD_NUM * sizeof(STAR_NIC_RXDESC));
+	}
+
+	if (txring.vir_addr) {
+		dma_free_coherent(NULL, STAR_NIC_MAX_TFD_NUM * sizeof(STAR_NIC_TXDESC), txring.vir_addr, txring.phy_addr);
+		memset((void *)&txring, 0, STAR_NIC_MAX_TFD_NUM * sizeof(STAR_NIC_TXDESC));
+	}
+}
+
+static int __init star_nic_buffer_alloc(void)
+{
+	STAR_NIC_RXDESC	volatile *rxdesc_ptr;
+	STAR_NIC_TXDESC	volatile *txdesc_ptr;
+	struct sk_buff	*skb_ptr;
+	int err;
+	int i;
+
+	rxring.vir_addr = dma_alloc_coherent(NULL, STAR_NIC_MAX_RFD_NUM * sizeof(STAR_NIC_RXDESC), &rxring.phy_addr, GFP_KERNEL);
+	if (!rxring.vir_addr) {
+		printk("\n ERROR: Allocate RFD Failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	txring.vir_addr = dma_alloc_coherent(NULL, STAR_NIC_MAX_TFD_NUM * sizeof(STAR_NIC_TXDESC), &txring.phy_addr, GFP_KERNEL);
+	if (!txring.vir_addr) {
+		printk("\n ERROR: Allocate TFD Failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	// Clean RX Memory
+	memset((void *)rxring.vir_addr, 0, STAR_NIC_MAX_RFD_NUM * sizeof(STAR_NIC_RXDESC));
+	DBG_PRINT("    rxring.vir_addr=0x%08X rxring.phy_addr=0x%08X\n", (u32)rxring.vir_addr, (u32)rxring.phy_addr);
+	rxring.cur_index = 0;	// Set cur_index Point to Zero
+	rxdesc_ptr = rxring.vir_addr;
+	for (i = 0; i < STAR_NIC_MAX_RFD_NUM; i++, rxdesc_ptr++) {
+		if (i == (STAR_NIC_MAX_RFD_NUM - 1)) { 
+			rxdesc_ptr->eor = 1;	// End bit == 0;
+		}
+		skb_ptr = star_nic_alloc_skb();
+		if (!skb_ptr) {
+			printk("ERROR: Allocate skb Failed!\n");
+			err = -ENOMEM;
+			goto err_out;
+		}
+		// Trans Packet from Virtual Memory to Physical Memory
+		rxring.skb_ptr[i]	= skb_ptr;
+		rxdesc_ptr->data_ptr	= (u32)virt_to_phys(skb_ptr->data);
+		rxdesc_ptr->length	= MAX_PACKET_LEN;
+	}
+
+	// Clean TX Memory
+	memset((void *)txring.vir_addr, 0, STAR_NIC_MAX_TFD_NUM * sizeof(STAR_NIC_TXDESC));
+	DBG_PRINT("    txring.vir_addr=0x%08X txring.phy_addr=0x%08X\n", (u32)txring.vir_addr, (u32)txring.phy_addr);
+	txring.cur_index = 0;	// Set cur_index Point to Zero
+	txdesc_ptr = txring.vir_addr;
+	for (i = 0; i < STAR_NIC_MAX_TFD_NUM; i++, txdesc_ptr++) {
+		if (i == (STAR_NIC_MAX_TFD_NUM - 1)) { 
+			txdesc_ptr->eor = 1;	// End of Ring ==1
+		}
+		txdesc_ptr->cown = 1;	// TX Ring , Cown == 1
+
+#ifdef STAR_NIC_TX_HW_CHECKSUM
+		// Enable Checksum
+		txdesc_ptr->ico		= 1;
+		txdesc_ptr->uco		= 1;
+		txdesc_ptr->tco		= 1;
+#else
+		txdesc_ptr->ico		= 0;
+		txdesc_ptr->uco		= 0;
+		txdesc_ptr->tco		= 0;
+#endif
+		txring.skb_ptr[i] 	= NULL;	// clear txring.skb_ptr
+	}
+
+	return 0;
+
+err_out:
+	star_nic_buffer_free();
+	return err;
+}
+
+
+#ifdef CONFIG_STAR_JUMBO
+#define MINIMUM_ETHERNET_FRAME_SIZE	64
+#define MAX_JUMBO_FRAME_SIZE		2036
+#define ENET_HEADER_SIZE			14
+#define ETHERNET_FCS_SIZE			4
+#define ETHERNET_VLAN_SIZE			4
+#define NET_IP_ALIGN				2
+static int
+str8100_change_mtu(struct net_device *netdev, int new_mtu)
+{
+printk("%s: new_mtu=%d\n",__FUNCTION__,new_mtu);
+	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE+ETHERNET_VLAN_SIZE;
+	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
+	    (max_frame > MAX_JUMBO_FRAME_SIZE)) {
+		printk("%s: Invalid MTU setting (%d)\n",__FUNCTION__,new_mtu);
+		return -EINVAL;
+	}
+	netdev->mtu = new_mtu;
+
+//	star_nic_buffer_free();
+//	star_nic_buffer_alloc();
+
+//	if (netif_running(netdev))
+//		e1000_reinit_locked(adapter);
+
+	return 0;
+
+}
+#endif
+
+#ifdef CONFIG_STAR_NIC_NAPI
+#if 1
+static int star_nic_poll(struct napi_struct *napi, int budget)
+{
+	struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+        int work_done = 0;
+        int work_to_do = budget;
+
+	star_nic_receive_packet(0, &work_done, work_to_do);
+
+        budget -= work_done;
+
+        /* if no Tx and not enough Rx work done, exit the polling mode */
+        if (work_done) {
+                if (test_bit(0, (unsigned long *)&is_qf) == 1) { // queue full
+                        clear_bit(0, (unsigned long *)&is_qf);
+                        HAL_NIC_RX_DMA_START();
+                        return 1;
+                }
+        } else {
+		napi_complete(&priv->napi);
+#ifdef CONFIG_STAR_NIC_NAPI_MASK_IRQ
+		enable_irq(INTC_NIC_RXRC_BIT_INDEX);
+#endif
+                return 0;
+        }
+
+        return work_done;
+}
+#else
+static int star_nic_poll(struct net_device *netdev, int *budget)
+{
+	struct star_nic_private *priv = netdev_priv(STAR_NIC_LAN_DEV);
+	int work_done = 0;
+	int work_to_do = min(*budget, netdev->quota); // where is min define
+
+	star_nic_receive_packet(0, &work_done, work_to_do);
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+
+	/* if no Tx and not enough Rx work done, exit the polling mode */
+	if (work_done) {
+		if (test_bit(0, (unsigned long *)&is_qf) == 1) { // queue full
+			clear_bit(0, (unsigned long *)&is_qf);
+			HAL_NIC_RX_DMA_START();
+			return 1;
+		}
+	} else {
+		napi_complete(&priv->napi);
+#ifdef CONFIG_STAR_NIC_NAPI_MASK_IRQ
+		enable_irq(INTC_NIC_RXRC_BIT_INDEX);
+#endif
+		return 0;
+	}
+	return 1;
+}
+#endif
+#endif
+
+static int star_nic_get_rfd_buff(int index)
+{
+	struct star_nic_private *priv;
+	STAR_NIC_RXDESC volatile *rxdesc_ptr;
+	struct sk_buff *skb_ptr;
+	unsigned char *data;
+	int len;
+
+	//TODO: get rxdesc ptr
+	rxdesc_ptr = rxring.vir_addr + index;
+	skb_ptr = rxring.skb_ptr[index];
+#ifdef CONFIG_STAR_JUMBO
+	if (rxdesc_ptr->fs != 1 || rxdesc_ptr->ls != 1) {
+		goto freepacket;
+	}
+#endif
+	len = rxdesc_ptr->length;
+
+	//dma_cache_maintenance(skb_ptr->data, len, PCI_DMA_FROMDEVICE);
+	fa_dma_inv_range(skb_ptr->data, (unsigned long)skb_ptr->data + len);
+
+	data = skb_put(skb_ptr, len);
+
+	skb_ptr->dev = STAR_NIC_LAN_DEV;
+
+	priv = netdev_priv(skb_ptr->dev);
+
+#ifdef STAR_NIC_RX_HW_CHECKSUM
+	if (rxdesc_ptr->ipf == 1 || rxdesc_ptr->l4f == 1) {
+		if (rxdesc_ptr->prot != 0x11) {
+			skb_ptr->ip_summed = CHECKSUM_NONE;
+		} else {
+			// CheckSum Fail
+			priv->stats.rx_errors++;
+			goto freepacket;
+		}
+	} else {
+			skb_ptr->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+#else
+	skb_ptr->ip_summed = CHECKSUM_NONE;
+#endif
+
+	// this line must, if no, packet will not send to network layer
+	skb_ptr->protocol = eth_type_trans(skb_ptr, skb_ptr->dev);
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+	skb_ptr->dev->last_rx = jiffies;
+
+	// if netif_rx any package, will let this driver core dump.
+#ifdef CONFIG_STAR_NIC_NAPI
+	netif_receive_skb(skb_ptr);
+#else
+	netif_rx(skb_ptr);
+#endif
+
+	return 0;
+
+freepacket:
+	dev_kfree_skb_any(skb_ptr);
+	return 0;
+}
+
+#ifdef CONFIG_STAR_NIC_NAPI
+void star_nic_receive_packet(int mode, int *work_done, int work_to_do)
+#else
+void star_nic_receive_packet(int mode)
+#endif
+{
+	int rxsd_index;
+	u32 rxsd_current;
+	STAR_NIC_RXDESC volatile *rxdesc_ptr = rxring.vir_addr + rxring.cur_index;
+	struct sk_buff *skb_ptr;
+#ifndef CONFIG_STAR_NIC_NAPI
+	int rxqf = 0; // Queue Full Mode =0
+#endif
+	int i, rxcount = 0;
+	HAL_NIC_READ_RXSD(rxsd_current);
+	rxsd_index = (rxsd_current - (u32)rxring.phy_addr) >> 4;
+
+	if (rxsd_index > rxring.cur_index) {
+		rxcount = rxsd_index - rxring.cur_index;
+	} else if (rxsd_index < rxring.cur_index) {
+		rxcount = (STAR_NIC_MAX_RFD_NUM - rxring.cur_index) + rxsd_index;
+	} else {
+		if (rxdesc_ptr->cown == 0) {
+			goto receive_packet_exit;
+		} else {
+			// Queue Full
+#ifndef CONFIG_STAR_NIC_NAPI
+			rxqf = 1;
+#endif
+			rxcount = STAR_NIC_MAX_RFD_NUM;
+		}
+	}
+
+#ifndef CONFIG_STAR_NIC_NAPI
+	if (mode == 1) {
+		rxqf = 1;
+		rxcount = STAR_NIC_MAX_RFD_NUM;
+	}
+#endif
+
+	for (i = 0; i < rxcount; i++) {
+#ifdef CONFIG_STAR_NIC_NAPI
+		if (*work_done >= work_to_do)
+			break;
+		++(*work_done);
+#endif
+		if (rxdesc_ptr->cown != 0) {
+			// Alloc New skb_buff 
+			skb_ptr = star_nic_alloc_skb();
+			// Check skb_buff
+			if (skb_ptr != NULL) {
+				star_nic_get_rfd_buff(rxring.cur_index);
+				rxring.skb_ptr[rxring.cur_index] = skb_ptr;
+				rxdesc_ptr->data_ptr	= (u32)virt_to_phys(skb_ptr->data);
+				rxdesc_ptr->length	= MAX_PACKET_LEN;	
+				rxdesc_ptr->cown	= 0; // set cbit to 0 for CPU Transfer	
+			} else {
+				// TODO:
+				// I will add dev->lp.stats->rx_dropped, it will effect the performance
+				DBG_PRINT("%s: Alloc sk_buff fail, reuse the buffer\n", __FUNCTION__);
+				rxdesc_ptr->cown	= 0; // set cbit to 0 for CPU Transfer	
+				return;
+			}
+		} else {
+			//printk("[KC_DEBUG] star_nic_receive_packet() encounter COWN==0 BUG\n");
+		}
+
+		if (rxring.cur_index == (STAR_NIC_MAX_RFD_NUM - 1)) {
+			rxring.cur_index	= 0;
+			rxdesc_ptr		= rxring.vir_addr;
+		} else {
+			rxring.cur_index++;
+			rxdesc_ptr++;
+		}
+	}
+
+#ifndef CONFIG_STAR_NIC_NAPI
+	if (rxqf) {
+		rxring.cur_index = rxsd_index;
+		mb();
+		HAL_NIC_RX_DMA_START();
+	}
+#endif
+
+receive_packet_exit:
+	return;
+}
+
+#ifdef FREE_TX_SKB_MULTI
+#define FREE_TX_SKB_MULTI_MAX   16
+#define MAX_TX_SKB_FREE_NUM     FREE_TX_SKB_MULTI_MAX + MAX_SKB_FRAGS
+#endif
+
+#define FIX_NFS
+static int star_nic_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	struct star_nic_private *priv = netdev_priv(dev);
+	STAR_NIC_TXDESC volatile *txdesc_ptr;
+	unsigned long flags;
+
+#ifdef FREE_TX_SKB_MULTI
+	int i;
+	int tssd_index;
+	int tssd_current;
+	int skb_free_count = 0;
+	struct sk_buff *skb_free[MAX_TX_SKB_FREE_NUM];
+#endif
+
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	int org_index;
+	int cur_index;
+
+
+	unsigned int f;
+	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+	unsigned int len = skb->len - skb->data_len;
+	int padding_size = ETH_ZLEN - len;
+	unsigned int offset;
+
+
+#ifndef FREE_TX_SKB_MULTI
+	int skb_free_count = 0;
+	struct sk_buff *skb_free[MAX_SKB_FRAGS];
+#endif
+#else
+#ifndef FREE_TX_SKB_MULTI
+	struct sk_buff *skb_free;
+#endif
+#endif
+
+	spin_lock_irqsave(&star_nic_send_lock, flags);
+
+#ifdef FREE_TX_SKB_MULTI
+		int count = 0;
+
+		for (i = 0; i < FREE_TX_SKB_MULTI_MAX; i++) {
+			txdesc_ptr = txring.vir_addr + txring.to_free_index;
+			if (txdesc_ptr->cown == 0) {
+				break;
+			}
+			if (txring.skb_ptr[txring.to_free_index]) {
+				skb_free[count++] = txring.skb_ptr[txring.to_free_index];
+				txring.skb_ptr[txring.to_free_index] = NULL;
+			}
+
+			increase_cyclic(txring.to_free_index, STAR_NIC_MAX_TFD_NUM);
+
+			if (count == FREE_TX_SKB_MULTI_MAX) {
+				break;
+			}
+		}
+		skb_free_count = count;
+#endif
+
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	org_index = txring.cur_index;
+	cur_index = txring.cur_index;
+	for (f = 0; f < (nr_frags + 1); f++) {
+		txdesc_ptr = txring.vir_addr + cur_index;
+
+		if (txdesc_ptr->cown == 0) {
+			spin_unlock_irqrestore(&star_nic_send_lock, flags);
+#ifdef FREE_TX_SKB_MULTI
+			for (i = 0; i < skb_free_count; i++) {
+				dev_kfree_skb(skb_free[i]);
+			}
+#endif
+			/* Not enough tx buffer, re-queue the skb.             */
+			return NETDEV_TX_BUSY;
+		}
+
+		if (txring.skb_ptr[cur_index]) {
+			skb_free[skb_free_count++] = txring.skb_ptr[cur_index];
+		}
+
+#if defined(FREE_TX_SKB_MULTI) || defined(STAR_NIC_TIMER)
+		if(cur_index==txring.to_free_index)
+			increase_cyclic(txring.to_free_index, STAR_NIC_MAX_TFD_NUM);
+#endif
+
+		if (f == 0) {
+			txdesc_ptr->fs		= 1;
+		} else {
+			txdesc_ptr->fs		= 0;
+		}
+		if (f == nr_frags) {
+			txdesc_ptr->ls		= 1;
+		} else {
+			txdesc_ptr->ls		= 0;
+		}
+
+		increase_cyclic(cur_index, STAR_NIC_MAX_TFD_NUM);
+	}
+
+	txdesc_ptr = (txring.vir_addr + txring.cur_index);
+	txdesc_ptr->data_ptr			= virt_to_phys(skb->data);
+
+	if ((nr_frags == 0) && (len < PKT_MIN_SIZE)) {
+		txdesc_ptr->length		= PKT_MIN_SIZE;
+		memset(skb->data + len, 0x00, PKT_MIN_SIZE - len);
+	} else {
+		txdesc_ptr->length		= len;
+	}
+
+	if (nr_frags) {
+		txring.skb_ptr[txring.cur_index]	= NULL;
+	} else {
+		txring.skb_ptr[txring.cur_index]	= skb;
+	}
+	//dma_cache_maintenance(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+	fa_dma_clean_range(skb->data, (unsigned long)skb->data + txdesc_ptr->length);
+
+	increase_cyclic(txring.cur_index, STAR_NIC_MAX_TFD_NUM);
+
+	for (f = 0; f < nr_frags; f++) {
+		struct skb_frag_struct *frag; 
+		txdesc_ptr = txring.vir_addr + txring.cur_index;
+		frag = &skb_shinfo(skb)->frags[f]; 
+#if 1
+		padding_size -= frag->size;
+
+		//txdesc_ptr->data_ptr = virt_to_phys(page_address(frag->page) + frag->page_offset);
+		txdesc_ptr->data_ptr = virt_to_phys(sg_virt(frag));
+		txdesc_ptr->length = frag->size;
+#else
+		len = frag->size; 
+		//offset = frag->page_offset; 
+
+		//txdesc_ptr->data_ptr = virt_to_phys(page_address(frag->page) + offset);
+		txdesc_ptr->data_ptr = virt_to_phys(sg_virt(frag));
+		txdesc_ptr->length = len;
+#endif // FIX_NFS
+
+		if (f == (nr_frags - 1)) {
+			txring.skb_ptr[txring.cur_index] = skb;
+		} else {
+			txring.skb_ptr[txring.cur_index] = NULL;
+		}
+		//dma_cache_maint(page_address(frag->page) + offset, txdesc_ptr->length, PCI_DMA_TODEVICE);
+		// dma_cache_maintenance(sg_virt(frag), txdesc_ptr->length, PCI_DMA_TODEVICE);
+		fa_dma_clean_range(sg_virt(frag), (unsigned long)sg_virt(frag)+txdesc_ptr->length);
+
+		increase_cyclic(txring.cur_index, STAR_NIC_MAX_TFD_NUM);
+		
+		if (padding_size > 0)
+		/* Padding zero to the end of packet to meet minimum 
+		 * packet size requirement.                       */
+			txdesc_ptr->length += padding_size;
+	}
+
+	for (f = 0; f < (nr_frags + 1); f++) {
+		txdesc_ptr = txring.vir_addr + org_index;
+		txdesc_ptr->cown = 0;
+		org_index++;
+		if (org_index == STAR_NIC_MAX_TFD_NUM) {
+			org_index = 0;
+		}
+	}
+
+
+
+#else
+	txdesc_ptr = txring.vir_addr + txring.cur_index;
+
+	if (txdesc_ptr->cown == 0) { // This TFD is busy
+		spin_unlock_irqrestore(&star_nic_send_lock, flags);
+		// re-queue the skb
+		return 1;
+	}
+
+#ifndef FREE_TX_SKB_MULTI
+	if (txring.skb_ptr[txring.cur_index]) {
+		// MUST TODO: Free skbuff
+		skb_free = txring.skb_ptr[txring.cur_index];
+	}
+#endif
+
+	txdesc_ptr->fs		= 1;
+	txdesc_ptr->ls		= 1;
+
+	txring.skb_ptr[txring.cur_index]	= skb;
+	txdesc_ptr->data_ptr			= virt_to_phys(skb->data);
+	if (skb->len < PKT_MIN_SIZE) {
+		txdesc_ptr->length		= PKT_MIN_SIZE;
+		memset(skb->data + skb->len, 0x00, PKT_MIN_SIZE - skb->len);
+	} else {
+		txdesc_ptr->length		= skb->len;
+	}
+
+	//dma_cache_maintenance(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+	fa_dma_clean_range(skb->data, (unsigned long)skb->data+txdesc_ptr->length);
+
+	increase_cyclic(txring.cur_index, STAR_NIC_MAX_TFD_NUM);
+
+	txdesc_ptr->cown	= 0;
+#endif
+
+	mb();
+	HAL_NIC_TX_DMA_START();
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	dev->trans_start = jiffies;
+
+	spin_unlock_irqrestore(&star_nic_send_lock, flags);
+
+#ifdef FREE_TX_SKB_MULTI
+	for (i = 0; i < skb_free_count; i++) {
+		dev_kfree_skb(skb_free[i]);
+	}
+#else
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	for (f = 0; f < skb_free_count; f++) {
+		dev_kfree_skb(skb_free[f]);
+	}
+#else
+	if (skb_free) {
+		dev_kfree_skb(skb_free);
+	}
+#endif
+#endif
+
+	return NETDEV_TX_OK;
+
+#else
+	struct star_nic_private *priv = netdev_priv(dev);
+	STAR_NIC_TXDESC volatile *txdesc_ptr = (txring.vir_addr + txring.cur_index);
+	struct sk_buff *skb_free = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&star_nic_send_lock, flags);
+
+	if (txdesc_ptr->cown == 0) { // This TFD is busy
+		spin_unlock_irqrestore(&star_nic_send_lock, flags);
+		// re-queue the skb
+		return NETDEV_TX_BUSY;
+	}
+
+	if (txdesc_ptr->data_ptr != 0) {
+		// MUST TODO: Free skbuff
+		skb_free = txring.skb_ptr[txring.cur_index];
+#ifdef STAR_NIC_TIMER
+		txring.to_free_index = txring.cur_index + 1;
+		if (txring.to_free_index == STAR_NIC_MAX_TFD_NUM) {
+			txring.to_free_index = 0;
+		}
+#endif
+	}
+
+#ifdef STAR_NIC_TX_HW_CHECKSUM
+	if (skb->protocol == __constant_htons(ETH_P_IP)) {
+		if (skb->nh.iph->protocol == IPPROTO_UDP) {
+			txdesc_ptr->uco = 1;
+			txdesc_ptr->tco = 0;
+			//printk("[KC DEBUG] UDP PACKET\n");
+		} else if (skb->nh.iph->protocol == IPPROTO_TCP) {
+			txdesc_ptr->uco = 0;
+			txdesc_ptr->tco = 1;
+			//printk("[KC DEBUG] TCP PACKET\n");
+		} else {
+			txdesc_ptr->uco = 0;
+			txdesc_ptr->tco = 0;
+			//printk("[KC DEBUG] NOT TCP&UDP PACKET\n");
+		}
+	} else {
+#if 0
+		if (skb->protocol == __constant_htons(ETH_P_ARP)) {
+			printk("[KC DEBUG] ARP PACKET\n");
+		} else {
+			printk("[KC DEBUG] NOT IP PACKET\n");
+		}
+#endif
+		txdesc_ptr->ico = 0;
+		txdesc_ptr->uco = 0;
+		txdesc_ptr->tco = 0;
+	}
+#endif
+
+	txring.skb_ptr[txring.cur_index]	= skb;
+	txdesc_ptr->data_ptr			= virt_to_phys(skb->data);
+	if (skb->len < PKT_MIN_SIZE) {
+		txdesc_ptr->length		= PKT_MIN_SIZE;
+		memset(skb->data + skb->len, 0x00, PKT_MIN_SIZE - skb->len);
+	} else {
+		txdesc_ptr->length		= skb->len;
+	}
+
+	//dma_cache_maintenance(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+	fa_dma_clean_range(skb->data, (unsigned long)skb->data+txdesc_ptr->length);
+
+	txdesc_ptr->fs		= 1;
+	txdesc_ptr->ls		= 1;
+	// Wake interrupt
+	txdesc_ptr->intr	= 0;
+	txdesc_ptr->cown	= 0;
+
+	mb();
+	HAL_NIC_TX_DMA_START();
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	dev->trans_start = jiffies;
+
+	if (txring.cur_index == (STAR_NIC_MAX_TFD_NUM - 1)) {
+		txring.cur_index = 0;
+	} else {
+		txring.cur_index++;
+	}
+
+	spin_unlock_irqrestore(&star_nic_send_lock, flags);
+	if (skb_free) {
+		dev_kfree_skb(skb_free);
+	}
+
+#ifdef STAR_NIC_TIMER
+	mod_timer(&star_nic_timer, jiffies + 10);
+#endif
+	return NETDEV_TX_OK;
+#endif
+}
+
+static void star_nic_set_mac_addr(struct net_device *dev, const char *mac_addr)
+{
+	memcpy(dev->dev_addr, mac_addr, 6);
+
+	NIC_MY_MAC_HIGH_BYTE_REG =
+	       	(mac_addr[0] << 8) |
+		 mac_addr[1];
+
+	NIC_MY_MAC_LOW_BYTE_REG =
+	       	(mac_addr[2] << 24) |
+		(mac_addr[3] << 16) |
+		(mac_addr[4] << 8)  |
+		(mac_addr[5]);
+
+	printk("MAC Addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+		mac_addr[0],
+		mac_addr[1],
+		mac_addr[2],
+		mac_addr[3],
+		mac_addr[4],
+		mac_addr[5]);
+}
+
+static int star_nic_set_lan_mac_addr(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock_addr = addr;
+	struct star_nic_private *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+	star_nic_set_mac_addr(dev, sock_addr->sa_data);
+	spin_unlock_irq(&priv->lock);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int nic_suspended=0;
+void inline str8100_wol_enter(){
+
+	//stop tx dma
+	HAL_NIC_TX_DMA_STOP();
+	//Enable Internal Loopback mode
+	NIC_TEST_1_REG|=(0x1<<18);
+
+	//WoL
+	NIC_MAC_CONTROL_REG |= (0x1 << 30); //assert WoL bit
+
+
+	while (!((NIC_MAC_CONTROL_REG>>29)&0x1)){
+		udelay(500);
+		NIC_MAC_CONTROL_REG |= (0x1 << 30); //assert WoL bit
+		NIC_MAC_CONTROL_REG &= ~(0x1 << 30); //de-assert WoL bit
+		NIC_MAC_CONTROL_REG |= (0x1 << 30); //assert WoL bit
+		udelay(500);
+
+//		if((NIC_TEST_1_REG&(0x1fff))!=4096){
+//printk("%.8x\n",NIC_TEST_1_REG);
+			u32 test=0;
+			test=test=NIC_TEST_1_REG;
+//		}
+	}
+	//Disable Internal Loopback mode
+	NIC_TEST_1_REG&=~(0x1<<18);
+
+	//Enable Magic packet received of Nic status Int	
+	HAL_NIC_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(4);
+
+	NIC_MAC_CONTROL_REG |= (0x1 <<29);//write "1" clear
+	HAL_PWRMGT_DISABLE_NIC_CLOCK();
+}
+
+void inline str8100_wol_exit(){
+	HAL_NIC_DISABLE_INTERRUPT_STATUS_SOURCE_BIT(4);
+	HAL_PWRMGT_ENABLE_NIC_CLOCK();
+	NIC_MAC_CONTROL_REG &= ~(0x1 << 30); //de-assert power down bit
+
+	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCES((0x1<<4));
+	HAL_NIC_TX_DMA_START();
+}
+
+int inline str8100_nic_suspend(suspend_state_t state)
+{
+	if(!netif_running(STAR_NIC_LAN_DEV)) return 0;
+	nic_suspended=1;
+
+#ifdef CONFIG_PM_DEBUG
+	printk("%s:\n",__FUNCTION__);
+#endif
+	netif_device_detach(STAR_NIC_LAN_DEV);
+/*
+	if (netif_running(STAR_NIC_LAN_DEV)) {
+		WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
+		e1000_down(adapter);
+	}
+*/
+	str8100_wol_enter();
+	return 0;
+}
+int inline str8100_nic_resume()
+{
+	//Waked
+	if(!nic_suspended) return 0;
+	nic_suspended=0;
+#ifdef CONFIG_PM_DEBUG
+	printk("%s:\n",__FUNCTION__);
+#endif
+/*	if (netif_running(STAR_NIC_LAN_DEV))
+		e1000_up(adapter);
+*/
+	netif_device_attach(STAR_NIC_LAN_DEV);
+
+	str8100_wol_exit();	
+
+	return 0;
+}
+#endif
+
+static int star_nic_init(struct net_device *dev)
+{
+#if 1
+	// set hight
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+	// set low
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << 15);
+	// set high
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+#endif
+
+#if 1
+	// set NIC clock to 67.5MHz
+	PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 7);
+#else
+	// set NIC clock to 125MHz
+	PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 << 7);
+#endif
+
+	// enable NIC clock
+	HAL_PWRMGT_ENABLE_NIC_CLOCK();
+	//NIC_MAC_CONTROL_REG = 0x00527C00;
+	udelay(100);
+
+	// Configure GPIO for NIC MDC/MDIO pins
+	HAL_MISC_ENABLE_MDC_MDIO_PINS();
+	HAL_MISC_ENABLE_NIC_COL_PINS();
+#ifdef CONFIG_STAR_NIC_PHY_INTERNAL_PHY
+	MISC_GPIOA_PIN_ENABLE_REG |= (0x7 << 22);
+	MISC_FAST_ETHERNET_PHY_CONFIG_REG |=  (FE_PHY_LED_MODE >> 12) & 0x3;
+
+	// set hight
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+	// set low
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << 15);
+	// set high
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 15);
+#else
+	//Enable GPIO for NIC LED
+	HAL_MISC_ENABLE_LED012_PINS();
+#endif
+
+	// disable all interrupt status sources
+	HAL_NIC_DISABLE_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// clear previous interrupt sources
+	HAL_NIC_CLEAR_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// disable all DMA-related interrupt sources
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_TXTC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_TXQE_BIT_INDEX);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_NIC_RXQF_BIT_INDEX);
+
+	// clear previous interrupt sources
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_TXTC_BIT_INDEX);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_RXRC_BIT_INDEX);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_TXQE_BIT_INDEX);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_NIC_RXQF_BIT_INDEX);
+
+	HAL_NIC_TX_DMA_STOP();
+	HAL_NIC_RX_DMA_STOP();
+
+	if (star_nic_buffer_alloc() != 0) {
+		return -1;
+	}
+	star_nic_mac_config(dev);
+	star_nic_fc_config(dev);
+
+	if (star_nic_phy_config(dev) != 0) {
+		star_nic_buffer_free();
+		return -1;
+	}
+
+	star_nic_vlan_config(dev);
+	star_nic_arl_config(dev);
+
+	/* MAC address is already in MAC registers from TS-BOOTROM */
+	default_mac_addr[0] = NIC_MY_MAC_HIGH_BYTE_REG >> 8;
+	default_mac_addr[1] = NIC_MY_MAC_HIGH_BYTE_REG;
+	default_mac_addr[2] = NIC_MY_MAC_LOW_BYTE_REG >> 24;
+	default_mac_addr[3] = NIC_MY_MAC_LOW_BYTE_REG >> 16;
+	default_mac_addr[4] = NIC_MY_MAC_LOW_BYTE_REG >> 8;
+	default_mac_addr[5] = NIC_MY_MAC_LOW_BYTE_REG;
+
+	star_nic_set_mac_addr(dev, default_mac_addr);
+	star_nic_mib_reset();
+
+	*(u32 volatile *)(SYSVA_MISC_BASE_ADDR+0x0c) = 0x00000125;    //0x00000105 pb0_nic
+
+	HAL_NIC_WRITE_TXSD(txring.phy_addr);
+	HAL_NIC_WRITE_TX_BASE(txring.phy_addr);
+	HAL_NIC_WRITE_RXSD(rxring.phy_addr);
+	HAL_NIC_WRITE_RX_BASE(rxring.phy_addr);
+
+	star_nic_dma_config(dev);
+
+	return 0;
+}
+
+static void set_multicast_list(struct net_device *dev) {
+}
+
+static const struct net_device_ops star_ops = {
+        .ndo_open               = star_nic_lan_open,
+        .ndo_stop               = star_nic_close,
+        .ndo_start_xmit         = star_nic_send_packet,
+        .ndo_get_stats          = star_nic_get_stats,
+        .ndo_set_multicast_list = set_multicast_list,
+        .ndo_tx_timeout         = star_nic_timeout,
+        .ndo_change_mtu         = eth_change_mtu,
+        .ndo_set_mac_address    = star_nic_set_lan_mac_addr,
+        .ndo_validate_addr      = eth_validate_addr,
+};
+
+static int __init star_nic_probe(int port_type)
+{
+	struct net_device *netdev;
+	struct star_nic_private *priv;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(struct star_nic_private));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+
+	priv = netdev_priv(netdev);
+	memset(priv, 0, sizeof(struct star_nic_private));
+	spin_lock_init(&priv->lock);
+
+	netdev->base_addr		= SYSVA_NIC_BASE_ADDR;
+	netdev->netdev_ops = &star_ops;
+
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	netdev->features                = NETIF_F_IP_CSUM | NETIF_F_SG;
+#elif defined(STAR_NIC_TX_HW_CHECKSUM)
+	netdev->features                = NETIF_F_IP_CSUM;
+#endif
+#ifdef CONFIG_STAR_NIC_NAPI
+	netif_napi_add(netdev, &priv->napi, star_nic_poll, 64);
+#else
+	netdev->poll			= star_nic_poll;
+	netdev->weight			= 64;
+#endif
+	priv->dev_index			= LAN_PORT;
+
+#ifdef CONFIG_STAR_JUMBO
+	#error fix me
+	netdev->change_mtu = &str8100_change_mtu;
+#endif
+
+	err = register_netdev(netdev);
+	if (err) {
+		goto err_register_netdev;
+	}
+
+	//SET_MODULE_OWNER(netdev);
+
+	STAR_NIC_LAN_DEV = netdev;
+
+	if ((err = star_nic_init(netdev))) {
+		goto err_nic_init;
+	}
+
+	return 0;
+
+err_register_netdev:
+	free_netdev(netdev);
+	return err;
+
+err_nic_init:
+	unregister_netdev(netdev);
+	return err;
+
+err_alloc_etherdev:
+	return err;
+}
+
+static int __init star_nic_lan_init(void)
+{
+	return star_nic_probe(LAN_PORT);
+}
+
+static int __init star_nic_proc_init(void)
+{
+	star_nic_proc_entry = create_proc_entry("str8100/nic", S_IFREG | S_IRUGO, NULL);
+	if (star_nic_proc_entry) {
+		star_nic_proc_entry->read_proc = star_nic_read_proc;
+		star_nic_proc_entry->write_proc = star_nic_write_proc;
+	}
+
+	return 0;
+}
+
+static int __init star_nic_init_module(void)
+{
+	int err = 0;
+
+	printk(KERN_INFO "%s", star_nic_driver_version);
+	spin_lock_init(&star_nic_send_lock);
+	err = star_nic_lan_init();
+	if (err != 0) {
+		return err;
+	}
+	star_nic_proc_init();
+
+	printk("\n");
+#ifdef CONFIG_INTERNEL_PHY_PATCH
+	printk("%s: internal phy patch included.\n",__FUNCTION__);
+	//str813x_internal_phy_proc_init();
+#elif defined(CONFIG_STAR_NIC_PHY_INTERNAL_PHY)
+	printk("%s: internal phy used but no patch included.\n",__FUNCTION__);
+#endif
+#if defined(STAR_NIC_TX_HW_CHECKSUM) && defined(MAX_SKB_FRAGS) && defined(STAR_NIC_SG)
+	printk("%s: scatter/gather enabled.\n",__FUNCTION__);
+#else
+	printk("%s: scatter/gather disabled.\n",__FUNCTION__);
+#endif
+	printk("\n");
+
+#ifdef STAR_NIC_TIMER
+	init_timer(&star_nic_timer);
+	star_nic_timer.function = &star_nic_timer_func;
+	star_nic_timer.data = (unsigned long)NULL;
+#endif
+
+	return 0;
+}
+
+module_init(star_nic_init_module);
+
+//========================================================
+#ifdef CONFIG_INTERNEL_PHY_PATCH
+
+static void (*phy_statemachine)(int, int, int);
+
+#define ETH3220_PHY_MON_PERIOD INTERNAL_PHY_PATCH_CHECK_PERIOD
+
+/*===================================================================================*/
+/*  phy monitor state  */
+#define NUM_PHY 1
+#define PHY_STATE_INIT					0
+#define LINK_DOWN_POSITIVE				1
+#define WAIT_LINK_UP_POSITIVE				2
+#define LINK_UP_POSITIVE				3
+#define WAIT_BYPASS_LINK_UP_POSITIVE			4
+#define BYPASS_AND_LINK_UP_POSITIVE			5
+#define LINK_UP_8101_POSITIVE				6
+#define WAIT_8101_LINK_UP_POSITIVE			7
+
+#define PHY_STATE_LAST					(WAIT_8101_LINK_UP_POSITIVE+1)
+/*===================================================================================*/
+/*  time setting  */
+#define WAIT_BYPASS_LINK_UP_POSITIVE_TIMEOUT		5000	/*  5000 ms  */
+#define WAIT_BYPASS_LINK_UP_NEGATIVE_TIMEOUT		5000	/*  5000 ms  */
+#define LINK_DOWN_ABILITY_DETECT_TIMEOUT		5000	/*  5000 ms  */
+#define DETECT_8101_PERIOD				7000	/*  7000 ms  */
+#define WAIT_8101_LINK_UP_TIMEOUT			3000	/*  3000 ms  */
+
+#define MAX_PHY_PORT					1
+#define DEFAULT_AGC_TRAIN				16
+#define MAX_AGC_TRAIN					16	//train 16 times
+static int agc_train_num = DEFAULT_AGC_TRAIN;
+u32 port_displaybuf[NUM_PHY][MAX_AGC_TRAIN + 1] = {{0}};
+
+static int cuv[3][3] = {
+	{1, 1, 4},
+	{1, 1, 0},
+	{1, 1, -4}};
+static u32 link_status_old = 0;
+//static int agc_th[2] = {0x18, 0x28}; /* To be deleted */
+//static u32 phy_mon_timer; /* To be deleted */
+//static u32 current_agc = 0;   //0:Not patch, 1:patch
+/*===================================================================================*/
+
+typedef struct eth3220_phy_s {
+	u16 state;
+	u16 linkdown_cnt;
+	u32 state_time;
+	u32 timer;
+} eth3220_phy_t;
+
+#define DEBUG_PHY_STATE_TRANSITION			1
+#if DEBUG_PHY_STATE_TRANSITION
+/*  show state transition of debug phy port.
+ *  -1 for all ports
+ *  -2 for disable all ports
+ *  0 - 4 for each port  */
+static int debug_phy_port = -2;
+static char *phystate_name[] = {
+	"init",			/*  PHY_STATE_INIT  */
+	"ldp",			/*  LINK_DOWN_POSITIVE  */
+	"wait_lup",		/*  WAIT_LINK_UP_POSITIVE  */
+	"lup",			/*  LINK_UP_POSITIVE  */
+	"wait_bp_lup",		/*  WAIT_BYPASS_LINK_UP_POSITIVE  */
+	"bp_lup",		/*  BYPASS_AND_LINK_UP_POSITIVE  */
+	"8101_lup",		/*  LINK_UP_8101_POSITIVE  */
+	"wait_8101_lup",	/*  WAIT_8101_LINK_UP_POSITIVE  */
+	"err",
+};
+#endif  /*  DEBUG_PHY_STATE_TRANSITION  */
+static eth3220_phy_t phy[5] = { {PHY_STATE_INIT, 0, 0, 0},
+				{PHY_STATE_INIT, 0, 0, 0},
+				{PHY_STATE_INIT, 0, 0, 0},
+				{PHY_STATE_INIT, 0, 0, 0},
+				{PHY_STATE_INIT, 0, 0, 0}};
+
+static u16 long_cable_global_reg[32]={
+0x0000,0x19a0,0x1d00,0x0e80,0x0f60,0x07c0,0x07e0,0x03e0,
+0x0000,0x0000,0x0000,0x2000,0x8250,0x1700,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x204b,0x01c2,0x0000,
+0x0000,0x0000,0x0fff,0x4100,0x9319,0x0021,0x0034,0x270a|FE_PHY_LED_MODE
+};
+
+static u16 long_cable_local_reg[32]={
+0x3100,0x786d,0x01c1,0xca51,0x05e1,0x45e1,0x0003,0x001c,
+0x2000,0x9828,0xf3c4,0x400c,0xf8ff,0x6940,0xb906,0x503c,
+0x8000,0x297a,0x1010,0x5010,0x6ae1,0x7c73,0x783c,0xfbdf,
+0x2080,0x3244,0x1301,0x1a80,0x8e8f,0x8000,0x9c29,0xa70a|FE_PHY_LED_MODE
+};
+
+static void internal_phy_update(unsigned long data)
+{
+	internal_phy_patch_check(0);
+	mod_timer(&internal_phy_timer, jiffies + INTERNAL_PHY_PATCH_CHECK_PERIOD / 10);
+}
+
+static struct timer_list internal_phy_timer =
+	TIMER_INITIALIZER(internal_phy_update, 0, 0);
+
+/*=============================================================*
+ *  eth3220ac_rt8101_phy_setting
+ *=============================================================*/
+static  void eth3220ac_rt8101_phy_setting(int port)
+{
+	star_nic_write_phy(port, 12, 0x18ff);
+	star_nic_write_phy(port, 18, 0x6400);
+}
+
+static void eth3220ac_release_bpf(int port)
+{
+	star_nic_write_phy(port, 18, 0x6210);
+}
+
+static  void eth3220ac_def_bpf(int port)
+{
+	star_nic_write_phy(port, 18, 0x6bff);
+}
+
+static  void eth3220ac_def_linkdown_setting(int port)
+{
+	star_nic_write_phy(port, 13, 0xe901);
+	star_nic_write_phy(port, 14, 0xa3c6);
+}
+
+static  void eth3220ac_def_linkup_setting(int port)
+{
+	star_nic_write_phy(port, 13, 0x6901);
+	star_nic_write_phy(port, 14, 0xa286);
+}
+
+/*=============================================================*
+ *  eth3220ac_link_agc:
+ *=============================================================*/
+static int eth3220ac_link_agc(int port, int speed)
+{
+	u16 reg;
+	u32 agc_data = 0;
+	u32 short_cable;
+	int i, jj;
+
+	/* if speed = 100MHz, then continue */
+	if (speed == 0)
+		return 0;
+
+	short_cable = 0;
+	jj = 0;
+	for (i=0; i < agc_train_num; i++) {
+		star_nic_read_phy(port, 15, &reg);
+		reg &= 0x7f;
+		if (reg <= 0x12) {
+			short_cable = 1;
+			jj++;
+			agc_data += (u32)reg;
+		}
+	}
+	if (short_cable) {
+		agc_data = (agc_data / jj) + 4;
+	} else {
+		agc_data = (cuv[2][0] * agc_data) / cuv[2][1] / agc_train_num - 4;
+	}
+
+	/*  Fix AGC  */
+	agc_data = 0xd0 | (agc_data << 9);
+	star_nic_write_phy(port, 15, agc_data);
+	udelay(1000);
+	star_nic_read_phy(port, 15, &reg);
+	reg &= ~(0x1 << 7);
+	star_nic_write_phy(port, 15, reg);
+
+	return 0;
+}
+
+/*=============================================================*
+ *  eth3220ac_unlink_agc:
+ *=============================================================*/
+static void eth3220ac_unlink_agc(int port)
+{
+	// start AGC adaptive
+	star_nic_write_phy(port, 15, 0xa050);
+}
+
+/*=============================================================*
+ *  eth3220ac_rt8100_check
+ *=============================================================*/
+static int eth3220ac_rt8100_check(int port)
+{
+	u16 reg, reg2;
+
+	/* Read reg27 (error register) */
+	star_nic_read_phy(port, 27, &reg);
+	/* if error exists, set Bypass Filter enable */
+	if ((reg & 0xfffc)) {
+                star_nic_read_phy(port, 15, &reg);	
+                star_nic_read_phy(port, 27, &reg2);	
+		if (( reg2 & 0xfffc) && (((reg >> 9) & 0xff) < 0x1c)) {
+			printk("8100 pos err\n");
+			/* Bypass agcgain disable */
+			star_nic_write_phy(port, 15, (reg & (~(0x1 << 7))));
+			
+			/* repeat counts when reaching threshold error */
+			star_nic_write_phy(port, 13, 0x4940);
+			
+			/* Speed up AN speed && compensate threshold phase error */
+			star_nic_write_phy(port, 14, 0xa306);
+			
+			/* Bypass Filter enable */
+                        star_nic_read_phy(port, 18, &reg2);	
+
+			star_nic_write_phy(port, 18, (reg | 0x400));
+			
+			/* restart AN */
+			star_nic_write_phy(port, 0, 0x3300);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+
+/*=============================================================*
+ *  eth3220ac_rt8100_linkdown
+ *=============================================================*/
+static void eth3220ac_rt8100_linkdown(int port)
+{
+	u16 reg;
+	
+	/* Bypass Filter disable */
+	star_nic_read_phy(port, 18, &reg);	
+	star_nic_write_phy(port, 18, (reg & (~(0x1 << 10))));
+	eth3220ac_def_linkdown_setting(port);
+}
+
+static void eth3220ac_normal_phy_setting(int port)
+{
+	star_nic_write_phy(port, 12, 0xd8ff);
+	eth3220ac_def_bpf(port);
+}
+
+/*=============================================================*
+ *  wp3220ac_phystate
+ *=============================================================*/
+static void wp3220ac_phystate(int port, int link, int speed)
+{
+	int next_state;
+	u16 reg, reg2;	
+
+	phy[port].timer += ETH3220_PHY_MON_PERIOD;
+	
+	if (link) {
+		/*  Link up state  */
+		switch(phy[port].state) {
+		case LINK_UP_POSITIVE:
+			next_state = eth3220ac_rt8100_check(port) ?
+				WAIT_BYPASS_LINK_UP_POSITIVE :
+				LINK_UP_POSITIVE;
+			break;
+			
+		case PHY_STATE_INIT:
+		case WAIT_LINK_UP_POSITIVE:
+		case LINK_DOWN_POSITIVE:
+			next_state = LINK_UP_POSITIVE;
+			eth3220ac_def_linkup_setting(port);
+			eth3220ac_link_agc(port, speed);
+			eth3220ac_release_bpf(port);
+			break;
+			
+		case WAIT_BYPASS_LINK_UP_POSITIVE:
+		case BYPASS_AND_LINK_UP_POSITIVE:
+			next_state = BYPASS_AND_LINK_UP_POSITIVE;
+			break;
+			
+		case WAIT_8101_LINK_UP_POSITIVE:
+			next_state = LINK_UP_8101_POSITIVE;
+			eth3220ac_link_agc(port, speed);
+			star_nic_write_phy(port, 12, 0x98ff);
+			break;
+			
+		case LINK_UP_8101_POSITIVE:
+			next_state = LINK_UP_8101_POSITIVE;
+			break;
+			
+		default:
+			next_state = LINK_UP_POSITIVE;
+			eth3220ac_def_linkup_setting(port);
+			eth3220ac_link_agc(port, speed);
+		}
+	} else {
+		/*  Link down state  */
+		switch(phy[port].state) {
+		case LINK_DOWN_POSITIVE:
+                        star_nic_read_phy(port, 5, &reg);	
+                        star_nic_read_phy(port, 28, &reg2);	
+			/* AN Link Partner Ability Register or NLP */
+			if (reg || (reg2 & 0x100))
+				next_state = WAIT_LINK_UP_POSITIVE;
+			else
+				next_state = LINK_DOWN_POSITIVE;
+			break;
+			
+		case WAIT_LINK_UP_POSITIVE:
+			if (phy[port].state_time > LINK_DOWN_ABILITY_DETECT_TIMEOUT)
+				next_state = LINK_DOWN_POSITIVE;
+			else
+				next_state = WAIT_LINK_UP_POSITIVE;
+			break;
+			
+		case WAIT_BYPASS_LINK_UP_POSITIVE:
+			/* set timeout = 5 sec */
+			if (phy[port].state_time > WAIT_BYPASS_LINK_UP_POSITIVE_TIMEOUT) {
+				next_state = LINK_DOWN_POSITIVE;
+				/* Bypass Filter disable */
+				eth3220ac_rt8100_linkdown(port);
+				eth3220ac_def_bpf(port);
+			} else {
+				next_state = WAIT_BYPASS_LINK_UP_POSITIVE;
+			}
+			break;
+			
+		case BYPASS_AND_LINK_UP_POSITIVE:
+			next_state = LINK_DOWN_POSITIVE;
+			eth3220ac_rt8100_linkdown(port);
+			eth3220ac_def_bpf(port);
+			break;
+			
+		case WAIT_8101_LINK_UP_POSITIVE:
+			if (phy[port].state_time > WAIT_8101_LINK_UP_TIMEOUT) {
+				next_state = LINK_DOWN_POSITIVE;
+				eth3220ac_normal_phy_setting(port);
+				eth3220ac_def_linkdown_setting(port);
+			} else {
+				next_state = WAIT_8101_LINK_UP_POSITIVE;
+			}
+			break;
+			
+		case LINK_UP_POSITIVE:
+			eth3220ac_unlink_agc(port);
+			eth3220ac_def_linkdown_setting(port);
+			eth3220ac_def_bpf(port);
+			if (phy[port].timer > DETECT_8101_PERIOD) {
+				next_state = LINK_DOWN_POSITIVE;
+				phy[port].timer = 0;
+				phy[port].linkdown_cnt = 1;
+			} else {
+				if (++phy[port].linkdown_cnt > 2) {
+					next_state = WAIT_8101_LINK_UP_POSITIVE;
+					eth3220ac_rt8101_phy_setting(port);
+				} else {
+					next_state = LINK_DOWN_POSITIVE;
+				}
+			}
+			break;
+			
+		case LINK_UP_8101_POSITIVE:
+			eth3220ac_normal_phy_setting(port);
+			/*  fall down to phy normal state  */
+		case PHY_STATE_INIT:
+			eth3220ac_def_linkdown_setting(port);
+			eth3220ac_unlink_agc(port);
+		default:
+			next_state = LINK_DOWN_POSITIVE;
+		}
+	}
+	
+	if (phy[port].state != next_state) {
+		phy[port].state_time = 0;
+#if DEBUG_PHY_STATE_TRANSITION
+		if (debug_phy_port == -1 || port == debug_phy_port)
+		{
+			if ((phy[port].state < PHY_STATE_LAST) && (next_state < PHY_STATE_LAST))
+			{
+				printk("p%d: %s->%s, %d, %d\n", port, phystate_name[phy[port].state],
+					phystate_name[next_state], phy[port].timer, phy[port].linkdown_cnt);
+			}
+			else
+			{
+				printk("p%d: %d->%d\n", port, phy[port].state, next_state);
+			}
+		}
+#endif   /*  DEBUG_PHY_STATE_TRANSITION  */
+	} else {
+		phy[port].state_time += ETH3220_PHY_MON_PERIOD;
+	}
+	phy[port].state = next_state;
+}
+
+/*=============================================================*
+ *  eth3220_phyinit:
+ *=============================================================*/
+static void eth3220ac_10m_agc(void)
+{
+	/* Force 10M AGC = 2c globally */
+	star_nic_write_phy(0, 31, 0x2f1a);
+	star_nic_write_phy(0, 12, 0x112c);
+	star_nic_write_phy(0, 13, 0x2e21);
+	star_nic_write_phy(0, 31, 0xaf1a);
+}
+
+static void eth3220ac_dfe_init(void)
+{
+	int i;
+
+	star_nic_write_phy(0, 31, 0x2f1a);
+	for (i=0; i <= 7; i++)
+		star_nic_write_phy(0, i, 0);
+	star_nic_write_phy(0, 11, 0x0b50);
+	star_nic_write_phy(0, 31, 0xaf1a);
+}
+
+static void eth3220ac_phy_cdr_training_init(void)
+{
+	int volatile i;
+
+	/* Force all port in 10M FD mode */
+	for (i=0; i < NUM_PHY; i++)
+		star_nic_write_phy(i, 0, 0x100);
+	
+	/* Global setting */
+	star_nic_write_phy(0, 31, 0x2f1a);
+	star_nic_write_phy(0, 29, 0x5021);
+        udelay(2000); //2ms, wait > 1 ms
+	star_nic_write_phy(0, 29, 0x4021);
+        udelay(2000); //2ms, wait > 1 ms
+	star_nic_write_phy(0, 31, 0xaf1a);
+
+	/* Enable phy AN */
+	for (i=0; i < NUM_PHY; i++)
+		star_nic_write_phy(i, 0, 0x3100);	
+}
+
+static void eth3220_phyinit(void)
+{
+	eth3220ac_10m_agc();
+	eth3220ac_dfe_init();
+	eth3220ac_phy_cdr_training_init();
+}
+
+static void eth3220_phycfg(int phyaddr)
+{
+	eth3220ac_def_linkdown_setting(phyaddr);
+	eth3220ac_normal_phy_setting(phyaddr);
+	star_nic_write_phy(phyaddr, 9, 0x7f);
+}
+
+static void internal_phy_patch_check(int init)
+{
+	u32 short_cable_agc_detect_count;
+	u32 link_status = 0, link_speed;
+	u32 ii, jj;
+	u16 phy_data;
+	u16 phy_data2;
+
+	star_nic_read_phy(STAR_NIC_PHY_ADDR, 1, &phy_data);
+	udelay(100);
+	star_nic_read_phy(STAR_NIC_PHY_ADDR, 1, &phy_data2);
+	if (((phy_data & 0x0004) != 0x0004) && ((phy_data2 & 0x0004) != 0x0004)) { // link down
+		short_cable_agc_detect_count = 0;
+		for (jj = 0; jj < INTERNAL_PHY_PATCH_CHECKCNT; jj++) {
+			star_nic_read_phy(STAR_NIC_PHY_ADDR, 15, &phy_data);
+			udelay(1000);
+			if (((phy_data) & 0x7F) <= 0x12) { // short cable
+				short_cable_agc_detect_count++;
+				break;
+			}
+		}
+		if (short_cable_agc_detect_count) { // short cable
+			phy_statemachine = wp3220ac_phystate;
+			eth3220_phyinit();
+			star_nic_read_phy(STAR_NIC_PHY_ADDR, 1, &phy_data);
+			if (phy_data & 0x0040) { // link up
+				link_status = 1;
+			}
+			if ((NIC_MAC_CONTROL_REG & 0xC) == 0x4) { // 100Mbps
+				link_speed = 1;
+			} else {
+				link_speed = 0;
+			}
+			link_status_old = link_status;
+			for (ii = 0; ii < MAX_PHY_PORT; link_status >>= 1, ii++) {
+				eth3220_phycfg(ii);
+#if 0
+				if (phy_statemachine != NULL)
+					(*phy_statemachine)(ii, link_status & 1, link_speed & 1);
+#endif
+			}
+		} else { // long cable
+			// set to global domain
+			star_nic_write_phy(NIC_PHY_ADDRESS, 31, 0x2f1a);
+			for (ii = 0; ii < 32; ii++) {
+				star_nic_write_phy(NIC_PHY_ADDRESS, ii, long_cable_global_reg[ii]);
+			}
+			// set to local domain
+			star_nic_write_phy(NIC_PHY_ADDRESS, 31, 0xaf1a);
+			for (ii = 0; ii < 32; ii++) {
+				star_nic_write_phy(NIC_PHY_ADDRESS, ii, long_cable_local_reg[ii]);
+			}
+		}
+	}
+}
+
+#endif
+//========================================================
diff -Nur linux-2.6.35.11/drivers/net/str9100/dorado2.h linux-2.6.35.11-ts7500//drivers/net/str9100/dorado2.h
--- linux-2.6.35.11/drivers/net/str9100/dorado2.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/dorado2.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,223 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef  DORADO2_H
+#define  DORADO2_H
+
+#include <linux/types.h>
+
+// this configure is for star dorado2
+
+// add by descent 2006/07/10
+#define DORADO2
+
+// add by KC 2006/09/07
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+// if no VSC8201 on MAC PORT1, we need to define this
+// if VSC8201 is present, mark it
+//#define DORADO2_PCI_FASTPATH_MAC_PORT1_LOOPBACK
+#endif
+
+#ifdef DORADO2
+// init phy or switch chip
+#define INIT_PORT0_PHY star_gsw_config_VSC7385();
+#ifdef DORADO2_PCI_FASTPATH_MAC_PORT1_LOOPBACK
+#define INIT_PORT1_PHY star_gsw_config_mac_port1_loopback();
+#else
+#define INIT_PORT1_PHY star_gsw_config_VSC8201(1,1);
+#endif
+//#define INIT_PORT1_PHY 
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC init_packet_forward(1);
+//#define INIT_PORT1_MAC 
+
+#define PORT0_LINK_DOWN disable_AN(0, 0);
+#define PORT0_LINK_UP disable_AN(0, 1);
+
+#ifdef DORADO2_PCI_FASTPATH_MAC_PORT1_LOOPBACK
+#define PORT1_LINK_DOWN
+#define PORT1_LINK_UP
+#else
+#define PORT1_LINK_DOWN std_phy_power_down(1, 1);
+#define PORT1_LINK_UP std_phy_power_down(1, 0);
+#endif
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 star_gsw_probe(WAN_PORT);
+#define CREATE_NET_DEV2 star_gsw_probe(EWC_PORT);
+//#define CREATE_NET_DEV2 
+
+#define CONFIG_STR9100_PORT_BASE
+#define CONFIG_STR9100_VLAN_BASE
+//#define CONFIG_HAVE_VLAN_TAG
+
+// for port base, port base max is 2 port.
+// use in star_gsw_get_rfd_buff().
+// if a port no used, define to "0;"
+// NET_DEV0 : rx->sp 0 (port 0)
+#define NET_DEV0 0
+// NET_DEV1 : rx->sp 1 (port 1)
+#define NET_DEV1 STAR_GSW_EWC_DEV
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT -1
+#define PORT_BASE_PMAP_WAN_PORT -1
+#define PORT_BASE_PMAP_EWC_PORT 2 // 2 port 1
+
+#define MODEL "DORADO2"
+
+// OPEN_PORT0 include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_EWC_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[2].vlan_mac, 6);\
+		PRINT_INFO("open mac port1\n"); \
+		mac_port_config = GSW_MAC_PORT_1_CONFIG; \
+		/* disable port 1 */  \
+		mac_port_config &= (~(0x1 << 18)); \
+		GSW_MAC_PORT_1_CONFIG = mac_port_config; \
+		PORT1_LINK_UP \
+	} \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		if (dev == STAR_GSW_LAN_DEV) \
+			memcpy(dev->dev_addr, star_gsw_info.vlan[1].vlan_mac, 6);\
+		if (dev == STAR_GSW_WAN_DEV) \
+			memcpy(dev->dev_addr, star_gsw_info.vlan[0].vlan_mac, 6);\
+		/* rc_port is a reference count variable. */ \
+	        if (rc_port == 0) {\
+        		PRINT_INFO("open mac port 0\n");\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* enable port 0 */ \
+		        mac_port_config &= (~(0x1 << 18));\
+               		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+			PORT0_LINK_UP\
+	        }\
+	        else{\
+      			PRINT_INFO("port 0 already open\n");\
+	        }\
+		++rc_port;\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_EWC_DEV) { \
+		PRINT_INFO("close mac port1\n"); \
+		PORT1_LINK_DOWN \
+		mac_port_config = GSW_MAC_PORT_1_CONFIG; \
+		/* disable port 1 */  \
+		mac_port_config |= ((0x1 << 18)); \
+		GSW_MAC_PORT_1_CONFIG = mac_port_config; \
+	} \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		--rc_port;\
+		/* rc_port is a reference count variable. */ \
+	        if (rc_port == 0) {\
+        		PRINT_INFO("close mac port 0\n");\
+			PORT0_LINK_DOWN\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* disable port 0 */ \
+		        mac_port_config |= ((0x1 << 18));\
+               		 GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	        }\
+	        else {\
+      			PRINT_INFO("a live net device\n");\
+	        }\
+	} \
+}
+
+
+
+#define VLAN0_VID			(0x2)
+#define VLAN1_VID			(0x1)
+#define VLAN2_VID			(0x3)
+#define VLAN3_VID			(0x4)
+#define VLAN4_VID			(0x5)
+#define VLAN5_VID			(0x6)
+#define VLAN6_VID			(0x7)
+#define VLAN7_VID			(0x8)
+
+#define VLAN0_GROUP			(PORT0 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(PORT1 | CPU_PORT)
+#define VLAN3_GROUP			(PORT1 | CPU_PORT)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(PORT1 | CPU_PORT)
+
+
+#ifdef CONFIG_HAVE_VLAN_TAG
+
+#define VLAN0_VLAN_TAG			(5)	// cpu port and mac 0 port
+#define VLAN1_VLAN_TAG			(5)	// cpu port and mac 0 port
+
+#else
+#define VLAN0_VLAN_TAG			(1)	// only mac 0 port
+#define VLAN1_VLAN_TAG			(1)	// only mac 0 port
+#endif
+
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+
+/* wan eth1 */
+static u8 my_vlan0_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x50};
+
+/* lan eth 0*/
+static u8 my_vlan1_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x60};
+
+/* cpu */
+static u8 my_vlan2_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x22};
+
+/* ewc  */
+static u8 my_vlan3_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x23};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 1
+#define WAN_GID 0
+
+
+#endif //DORADO2
+
+
+
+
+#endif
diff -Nur linux-2.6.35.11/drivers/net/str9100/dorado.h linux-2.6.35.11-ts7500//drivers/net/str9100/dorado.h
--- linux-2.6.35.11/drivers/net/str9100/dorado.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/dorado.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,188 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef  DORADO_H
+#define  DORADO_H
+
+int disable_AN(int port, int y);
+// this configure is for star dorado2
+
+// add by descent 2006/07/10
+#define DORADO
+#ifdef DORADO
+// init phy or switch chip
+#define INIT_PORT0_PHY star_gsw_config_VSC7385();
+#define INIT_PORT1_PHY 
+//#define INIT_PORT1_PHY 
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC 
+//#define INIT_PORT1_MAC 
+
+#define PORT0_LINK_DOWN disable_AN(0, 0);
+#define PORT0_LINK_UP disable_AN(0, 1);
+
+#define PORT1_LINK_DOWN 
+#define PORT1_LINK_UP 
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 star_gsw_probe(WAN_PORT);
+#define CREATE_NET_DEV2 
+//#define CREATE_NET_DEV2 
+
+#undef CONFIG_STR9100_PORT_BASE
+#define CONFIG_STR9100_VLAN_BASE
+#undef CONFIG_HAVE_VLAN_TAG
+
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT INVALID_PORT_BASE_PMAP_PORT
+#define PORT_BASE_PMAP_WAN_PORT INVALID_PORT_BASE_PMAP_PORT
+#define PORT_BASE_PMAP_EWC_PORT INVALID_PORT_BASE_PMAP_PORT
+
+#define MODEL "DORADO"
+
+// OPEN_PORT0 include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		if (dev == STAR_GSW_LAN_DEV) { \
+			/*printk("STAR_GSW_LAN_DEV\n"); */ \
+			/*memcpy(dev->dev_addr, star_gsw_info.vlan[LAN_GID].vlan_mac, 6);*/ \
+		} \
+		if (dev == STAR_GSW_WAN_DEV) { \
+			/* printk("STAR_GSW_WAN_DEV\n"); */ \
+			/*memcpy(dev->dev_addr, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);*/ \
+		} \
+		/* rc_port is a reference count variable. */ \
+	        if (rc_port == 0) {\
+        		PRINT_INFO("open mac port 0\n");\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* enable port 0 */ \
+		        mac_port_config &= (~(0x1 << 18));\
+               		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+			PORT0_LINK_UP\
+	        }\
+	        else{\
+      			PRINT_INFO("port 0 already open\n");\
+	        }\
+		++rc_port;\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		/* rc_port is a reference count variable. */ \
+		--rc_port;\
+	        if (rc_port == 0) {\
+        		PRINT_INFO("close mac port 0\n");\
+			PORT0_LINK_DOWN\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* disable port 0 */ \
+		        mac_port_config |= ((0x1 << 18));\
+               		 GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	        }\
+	        else {\
+      			PRINT_INFO("a live net device\n");\
+	        }\
+	} \
+}
+
+
+
+// the vlan past waht vlan tag value
+#define VLAN0_VID			(0x2) // wan
+#define VLAN1_VID			(0x1) // lan
+#define VLAN2_VID			(0x3)
+#define VLAN3_VID			(0x4)
+#define VLAN4_VID			(0x5)
+#define VLAN5_VID			(0x6)
+#define VLAN6_VID			(0x7)
+#define VLAN7_VID			(0x8)
+
+// the vlan include ports
+#define VLAN0_GROUP			(PORT0 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(0)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+
+
+#ifdef CONFIG_HAVE_VLAN_TAG
+
+// the vlan which ports will past vlan tags.
+#define VLAN0_VLAN_TAG			(5)	// cpu port and mac 0 port
+#define VLAN1_VLAN_TAG			(5)	// cpu port and mac 0 port
+
+#else
+#define VLAN0_VLAN_TAG			(1)	// only mac 0 port
+#define VLAN1_VLAN_TAG			(1)	// only mac 0 port
+#endif
+
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+
+/* wan eth1 */
+static u8 my_vlan0_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x50};
+
+/* lan eth 0*/
+static u8 my_vlan1_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x60};
+
+/* cpu */
+static u8 my_vlan2_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x22};
+
+/* ewc  */
+static u8 my_vlan3_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x23};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 1
+#define WAN_GID 0
+
+
+#endif //DORADO
+
+
+
+
+#endif
diff -Nur linux-2.6.35.11/drivers/net/str9100/Kconfig linux-2.6.35.11-ts7500//drivers/net/str9100/Kconfig
--- linux-2.6.35.11/drivers/net/str9100/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,45 @@
+menu "CNS1100 Gigabit Switch support"
+	depends on ARCH_STR9100
+
+config STAR_GSW
+	tristate "CNS1100 Gigabit Switch driver support"
+
+config STR9100_SHNAT
+	bool "CNS1100 Smart HNAT Support"
+	depends on STAR_GSW
+	help
+	  Add STAR Smart HNAT support function in kernel
+
+config STAR9100_SHNAT_PCI_FASTPATH
+	bool "FastPath(From PCI to WAN) Support"
+	depends on STR9100_SHNAT
+	help
+	  Add FastPath Support for Smart HNAT.
+
+choice
+	prompt "CNS1100 Board"
+	depends on STAR_GSW
+	default DORADO
+
+config DORADO
+	bool "Dorado"
+
+config DORADO2
+	bool "Dorado2"
+
+config VIRGO
+	bool "Virgo"
+
+config VELA
+	bool "Vela"
+
+config LIBRA
+	bool "Libra"
+
+config LEO
+	bool "Leo"
+
+endchoice
+
+endmenu
+
diff -Nur linux-2.6.35.11/drivers/net/str9100/leo.h linux-2.6.35.11-ts7500//drivers/net/str9100/leo.h
--- linux-2.6.35.11/drivers/net/str9100/leo.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/leo.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,152 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef LEO_H
+#define LEO_H
+
+// add by descent 2006/07/10
+#define LEO
+#ifdef LEO
+// init phy or switch chip
+#define INIT_PORT0_PHY star_gsw_config_VSC8201(0,0);
+#define INIT_PORT1_PHY 
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC disable_AN(1, 1);
+// if no disable_AN port 1, maybe get link up/down (change link state)
+
+#define PORT0_LINK_DOWN std_phy_power_down(0,1);
+#define PORT0_LINK_UP std_phy_power_down(0,0);
+
+#define PORT1_LINK_DOWN 
+#define PORT1_LINK_UP 
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 
+#define CREATE_NET_DEV2
+
+
+#define CONFIG_STR9100_PORT_BASE
+#undef CONFIG_STR9100_VLAN_BASE
+#undef CONFIG_HAVE_VLAN_TAG
+
+// for port base, port base max is 2 port.
+// NET_DEV0 : rx->sp 0 (port 0)
+#define NET_DEV0 STAR_GSW_LAN_DEV
+// NET_DEV1 : rx->sp 1 (port 1)
+#define NET_DEV1 0
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT PORT0
+#define PORT_BASE_PMAP_WAN_PORT INVALID_PORT_BASE_PMAP_PORT
+#define PORT_BASE_PMAP_EWC_PORT INVALID_PORT_BASE_PMAP_PORT
+
+#define MODEL "LEO"
+
+// OPEN_PORT0 include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[1].vlan_mac, 6);\
+       		PRINT_INFO("open mac port 0\n");\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* enable port 0 */ \
+	        mac_port_config &= (~(0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+		PORT0_LINK_UP\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+       		PRINT_INFO("close mac port 0\n");\
+		PORT0_LINK_DOWN\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* disable port 0 */ \
+	        mac_port_config |= ((0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	} \
+}
+
+
+#define VLAN0_VID			(0x111)
+#define VLAN1_VID			(0x222)
+#define VLAN2_VID			(0x333)
+#define VLAN3_VID			(0x444)
+#define VLAN4_VID			(0x555)
+#define VLAN5_VID			(0x666)
+#define VLAN6_VID			(0x777)
+#define VLAN7_VID			(0x888)
+
+
+#define VLAN0_GROUP			(CPU_PORT | PORT0)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+//#define VLAN0_GROUP                     (PORT0 | PORT1 | CPU_PORT)
+//#define VLAN1_GROUP                     (PORT0 | CPU_PORT)
+//#define VLAN2_GROUP                     (PORT1 | CPU_PORT)
+#define VLAN2_GROUP			(0)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+
+#define VLAN0_VLAN_TAG			(0)
+#define VLAN1_VLAN_TAG			(0)
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+//#define PORT0_PVID			(VLAN0_GROUP_ID)
+//#define PORT1_PVID			(VLAN2_GROUP_ID)
+//#define CPU_PORT_PVID			(VLAN1_GROUP_ID)
+
+static u8 my_vlan0_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x12};
+static u8 my_vlan1_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x22};
+static u8 my_vlan2_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x32};
+static u8 my_vlan3_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x42};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 0
+#define WAN_GID 2
+
+
+#endif // LEO
+
+#endif
diff -Nur linux-2.6.35.11/drivers/net/str9100/libra.h linux-2.6.35.11-ts7500//drivers/net/str9100/libra.h
--- linux-2.6.35.11/drivers/net/str9100/libra.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/libra.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef  LIBRA_H
+#define  LIBRA_H
+
+// this configure is for star LIBRA
+
+// add by descent 2006/07/10
+#define LIBRA
+#ifdef LIBRA
+// init phy or switch chip
+#define INIT_PORT0_PHY configure_icplus_175c_phy();
+#define INIT_PORT1_PHY 
+//#define INIT_PORT1_PHY 
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC 
+//#define INIT_PORT1_MAC 
+
+#define PORT0_LINK_DOWN icp_175c_all_phy_power_down(1);
+#define PORT0_LINK_UP icp_175c_all_phy_power_down(0);
+
+#define PORT1_LINK_DOWN 
+#define PORT1_LINK_UP 
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 star_gsw_probe(WAN_PORT);
+#define CREATE_NET_DEV2 
+//#define CREATE_NET_DEV2 
+
+#undef CONFIG_STR9100_PORT_BASE
+#define CONFIG_STR9100_VLAN_BASE
+#undef CONFIG_HAVE_VLAN_TAG
+#define CONFIG_HAVE_VLAN_TAG
+
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT INVALID_PORT_BASE_PMAP_PORT
+#define PORT_BASE_PMAP_WAN_PORT INVALID_PORT_BASE_PMAP_PORT
+#define PORT_BASE_PMAP_EWC_PORT INVALID_PORT_BASE_PMAP_PORT
+
+#define MODEL "LIBRA"
+
+// OPEN_PORT0 include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		if (dev == STAR_GSW_LAN_DEV) \
+			memcpy(dev->dev_addr, star_gsw_info.vlan[LAN_GID].vlan_mac, 6);\
+		if (dev == STAR_GSW_WAN_DEV) \
+			memcpy(dev->dev_addr, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);\
+		/* rc_port is a reference count variable. */ \
+	        if (rc_port == 0) {\
+        		PRINT_INFO("open mac port 0\n");\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* enable port 0 */ \
+		        mac_port_config &= (~(0x1 << 18));\
+               		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+			PORT0_LINK_UP\
+	        }\
+	        else{\
+      			PRINT_INFO("port 0 already open\n");\
+	        }\
+		++rc_port;\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV || dev == STAR_GSW_WAN_DEV) { \
+		/* rc_port is a reference count variable. */ \
+		--rc_port;\
+	        if (rc_port == 0) {\
+        		PRINT_INFO("close mac port 0\n");\
+			PORT0_LINK_DOWN\
+		        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+               		/* disable port 0 */ \
+		        mac_port_config |= ((0x1 << 18));\
+               		 GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	        }\
+	        else {\
+      			PRINT_INFO("a live net device\n");\
+	        }\
+	} \
+}
+
+
+
+// the vlan past waht vlan tag value
+#define VLAN0_VID			(0x2) // wan
+#define VLAN1_VID			(0x1) // lan
+#define VLAN2_VID			(0x3)
+#define VLAN3_VID			(0x4)
+#define VLAN4_VID			(0x5)
+#define VLAN5_VID			(0x6)
+#define VLAN6_VID			(0x7)
+#define VLAN7_VID			(0x8)
+
+// the vlan include ports
+#define VLAN0_GROUP			(PORT0 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(0)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+
+
+#ifdef CONFIG_HAVE_VLAN_TAG
+
+// the vlan which ports will past vlan tags.
+#define VLAN0_VLAN_TAG			(5)	// cpu port and mac 0 port
+#define VLAN1_VLAN_TAG			(5)	// cpu port and mac 0 port
+
+#else
+#define VLAN0_VLAN_TAG			(1)	// only mac 0 port
+#define VLAN1_VLAN_TAG			(1)	// only mac 0 port
+#endif
+
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+
+/* wan eth1 */
+static u8 my_vlan0_mac[6] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x50};
+
+/* lan eth 0*/
+static u8 my_vlan1_mac[6] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x60};
+
+/* cpu */
+static u8 my_vlan2_mac[6] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x22};
+
+/* ewc  */
+static u8 my_vlan3_mac[6] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x23};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 1
+#define WAN_GID 0
+
+
+#endif //LIBRA
+
+
+
+
+#endif
diff -Nur linux-2.6.35.11/drivers/net/str9100/Makefile linux-2.6.35.11-ts7500//drivers/net/str9100/Makefile
--- linux-2.6.35.11/drivers/net/str9100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,38 @@
+################################################################################
+#
+# 
+# Copyright(c) 2005 -  Star semiconduction. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+#
+# Makefile for the Star GSW ethernet driver
+#
+
+#obj-y :=
+#obj-m :=
+
+obj-$(CONFIG_STAR_GSW) += str9100.o
+str9100-objs := star_gsw_phy.o star_gsw.o
+
+#include $(TOPDIR)/Rules.make
diff -Nur linux-2.6.35.11/drivers/net/str9100/star_gsw.c linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw.c
--- linux-2.6.35.11/drivers/net/str9100/star_gsw.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,3421 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include "star_gsw.h"
+
+#ifdef LINUX24
+#include <asm/arch/str9100/star_tool.h>
+#include <asm/arch/str9100/star_misc.h>
+#endif
+
+#ifdef LINUX26
+#include <asm/arch/star_misc.h>
+#endif
+
+#if defined(LINUX24)
+#if defined(CONFIG_STAR9100_SHNAT_PCI_FASTPATH) 
+#include <linux/star9100/star9100_shnat.h>
+#include <linux/star9100/str9100_shnat_hook.h>
+#endif /* defined(CONFIG_STAR9100_SHNAT_PCI_FASTPATH) */
+#elif defined(LINUX26) /* defined(LINUX24) */
+#if defined(CONFIG_STR9100_SHNAT) 
+#include <linux/str9100/star9100_shnat.h>
+#include <linux/str9100/str9100_shnat_hook.h>
+#endif /* defined(CONFIG_STAR9100_SHNAT_PCI_FASTPATH) */
+#endif /* defined(LINUX24) */
+
+#if defined(LINUX24)
+#define IRQ_RETURN void
+#define IRQ_HANDLED 
+static const char star_gsw_driver_version[] =
+	"Star GSW Driver(for Linux Kernel 2.4) - Star Semiconductor\n";
+#elif defined(LINUX26)
+#define IRQ_RETURN irqreturn_t
+static const char star_gsw_driver_version[] =
+	"Star GSW Driver(for Linux Kernel 2.6) - Star Semiconductor\n";
+#endif
+
+
+#define DRV_VERSION "0.01"
+
+int all_netdevice=0;
+
+
+irqreturn_t star_gsw_receive_isr(int irq, void *dev_id, struct pt_regs *regs);
+//struct proc_dir_entry *str9100_gsw_procdir=0;
+static u32 max_pend_int_cnt=MAX_PEND_INT_CNT, max_pend_time=MAX_PEND_TIME;
+
+#define MIN_PACKET_LEN 60
+
+
+static struct net_device *STAR_GSW_LAN_DEV;
+static struct net_device *STAR_GSW_WAN_DEV;
+static struct net_device *STAR_GSW_EWC_DEV;
+
+static struct net_device *STAR_NAPI_DEV;
+
+#define NETDEV_SIZE 10
+static struct net_device *net_dev_array[NETDEV_SIZE];
+
+
+static int install_isr_account = 0;
+static int rc_port = 0; // rc mean reference counting, determine port open/close.
+static int fsrc_count = 0;
+static volatile unsigned long is_qf = 0; // determine queue full state
+
+gsw_info_t star_gsw_info;
+static spinlock_t star_gsw_send_lock;
+
+static TXRING_INFO txring;
+static RXRING_INFO rxring;
+
+static struct proc_dir_entry *star_gsw_proc_entry;
+
+#ifdef CONFIG_STAR_GSW_NAPI
+static void star_gsw_receive_packet(int mode, int *work_done, int work_to_do);
+#else
+static void star_gsw_receive_packet(int mode);
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+void gsw_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid);
+void gsw_vlan_rx_register(struct net_device *dev, struct vlan_group *grp);
+#endif
+
+static int star_gsw_notify_reboot(struct notifier_block *nb, unsigned long event, void *ptr);
+
+static struct notifier_block star_gsw_notifier_reboot = {
+	.notifier_call	= star_gsw_notify_reboot,
+	.next		= NULL,
+	.priority	= 0
+};
+
+
+
+
+#ifdef STAR_GSW_TIMER
+static struct timer_list star_gsw_timer;
+static void star_gsw_timer_func(unsigned long data)
+{
+	int i;
+	int tssd_index;
+	int tssd_current;
+	int skb_free_count = 0;
+	STAR_GSW_TXDESC volatile *txdesc_ptr;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	HAL_GSW_READ_TSSD(tssd_current);
+	tssd_index = (tssd_current - (u32)txring.phy_addr) >> 4;
+	if (tssd_index > txring.to_free_index) {
+		skb_free_count = tssd_index - txring.to_free_index;
+	} else if (tssd_index < txring.to_free_index) {
+		skb_free_count = STAR_GSW_MAX_TFD_NUM + tssd_index - txring.to_free_index;
+	}
+	for (i = 0; i < skb_free_count; i++) {
+		txdesc_ptr = txring.vir_addr + txring.to_free_index;
+		if (txdesc_ptr->cown == 0) {
+			break;
+		}
+		if (txring.skb_ptr[txring.to_free_index]) {
+			dev_kfree_skb_any(txring.skb_ptr[txring.to_free_index]);
+			txring.skb_ptr[txring.to_free_index] = NULL;
+		}
+		txring.to_free_index++;
+		if (txring.to_free_index == STAR_GSW_MAX_TFD_NUM) {
+			txring.to_free_index = 0;
+		}
+	}
+	local_irq_restore(flags);
+}
+#endif
+
+
+#define between(x, start, end) ((x)>=(start) && (x)<=(end))
+void print_packet(unsigned char *data, int len) 
+{
+    int i,j;
+
+    printk("packet length: %d%s:\n", len, len>128?"(only show the first 128 bytes)":"");
+    if(len > 128) {
+        len = 128;
+    }
+    for(i=0;len;) {
+        if(len >=16 ) {
+            for(j=0;j<16;j++) {
+                printk("%02x ", data[i++]);
+            }
+            printk("| ");
+
+            i -= 16;
+            for(j=0;j<16;j++) {
+                if( between(data[i], 0x21, 0x7e) ) {
+                    printk("%c", data[i++]);
+                }
+                else {
+                    printk(".");
+                    i++;
+                }
+            }
+            printk("\n");
+
+            len -= 16;
+        }
+        else {
+            /* last line */
+
+            for(j=0; j<len; j++) {
+                printk("%02x ", data[i++]);
+            }
+            for(;j<16;j++) {
+                printk("   ");
+            }
+            printk("| ");
+
+            i -= len;
+            for(j=0;j<len;j++) {
+                if( between(data[i], 0x21, 0x7e) ) {
+                    printk("%c", data[i++]);
+                }
+                else {
+                    printk(".");
+                    i++;
+                }
+            }
+            for(;j<16;j++) {
+                printk(" ");
+            }
+            printk("\n");
+
+            len = 0;
+        }
+    }
+    return;
+
+}
+
+// add by descent 2006/07/07
+void init_switch()
+{
+        u32 sw_config;
+
+        /*
+         * Configure GSW configuration
+         */
+        sw_config = GSW_SWITCH_CONFIG;
+
+#if 0
+        // orignal virgon configuration
+        // enable fast aging
+        sw_config |= (0xF);
+
+        // CRC stripping
+        sw_config |= (0x1 << 21);
+
+        // IVL learning
+        sw_config |= (0x1 << 22);
+        // HNAT disable
+        sw_config &= ~(0x1 << 23);
+
+        GSW_SWITCH_CONFIG = sw_config;
+
+        sw_config = GSW_SWITCH_CONFIG;
+#endif
+
+//#if 0
+        /* configure switch */
+        sw_config = GSW_SWITCH_CONFIG;
+
+        sw_config &= ~0xF;      /* disable aging */
+        sw_config |= 0x1;       /* disable aging */
+
+#ifdef JUMBO_ENABLE
+
+        // CRC stripping and GSW_CFG_MAX_LEN_JMBO
+        //sw_config |= (GSW_CFG_CRC_STRP | GSW_CFG_MAX_LEN_JMBO);
+        // CRC stripping and GSW_CFG_MAX_LEN_JMBO
+        sw_config |= ((0x1 << 21) | (0x3 << 4));
+	       
+#else
+        // CRC stripping and 1536 bytes
+        //sw_config |= (GSW_CFG_CRC_STRP | GSW_CFG_MAX_LEN_1536);
+	sw_config |= ((0x1 << 21) | (0x2 << 4));
+#endif
+
+        /* IVL */
+        //sw_config |= GSW_CFG_IVL;
+        sw_config |= (0x1 << 22);
+
+
+        /* disable HNAT */
+        //sw_config &= ~GSW_CFG_HNAT_EN;
+        sw_config &= ~(0x1 << 23);
+
+
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	// PCI FASTPATH must enable firewall mode
+	sw_config |= (0x1 << 24);
+#endif
+
+        GSW_SWITCH_CONFIG = sw_config;
+//#endif
+}
+
+
+
+static int star_gsw_write_arl_table_entry(gsw_arl_table_entry_t *arl_table_entry)
+{
+	int i;
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_0 = 0x0;
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 = 0x0;
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 = 0x0;
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 = (((arl_table_entry->filter & 0x1) << 3) |
+		((arl_table_entry->vlan_mac & 0x1) << 4) |
+		((arl_table_entry->vlan_gid & 0x7) << 5) |
+		((arl_table_entry->age_field & 0x7) << 8) |
+		((arl_table_entry->port_map & 0x7) << 11) |
+		((arl_table_entry->mac_addr[0] & 0xFF) << 16) |
+		((arl_table_entry->mac_addr[1] & 0xFF) << 24));
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 = (((arl_table_entry->mac_addr[2] & 0xFF) << 0) |
+		((arl_table_entry->mac_addr[3] & 0xFF) << 8) |
+		((arl_table_entry->mac_addr[4] & 0xFF) << 16) |
+		((arl_table_entry->mac_addr[5] & 0xFF) << 24));
+
+	// issue the write command
+	GSW_ARL_TABLE_ACCESS_CONTROL_0 = (0x1 << 3);
+
+	for (i = 0; i < 0x1000; i++) {
+		if (GSW_ARL_TABLE_ACCESS_CONTROL_1 & (0x1)) {
+			return (1);  // write OK
+		} else {
+			udelay(10);
+		}
+	}
+
+	return (0);  // write failed
+}
+
+static int star_gsw_config_cpu_port(void)
+{
+	gsw_arl_table_entry_t arl_table_entry;
+	u32 cpu_port_config;
+
+	/*
+	 * Write some default ARL table entries
+	 */
+	// default ARL entry for VLAN0
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;	// the MAC in this table entry is MY VLAN MAC
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[0].vlan_gid;
+	arl_table_entry.age_field	= 0x7;	// static entry
+	arl_table_entry.port_map	= star_gsw_info.vlan[0].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[0].vlan_mac, 6);
+	if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+		return 1;
+	}
+
+	// default ARL entry for VLAN1
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[1].vlan_gid;
+	arl_table_entry.age_field	= 0x7;
+	arl_table_entry.port_map	= star_gsw_info.vlan[1].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[1].vlan_mac, 6);
+	if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+		return 1;
+	}
+
+	// default ARL entry for VLAN2
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[2].vlan_gid;
+	arl_table_entry.age_field	= 0x7;
+	arl_table_entry.port_map	= star_gsw_info.vlan[2].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[2].vlan_mac, 6);
+	if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+		return 1;
+	}
+
+	// default ARL entry for VLAN3
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[3].vlan_gid;
+	arl_table_entry.age_field	= 0x7;
+	arl_table_entry.port_map	= star_gsw_info.vlan[3].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[3].vlan_mac, 6);
+	if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+		return 1;
+	}
+
+	GSW_SET_PORT0_PVID(star_gsw_info.port[0].pvid);
+	GSW_SET_PORT1_PVID(star_gsw_info.port[1].pvid);
+	GSW_SET_CPU_PORT_PVID(star_gsw_info.port[2].pvid);
+
+	GSW_SET_VLAN_0_VID(star_gsw_info.vlan[0].vlan_vid);
+	GSW_SET_VLAN_1_VID(star_gsw_info.vlan[1].vlan_vid);
+	GSW_SET_VLAN_2_VID(star_gsw_info.vlan[2].vlan_vid);
+	GSW_SET_VLAN_3_VID(star_gsw_info.vlan[3].vlan_vid);
+	GSW_SET_VLAN_4_VID(star_gsw_info.vlan[4].vlan_vid);
+	GSW_SET_VLAN_5_VID(star_gsw_info.vlan[5].vlan_vid);
+	GSW_SET_VLAN_6_VID(star_gsw_info.vlan[6].vlan_vid);
+	GSW_SET_VLAN_7_VID(star_gsw_info.vlan[7].vlan_vid);
+
+	GSW_SET_VLAN_0_MEMBER(star_gsw_info.vlan[0].vlan_group);
+	GSW_SET_VLAN_1_MEMBER(star_gsw_info.vlan[1].vlan_group);
+	GSW_SET_VLAN_2_MEMBER(star_gsw_info.vlan[2].vlan_group);
+	GSW_SET_VLAN_3_MEMBER(star_gsw_info.vlan[3].vlan_group);
+	GSW_SET_VLAN_4_MEMBER(star_gsw_info.vlan[4].vlan_group);
+	GSW_SET_VLAN_5_MEMBER(star_gsw_info.vlan[5].vlan_group);
+	GSW_SET_VLAN_6_MEMBER(star_gsw_info.vlan[6].vlan_group);
+	GSW_SET_VLAN_7_MEMBER(star_gsw_info.vlan[7].vlan_group);
+
+	GSW_SET_VLAN_0_TAG(star_gsw_info.vlan[0].vlan_tag_flag);
+	GSW_SET_VLAN_1_TAG(star_gsw_info.vlan[1].vlan_tag_flag);
+	GSW_SET_VLAN_2_TAG(star_gsw_info.vlan[2].vlan_tag_flag);
+	GSW_SET_VLAN_3_TAG(star_gsw_info.vlan[3].vlan_tag_flag);
+	GSW_SET_VLAN_4_TAG(star_gsw_info.vlan[4].vlan_tag_flag);
+	GSW_SET_VLAN_5_TAG(star_gsw_info.vlan[5].vlan_tag_flag);
+	GSW_SET_VLAN_6_TAG(star_gsw_info.vlan[6].vlan_tag_flag);
+	GSW_SET_VLAN_7_TAG(star_gsw_info.vlan[7].vlan_tag_flag);
+
+	// disable all interrupt status sources
+	GSW_DISABLE_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// clear previous interrupt sources
+	GSW_CLEAR_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// disable all DMA-related interrupt sources
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_FSRC_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_TSQE_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_FSQF_BIT_INDEX);
+
+	// clear previous interrupt sources
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSRC_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_TSQE_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSQF_BIT_INDEX);
+
+	GSW_TS_DMA_STOP();
+	GSW_FS_DMA_STOP();
+
+	GSW_WRITE_TSSD(txring.phy_addr);
+	GSW_WRITE_TS_BASE(txring.phy_addr);
+	GSW_WRITE_FSSD(rxring.phy_addr);
+	GSW_WRITE_FS_BASE(rxring.phy_addr);
+
+	/*
+	 * Configure CPU port
+	 */
+	cpu_port_config = GSW_CPU_PORT_CONFIG;
+
+	//SA learning Disable 
+	cpu_port_config |= (0x1 << 19);
+
+	//offset 4N +2 
+	cpu_port_config &= ~(1 << 31);
+	//cpu_port_config |= (1 << 31);
+
+	/* enable the CPU port */
+	cpu_port_config &= ~(1 << 18);
+
+	GSW_CPU_PORT_CONFIG = cpu_port_config;
+
+	return 0;
+}
+
+static void star_gsw_interrupt_disable(void)
+{
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_STATUS_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_FSRC_BIT_INDEX);
+}
+
+static void star_gsw_interrupt_enable(void)
+{
+	INTC_ENABLE_INTERRUPT_SOURCE(INTC_GSW_STATUS_BIT_INDEX);
+	// 20070321 
+	//INTC_ENABLE_INTERRUPT_SOURCE(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_ENABLE_INTERRUPT_SOURCE(INTC_GSW_FSRC_BIT_INDEX);
+}
+
+static int star_gsw_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+#if 0
+	int num = 0;
+	int ad;
+	u32 port;
+	u32 fssd_current;
+	int fssd_index, rxcount;
+	STAR_GSW_RXDESC volatile *rxdesc_ptr = (rxring.vir_addr + rxring.cur_index);
+
+	GSW_READ_FSSD(fssd_current);
+	fssd_index = (fssd_current - (u32)rxring.phy_addr) >> 4;
+
+	if (fssd_index > rxring.cur_index) {
+		rxcount = fssd_index - rxring.cur_index;
+	} else if (fssd_index < rxring.cur_index) {
+		rxcount = (STAR_GSW_MAX_RFD_NUM - rxring.cur_index) + fssd_index;
+	} else {
+		if (rxdesc_ptr->cown == 0) {
+			//goto receive_packet_exit;
+			rxcount = -1;
+		} else {
+			// Queue Full
+			rxcount = STAR_GSW_MAX_RFD_NUM;
+		}
+	}
+
+	port = GSW_MAC_PORT_0_CONFIG;
+	num = sprintf(page, "\nStar Giga Bit Switch\n");
+#ifdef CONFIG_STAR_GSW_NAPI
+	num += sprintf(page + num, "Receive Method : NAPI\n");
+#else
+	num += sprintf(page + num, "Receive Method : General\n");
+#endif
+
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	num += sprintf(page + num, "Support SHNAT PCI Fast PATH\n");
+#endif
+
+	HAL_MISC_ORION_ECO_AD(ad);
+	num += sprintf(page + num, "Orion Version: %s\n", ad==1?"AD":"AC");
+
+	num += sprintf(page + num, "GSW_DELAYED_INTERRUPT_CONFIG: %x\n", GSW_DELAYED_INTERRUPT_CONFIG);
+
+	num += sprintf(page + num, "GSW_VLAN_VID_0_1: %x\n", GSW_VLAN_VID_0_1);
+	num += sprintf(page + num, "GSW_VLAN_VID_2_3: %x\n", GSW_VLAN_VID_2_3);
+	num += sprintf(page + num, "GSW_VLAN_VID_4_5: %x\n", GSW_VLAN_VID_4_5);
+	num += sprintf(page + num, "GSW_VLAN_VID_6_7: %x\n", GSW_VLAN_VID_6_7);
+
+	num += sprintf(page + num, "STAR_GSW_LAN_DEV: %x\n", STAR_GSW_LAN_DEV);
+	num += sprintf(page + num, "STAR_GSW_WAN_DEV: %x\n", STAR_GSW_WAN_DEV);
+	num += sprintf(page + num, "GSW_VLAN_TAG_PORT_MAP: %x\n", GSW_VLAN_TAG_PORT_MAP);
+	num += sprintf(page + num, "GSW_SWITCH_CONFIG: %x \n", GSW_SWITCH_CONFIG);
+	//num += sprintf(page + num, "is_qf: %d \n", is_qf);
+	num += sprintf(page + num, "GSW_VLAN_VID_0_1: %08X \n", GSW_VLAN_VID_0_1);
+	num += sprintf(page + num, "VLAN0_VID: %d \n", VLAN0_VID);
+	num += sprintf(page + num, "VLAN1_VID: %d \n", VLAN1_VID);
+
+	num += sprintf(page + num, "GSW_QUEUE_STATUS_TEST_1  : %x \n", GSW_QUEUE_STATUS_TEST_1);
+	num += sprintf(page + num, "GW_GSW_MAX_RFD_NUM  : %d \n", STAR_GSW_MAX_RFD_NUM);
+	num += sprintf(page + num, "GW_GSW_MAX_TFD_NUM  : %d \n", STAR_GSW_MAX_TFD_NUM);
+	num += sprintf(page + num, "GSW_INTERRUPT_STATUS  : %x \n", GSW_INTERRUPT_STATUS);
+
+	num += sprintf(page + num, "MAC PORT 0   : %x \n", GSW_MAC_PORT_0_CONFIG);
+	if (port & (0x1 << 22))
+		num += sprintf(page + num, "  IVL: IVL\n");
+	else
+		num += sprintf(page + num, "  IVL: SVL\n");
+
+	port = GSW_MAC_PORT_1_CONFIG;
+	num += sprintf(page + num, "MAC PORT 1   : %x \n", GSW_MAC_PORT_1_CONFIG);
+	if (port & (0x1 << 22))
+		num += sprintf(page + num, "  IVL: IVL\n");
+	else
+		num += sprintf(page + num, "  IVL: SVL\n");
+
+	num += sprintf(page + num, " CPU PORT 1   : %x \n", GSW_CPU_PORT_CONFIG);
+
+	num += sprintf(page + num, "MODEL: %s\n", MODEL);
+#ifdef STAR_GSW_TX_HW_CHECKSUM
+	num += sprintf(page + num, "use TX hardware checksum\n");
+#endif
+#ifdef STAR_GSW_RX_HW_CHECKSUM
+	num += sprintf(page + num, "use RX hardware checksum\n");
+#endif
+
+#ifdef CONFIG_STR9100_VLAN_BASE
+	num += sprintf(page + num, "VLAN BASE\n");
+  #ifdef CONFIG_HAVE_VLAN_TAG
+	num += sprintf(page + num, "HAVE VLAN TAG\n");
+  #else
+	num += sprintf(page + num, "HAVE NO VLAN TAG\n");
+  #endif
+#endif
+
+#ifdef CONFIG_STR9100_PORT_BASE
+	num += sprintf(page + num, "PORT BASE\n");
+#endif
+
+// 20060922 descent
+#ifdef CONFIG_NIC_MODE
+	num += sprintf(page + num, "NIC MODE ON\n");
+#else
+	num += sprintf(page + num, "NIC MODE OFF\n");
+#endif
+// 20060922 descent end
+
+#ifdef STAR_GSW_SG
+	num += sprintf(page + num, "scatter gather on\n");
+#else
+	num += sprintf(page + num, "scatter gather off\n");
+#endif
+
+#ifdef FREE_TX_SKB_MULTI
+	num += sprintf(page + num, "FREE_TX_SKB_MULTI on\n");
+#else
+	num += sprintf(page + num, "FREE_TX_SKB_MULTI off\n");
+#endif
+
+#ifdef STAR_GSW_TIMER
+	num += sprintf(page + num, "STAR_GSW_TIMER on\n");
+#else
+	num += sprintf(page + num, "STAR_GSW_TIMER off\n");
+#endif
+
+
+#if 0
+	num += sprintf(page + num, "  lan (eth0) mac: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			star_gsw_info.vlan[1].vlan_mac[0],
+			star_gsw_info.vlan[1].vlan_mac[1],
+			star_gsw_info.vlan[1].vlan_mac[2],
+			star_gsw_info.vlan[1].vlan_mac[3],
+			star_gsw_info.vlan[1].vlan_mac[4],
+			star_gsw_info.vlan[1].vlan_mac[5]);
+	num += sprintf(page + num, "  wan (eth1) mac: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			star_gsw_info.vlan[0].vlan_mac[0],
+			star_gsw_info.vlan[0].vlan_mac[1],
+			star_gsw_info.vlan[0].vlan_mac[2],
+			star_gsw_info.vlan[0].vlan_mac[3],
+			star_gsw_info.vlan[0].vlan_mac[4],
+			star_gsw_info.vlan[0].vlan_mac[5]);
+#endif
+
+	return num;
+
+#endif
+
+
+	int num = 0;
+	u32 port=0;
+	const char *STR_ENABLE="Enable";
+	const char *STR_DISABLE="Disable";
+
+
+	num  = sprintf(page, "Star STR9100 Gigabit Switch Driver Information \n");
+
+	num += sprintf(page + num, "%s\n", star_gsw_driver_version);
+	num += sprintf(page + num, "Demo Board Name: %s\n", MODEL);
+#ifdef CONFIG_STAR_GSW_NAPI
+	num += sprintf(page + num, "NAPI Function : %s\n", STR_ENABLE);
+#else
+	num += sprintf(page + num, "NAPI Function : %s\n", STR_DISABLE);
+#endif
+
+	port = GSW_SWITCH_CONFIG;
+	if (port & (0x1 << 22))
+		num += sprintf(page + num, "Independent VLAN Learning(IVL) Enable\n");
+	else
+		num += sprintf(page + num, "Share VLAN Learning (SVL) Enable\n");
+
+#ifdef CONFIG_STR9100_VLAN_BASE
+	num += sprintf(page + num, "Support Tag Base VLAN , Receive packet ");
+  #ifdef CONFIG_HAVE_VLAN_TAG
+	num += sprintf(page + num, "with vlan tag\n");
+  #else
+	num += sprintf(page + num, "without vlan tag\n");
+  #endif
+#endif
+
+#ifdef CONFIG_STR9100_PORT_BASE
+	num += sprintf(page + num, "Support Port Base VLAN\n");
+#endif
+
+
+	num += sprintf(page + num, "Max Receive Ring Buffer:  %02d \n", STAR_GSW_MAX_RFD_NUM );
+	num += sprintf(page + num, "Max Send Ring Buffer:     %02d\n",  STAR_GSW_MAX_TFD_NUM );
+#ifdef STAR_GSW_TX_HW_CHECKSUM
+	num += sprintf(page + num, "TX Hardware checksum:     %s \n", STR_ENABLE);
+#else
+	num += sprintf(page + num, "TX Hardware checksum:     %s \n", STR_DISABLE);
+#endif
+#ifdef STAR_GSW_RX_HW_CHECKSUM
+	num += sprintf(page + num, "Rx Hardware checksum:     %s\n", STR_ENABLE );
+#else
+	num += sprintf(page + num, "Rx Hardware checksum:     %s\n", STR_DISABLE );
+#endif
+
+#ifndef STAR_GSW_DELAYED_INTERRUPT
+	// Disable Delayed Interrupt
+	num += sprintf(page + num, "Delay Interrupt %s\n",STR_DISABLE);
+#else
+	num += sprintf(page + num, "Delay Interrupt %s , Max Pending Interrupt Count: %d , Max Pending Timer : %d \n",
+		       STR_ENABLE, MAX_PEND_INT_CNT, MAX_PEND_TIME);
+#endif
+	num += sprintf(page + num, "Group VID Info: GVID0_VID:%02X   GVID1_VID: %02X   GVID2_VID:%02X   GVID3_VID: %02X \n", 
+				GSW_VLAN_VID_0_1&0xFFF, (GSW_VLAN_VID_0_1>>12)&0xFFF,
+				GSW_VLAN_VID_2_3&0xFFF, (GSW_VLAN_VID_2_3>>12)&0xFFF);
+
+	
+	num += sprintf(page + num, "                GVID4_VID:%02X   GVID5_VID: %02X   GVID6_VID:%02X   GVID7_VID: %02X \n", 
+				GSW_VLAN_VID_4_5&0xFFF, (GSW_VLAN_VID_4_5>>12)&0xFFF,
+				GSW_VLAN_VID_6_7&0xFFF, (GSW_VLAN_VID_6_7>>12)&0xFFF);
+
+
+	num += sprintf(page + num, "Int. Buffer free pages count : %x(%d)\n", 
+				   GSW_QUEUE_STATUS_TEST_1&0xFF,GSW_QUEUE_STATUS_TEST_1&0xFF);
+	num += sprintf(page + num, "Interrupt Status    : %x (Clean After Read)\n", GSW_INTERRUPT_STATUS);
+	GSW_INTERRUPT_STATUS= GSW_INTERRUPT_STATUS;
+
+	num += sprintf(page + num, "Switch Register: %x \n", GSW_SWITCH_CONFIG);
+	num += sprintf(page + num, "MAC0 REG: %x (%s:%s,%s,%s,%s)\n", GSW_MAC_PORT_0_CONFIG,
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<18))==0?"Port Enable":"Port Disable",
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<7))!=0?"AN Enable":"AN Disable",
+			(GSW_MAC_PORT_0_CONFIG&(0x11<<2))!=0x10?"1000Mbps":"10/100Mbps",
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<4))==0x0?"Half Duplex":"Full Duplex",
+			(GSW_MAC_PORT_0_CONFIG&(0x1))!=0?"Link Up":"Link Down"
+			);
+	num += sprintf(page + num, "MAC1 REG: %x (%s:%s,%s,%s,%s)\n", GSW_MAC_PORT_1_CONFIG,
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<18))==0?"Port Enable":"Port Disable",
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<7))!=0?"AN Enable":"AN Disable",
+			(GSW_MAC_PORT_0_CONFIG&(0x11<<2))!=0x10?"1000Mbps":"10/100Mbps",
+			(GSW_MAC_PORT_0_CONFIG&(0x1<<4))==0x0?"Half Duplex":"Full Duplex",
+			(GSW_MAC_PORT_0_CONFIG&(0x1))!=0?"Link Up":"Link Down"
+			);
+
+	num += sprintf(page + num, "CPU  REG: %x \n", GSW_CPU_PORT_CONFIG);
+	num += sprintf(page + num, "GSW_BIST_RESULT_TEST_0: %x\n", GSW_BIST_RESULT_TEST_0);
+#ifdef CONFIG_STR9100_VLAN_BASE
+	num += sprintf(page + num, "VLAN BASE\n");
+  #ifdef CONFIG_HAVE_VLAN_TAG
+	num += sprintf(page + num, "HAVE VLAN TAG\n");
+  #else
+	num += sprintf(page + num, "HAVE NO VLAN TAG\n");
+  #endif
+#endif
+
+#ifdef CONFIG_STR9100_PORT_BASE
+	num += sprintf(page + num, "PORT BASE\n");
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	num += sprintf(page + num, "8021Q support\n");
+#else
+	num += sprintf(page + num, "no 8021Q support\n");
+#endif
+
+#ifdef STAR_GSW_SG
+	num += sprintf(page + num, "Scatter Gather on\n");
+#else
+	num += sprintf(page + num, "Scatter Gather off\n");
+#endif
+
+#ifdef FREE_TX_SKB_MULTI
+	num += sprintf(page + num, "FREE_TX_SKB_MULTI on\n");
+#else
+	num += sprintf(page + num, "FREE_TX_SKB_MULTI off\n");
+#endif
+
+#ifdef STAR_GSW_TIMER
+	num += sprintf(page + num, "STAR_GSW_TIMER on\n");
+#else
+	num += sprintf(page + num, "STAR_GSW_TIMER off\n");
+#endif
+
+	num += sprintf(page + num, "all_netdevice: %d\n", all_netdevice);
+
+	return num;
+}
+
+int star_gsw_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+
+// 20061103 descent
+#ifdef CONFIG_CONF_VID
+	char *str, *pos;
+	u16 gid, vid;
+
+	str=buffer;
+
+	if (count)
+	{
+		//simple_strtol();
+		//printk("input str: %s\n", buffer);
+
+		// skip blank
+		while (*str==' ')
+		{
+			++str;
+		}
+		pos = strstr(str, " ");
+		if (pos)
+		{
+			*pos='\0';
+			//printk("str : %s\n", str);
+			gid=simple_strtol(str, NULL, 10);
+			//printk("gid : %d\n", gid);
+		}
+
+		str=(++pos);
+
+		// skip blank
+		while (*str==' ')
+		{
+			++str;
+		}
+
+		//pos = strstr(str, " ");
+		//if (pos)
+		{
+			//*pos='\0';
+			//printk("str : %s\n", str);
+			vid=simple_strtol(str, NULL, 10);
+			//printk("vid : %d\n", vid);
+		}
+		star_gsw_info.vlan[gid].vlan_vid=vid;
+		switch (gid)
+		{
+			case 0:
+			{
+				GSW_SET_VLAN_0_VID(vid);
+				break;
+			}
+			case 1:
+			{
+				GSW_SET_VLAN_1_VID(vid);
+				break;
+			}
+			case 2:
+			{
+				GSW_SET_VLAN_2_VID(vid);
+				break;
+			}
+			case 3:
+			{
+				GSW_SET_VLAN_3_VID(vid);
+				break;
+			}
+			case 4:
+			{
+				GSW_SET_VLAN_4_VID(vid);
+				break;
+			}
+			case 5:
+			{
+				GSW_SET_VLAN_5_VID(vid);
+				break;
+			}
+			case 6:
+			{
+				GSW_SET_VLAN_6_VID(vid);
+				break;
+			}
+			case 7:
+			{
+				GSW_SET_VLAN_7_VID(vid);
+				break;
+			}
+		}
+
+
+
+		printk("GSW_VLAN_VID_0_1: %x\n", GSW_VLAN_VID_0_1);
+		printk("GSW_VLAN_VID_2_3: %x\n", GSW_VLAN_VID_2_3);
+		printk("GSW_VLAN_VID_4_5: %x\n", GSW_VLAN_VID_4_5);
+		printk("GSW_VLAN_VID_6_7: %x\n", GSW_VLAN_VID_6_7);
+	}
+
+#endif
+// 20061103 descent end
+
+// 20060922 descent
+#ifdef CONFIG_NIC_MODE
+       	u32 sw_config = GSW_SWITCH_CONFIG;
+
+	// NIC mode on
+	if (count && buffer[0]=='1') {
+		sw_config |= (1 << 30);
+
+		star_gsw_info.vlan[0].vlan_tag_flag	= 0;
+		star_gsw_info.vlan[1].vlan_tag_flag	= 0;
+
+		printk("NIC mode on\n");
+	}
+
+	// NIC mode off
+	if (count && buffer[0]=='0') {
+		sw_config &= ~(1 << 30);
+
+		star_gsw_info.vlan[0].vlan_tag_flag	= VLAN0_VLAN_TAG;
+		star_gsw_info.vlan[1].vlan_tag_flag	= VLAN1_VLAN_TAG;
+
+		printk("NIC mode off\n");
+	}
+	GSW_SET_VLAN_0_TAG(star_gsw_info.vlan[0].vlan_tag_flag);
+	GSW_SET_VLAN_1_TAG(star_gsw_info.vlan[1].vlan_tag_flag);
+
+       	GSW_SWITCH_CONFIG = sw_config;
+#endif
+// 20060922 descent end
+
+#ifdef CHANGE_DELAY_INT
+	int i=0, j=0;
+	int c=count;
+	char *str=buffer;
+	char str_num[5];
+	unsigned long n[2];
+	int index=0;
+	const char cmd_on[]="delay_int_on";
+	const char cmd_off[]="delay_int_off";
+
+	while(*str==' ') {
+		++str;
+		--c;
+	}
+	PDEBUG("count: %d\n", count);
+	PDEBUG("c: %d\n", c);
+	if (strncmp(cmd_on, str, strlen(cmd_on))==0) {
+		PDEBUG("delay int on\n");
+		GSW_DELAYED_INTERRUPT_CONFIG |= (1 << 16) ;
+		return count;
+	}
+	if (strncmp(cmd_off, str, strlen(cmd_off))==0) {
+		PDEBUG("delay int off \n");
+		GSW_DELAYED_INTERRUPT_CONFIG &= (~(0x1 << 16));
+		return count;
+	}
+	for (i=0, j=0 ; i < c; ++i){
+		if ( ('0' <= str[i] && str[i] <= '9') || ('a' <= str[i] && str[i] <= 'f') || ('A' <= str[i] && str[i] <= 'F'))
+			str[j++]=str[i];
+		else
+		{
+			str[j++]=0;
+			n[index]=simple_strtoul(str, NULL, 16);
+			PDEBUG("n: %x\n", n[index]);
+			++index;
+			PDEBUG("str: %s\n", str);
+			j=0;
+		}
+	}
+	//if (count && buffer[0]=='0')
+	max_pend_int_cnt=n[0];
+	max_pend_time=n[1];
+#ifdef STAR_GSW_DELAYED_INTERRUPT
+	GSW_DELAYED_INTERRUPT_CONFIG = (1 << 16) | (max_pend_int_cnt << 8) | (max_pend_time);
+#endif
+
+#endif
+
+// add by descent, 2006/07/04
+// ADJUSTMENT TX RX SKEW
+#ifdef ADJUSTMENT_TX_RX_SKEW
+	// adjust MAC port 0/1 RX/TX clock skew
+	if (count && buffer[0]=='0')
+	{
+		printk("port 1 tx skew 0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 30);
+		GSW_BIST_RESULT_TEST_0 |= (0x0 << 30);
+
+	}
+	if (count && buffer[0]=='1')
+	{
+		printk("port 1 tx skew 1.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 30);
+		GSW_BIST_RESULT_TEST_0 |= (0x1 << 30);
+	}
+	if (count && buffer[0]=='2')
+	{
+		printk("port 1 tx skew 2.0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 30);
+		GSW_BIST_RESULT_TEST_0 |= (0x2 << 30);
+	}
+	if (count && buffer[0]=='3')
+	{
+		printk("port 1 tx skew 2.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 30);
+		GSW_BIST_RESULT_TEST_0 |= (0x3 << 30);
+	}
+
+
+
+	if (count && buffer[0]=='4')
+	{
+		printk("port 1 rx skew 0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 28);
+		GSW_BIST_RESULT_TEST_0 |= (0x0 << 28);
+	}
+	if (count && buffer[0]=='5')
+	{
+		printk("port 1 rx skew 1.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 28);
+		GSW_BIST_RESULT_TEST_0 |= (0x1 << 28);
+	}
+	if (count && buffer[0]=='6')
+	{
+		printk("port 1 rx skew 2.0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 28);
+		GSW_BIST_RESULT_TEST_0 |= (0x2 << 28);
+	}
+	if (count && buffer[0]=='7')
+	{
+		printk("port 1 rx skew 2.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 28);
+		GSW_BIST_RESULT_TEST_0 |= (0x3 << 28);
+	}
+
+
+	if (count && buffer[0]=='8')
+	{
+		printk("port 0 tx skew 0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 26);
+		GSW_BIST_RESULT_TEST_0 |= (0x0 << 26);
+	}
+	if (count && buffer[0]=='9')
+	{
+		printk("port 0 tx skew 1.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 26);
+		GSW_BIST_RESULT_TEST_0 |= (0x1 << 26);
+	}
+	if (count && buffer[0]=='a')
+	{
+		printk("port 0 tx skew 2.0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 26);
+		GSW_BIST_RESULT_TEST_0 |= (0x2 << 26);
+	}
+	if (count && buffer[0]=='b')
+	{
+		printk("port 0 tx skew 2.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 26);
+		GSW_BIST_RESULT_TEST_0 |= (0x3 << 26);
+	}
+
+
+	if (count && buffer[0]=='c')
+	{
+		printk("port 0 rx skew 0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 24);
+		GSW_BIST_RESULT_TEST_0 |= (0x0 << 24);
+	}
+	if (count && buffer[0]=='d')
+	{
+		printk("port 0 rx skew 1.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 24);
+		GSW_BIST_RESULT_TEST_0 |= (0x1 << 24);
+	}
+	if (count && buffer[0]=='e')
+	{
+		printk("port 0 rx skew 2.0 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 24);
+		GSW_BIST_RESULT_TEST_0 |= (0x2 << 24);
+	}
+	if (count && buffer[0]=='f')
+	{
+		printk("port 0 rx skew 2.5 ns\n");
+                GSW_BIST_RESULT_TEST_0 &= ~(0x3 << 24);
+		GSW_BIST_RESULT_TEST_0 |= (0x3 << 24);
+	}
+
+	printk("GSW_BIST_RESULT_TEST_0: %x\n", GSW_BIST_RESULT_TEST_0);
+#endif
+
+#ifdef STR9100_GSW_FAST_AGE_OUT_
+	{
+	// 00:02:A5:BE:59:AA
+	u8 src_mac[6] = {0x00, 0x02, 0xa5, 0xbe, 0x59, 0xaa};
+	int vlan_gid=1; // lan
+
+	printk("src mac = %x:%x:%x:%x:%x:%x\n", *src_mac,*(src_mac+1), *(src_mac+2), *(src_mac+3), *(src_mac+4), *(src_mac+5));
+	printk("vlan_gid : %d\n", vlan_gid);
+	if (star_gsw_search_arl_table(src_mac, vlan_gid))
+	{
+		printk("find it\n");
+	}
+	else
+	{
+		printk("not found\n");
+	}
+
+	}
+
+	{
+	// 00:02:A5:BE:59:AA
+	u8 src_mac[6] = {0x00, 0x02, 0xa5, 0xbe, 0x59, 0x99};
+	int vlan_gid=1; // lan
+
+	printk("src mac = %x:%x:%x:%x:%x:%x\n", *src_mac,*(src_mac+1), *(src_mac+2), *(src_mac+3), *(src_mac+4), *(src_mac+5));
+	printk("vlan_gid : %d\n", vlan_gid);
+	if (star_gsw_search_arl_table(src_mac, vlan_gid))
+	{
+		printk("find it\n");
+	}
+	else
+	{
+		printk("not found\n");
+	}
+	}
+#endif
+	return count;
+}
+
+
+static void star_gsw_enable(struct net_device *dev)
+{
+	GSW_FS_DMA_START();
+	star_gsw_interrupt_enable();
+}
+
+
+static void star_gsw_shutdown(struct net_device *dev)
+{
+}
+
+inline int star_gsw_search_arl_table(u8 *mac, u32 vlan_gid)
+{
+	volatile u32 lookup_result;
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_0 = 0x0;
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 = 0x0;
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 = 0x0;
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 =
+		(((mac[2] & 0xFF) << 0)	|
+		((mac[3] & 0xFF) << 8)	|
+		((mac[4] & 0xFF) << 16)	|
+		((mac[5] & 0xFF) << 24));
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 =
+		((vlan_gid << 5)	|
+		((mac[0] & 0xFF) << 16)	|
+		((mac[1] & 0xFF) << 24) );
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_0 = (0x1 << 2);
+
+	do {
+		lookup_result = GSW_ARL_TABLE_ACCESS_CONTROL_1;
+		// still search, bit2 and bit0
+	} while ((lookup_result & 0x5) == 0); 
+
+	if (lookup_result & (0x1 << 2)) {
+		return 1;
+	} else {
+		return 0; // not found
+	}
+}
+
+// add by descent 2006/07/03
+// del arl entry
+int star_gsw_del_arl_table(u8 *mac, u32 vlan_gid)
+{
+	volatile u32 age_field=0; // invalid mean erase this entry
+	volatile u32 port_map=star_gsw_info.vlan[0].vlan_group; // invalid mean erase this entry
+	volatile u32 result;
+	
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 = 0x0;
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 = 0x0;
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_1 = ( ((vlan_gid & 0x7) << 5) |
+                                           ((age_field & 0x7) << 8 ) | 
+                                           ((port_map & 0x7) << 11 ) | 
+                                           ((mac[0] & 0xFF) << 16) |
+                                           ((mac[1] & 0xFF) << 24) );
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_2 = ( ((mac[2] & 0xFF) << 0)  |
+                                           ((mac[3] & 0xFF) << 8)  |
+                                           ((mac[4] & 0xFF) << 16) |
+                                           ((mac[5] & 0xFF) << 24));
+
+
+	GSW_ARL_TABLE_ACCESS_CONTROL_0 = 0x8; // write command
+	do
+	{
+		result=GSW_ARL_TABLE_ACCESS_CONTROL_1;
+	}while((result & 0x1)==0); 
+
+	return 0;
+}
+
+void star_gsw_hnat_write_vlan_src_mac(u8 index, u8 *vlan_src_mac)
+{
+	switch (index) {
+	case 0:
+		GSW_HNAT_SOURCE_MAC_0_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_0_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 1:
+		GSW_HNAT_SOURCE_MAC_1_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_1_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 2:
+		GSW_HNAT_SOURCE_MAC_2_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_2_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 3:
+		GSW_HNAT_SOURCE_MAC_3_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_3_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 4:
+		GSW_HNAT_SOURCE_MAC_4_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_4_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 5:
+		GSW_HNAT_SOURCE_MAC_5_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_5_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 6:
+		GSW_HNAT_SOURCE_MAC_6_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_6_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	case 7:
+		GSW_HNAT_SOURCE_MAC_7_HIGH = (vlan_src_mac[0] << 8) |
+			(vlan_src_mac[1] << 0);
+
+		GSW_HNAT_SOURCE_MAC_7_LOW = (vlan_src_mac[2] << 24) |
+			(vlan_src_mac[3] << 16) |
+			(vlan_src_mac[4] << 8) |
+			(vlan_src_mac[5] << 0);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static int star_gsw_hnat_setup_vlan_src_mac(void)
+{
+	star_gsw_hnat_write_vlan_src_mac(0, star_gsw_info.vlan[0].vlan_mac);
+	star_gsw_hnat_write_vlan_src_mac(1, star_gsw_info.vlan[1].vlan_mac);
+	star_gsw_hnat_write_vlan_src_mac(2, star_gsw_info.vlan[2].vlan_mac);
+	star_gsw_hnat_write_vlan_src_mac(3, star_gsw_info.vlan[3].vlan_mac);
+
+	return 0;
+}
+
+static void star_gsw_vlan_init(void)
+{
+	star_gsw_info.vlan[0].vlan_gid		= VLAN0_GROUP_ID;
+	star_gsw_info.vlan[0].vlan_vid		= VLAN0_VID;
+	star_gsw_info.vlan[0].vlan_group	= VLAN0_GROUP;
+	star_gsw_info.vlan[0].vlan_tag_flag	= VLAN0_VLAN_TAG;
+
+	// store My VLAN0 MAC
+	memcpy(star_gsw_info.vlan[0].vlan_mac, my_vlan0_mac, 6);
+
+	star_gsw_info.vlan[1].vlan_gid		= VLAN1_GROUP_ID;
+	star_gsw_info.vlan[1].vlan_vid		= VLAN1_VID;
+	star_gsw_info.vlan[1].vlan_group	= VLAN1_GROUP;
+	star_gsw_info.vlan[1].vlan_tag_flag	= VLAN1_VLAN_TAG;
+
+	// store My VLAN1 MAC
+	memcpy(star_gsw_info.vlan[1].vlan_mac, my_vlan1_mac, 6);
+
+	star_gsw_info.vlan[2].vlan_gid		= VLAN2_GROUP_ID;
+	star_gsw_info.vlan[2].vlan_vid		= VLAN2_VID;
+	star_gsw_info.vlan[2].vlan_group	= VLAN2_GROUP;
+	star_gsw_info.vlan[2].vlan_tag_flag	= VLAN2_VLAN_TAG;
+
+	// store My VLAN2 MAC
+	memcpy(star_gsw_info.vlan[2].vlan_mac, my_vlan2_mac, 6);
+
+	star_gsw_info.vlan[3].vlan_gid		= VLAN3_GROUP_ID;
+	star_gsw_info.vlan[3].vlan_vid		= VLAN3_VID;
+	star_gsw_info.vlan[3].vlan_group	= VLAN3_GROUP;
+	star_gsw_info.vlan[3].vlan_tag_flag	= VLAN3_VLAN_TAG;
+
+	// store My VLAN3 MAC
+	memcpy(star_gsw_info.vlan[3].vlan_mac, my_vlan3_mac, 6);
+
+	star_gsw_info.vlan[4].vlan_gid		= VLAN4_GROUP_ID;
+	star_gsw_info.vlan[4].vlan_vid		= VLAN4_VID;
+	star_gsw_info.vlan[4].vlan_group	= VLAN4_GROUP;
+	star_gsw_info.vlan[4].vlan_tag_flag	= VLAN4_VLAN_TAG;
+
+	star_gsw_info.vlan[5].vlan_gid		= VLAN5_GROUP_ID;
+	star_gsw_info.vlan[5].vlan_vid		= VLAN5_VID;
+	star_gsw_info.vlan[5].vlan_group	= VLAN5_GROUP;
+	star_gsw_info.vlan[5].vlan_tag_flag	= VLAN5_VLAN_TAG;
+
+	star_gsw_info.vlan[6].vlan_gid		= VLAN6_GROUP_ID;
+	star_gsw_info.vlan[6].vlan_vid		= VLAN6_VID;
+	star_gsw_info.vlan[6].vlan_group	= VLAN6_GROUP;
+	star_gsw_info.vlan[6].vlan_tag_flag	= VLAN6_VLAN_TAG; 
+
+	star_gsw_info.vlan[7].vlan_gid		= VLAN7_GROUP_ID;
+	star_gsw_info.vlan[7].vlan_vid		= VLAN7_VID;
+	star_gsw_info.vlan[7].vlan_group	= VLAN7_GROUP;
+	star_gsw_info.vlan[7].vlan_tag_flag	= VLAN7_VLAN_TAG;
+
+	star_gsw_info.port[0].pvid		= PORT0_PVID;
+	star_gsw_info.port[0].config_flag	= 0;
+	star_gsw_info.port[0].status_flag	= 0;
+
+	star_gsw_info.port[1].pvid		= PORT1_PVID;
+	star_gsw_info.port[1].config_flag	= 0;
+	star_gsw_info.port[1].status_flag	= 0;
+
+	star_gsw_info.port[2].pvid		= CPU_PORT_PVID;
+	star_gsw_info.port[2].config_flag	= 0;
+	star_gsw_info.port[2].status_flag	= 0;   
+}
+
+irqreturn_t star_gsw_receive_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct star_gsw_private *priv = netdev_priv(STAR_NAPI_DEV);
+
+
+#ifdef CONFIG_STAR_GSW_NAPI
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSRC_BIT_INDEX);
+	disable_irq(INTC_GSW_FSRC_BIT_INDEX);
+
+
+        if (likely(netif_rx_schedule_prep(STAR_NAPI_DEV,&priv->napi))) {
+                __netif_rx_schedule(STAR_NAPI_DEV,&priv->napi);
+	} else {
+                enable_irq(INTC_GSW_FSRC_BIT_INDEX);
+        }
+
+#if 0
+	CUR_NAPI_DEV=STAR_GSW_WAN_DEV;
+
+	if (CUR_NAPI_DEV && netif_running(CUR_NAPI_DEV)) {
+		if (likely(netif_rx_schedule_prep(CUR_NAPI_DEV))) {
+			__netif_rx_schedule(CUR_NAPI_DEV);
+		} else {
+			PDEBUG("lan driver bug! interrupt while in poll\n");
+		}
+	}
+	else
+	{
+		CUR_NAPI_DEV=STAR_GSW_LAN_DEV;
+		if (CUR_NAPI_DEV && netif_running(CUR_NAPI_DEV)) {
+			if (likely(netif_rx_schedule_prep(CUR_NAPI_DEV))) {
+				__netif_rx_schedule(CUR_NAPI_DEV);
+			} else {
+				PDEBUG("lan driver bug! interrupt while in poll\n");
+			}
+		}
+		else
+		{
+			CUR_NAPI_DEV=STAR_GSW_EWC_DEV;
+			if (CUR_NAPI_DEV && netif_running(CUR_NAPI_DEV)) {
+				if (likely(netif_rx_schedule_prep(CUR_NAPI_DEV))) {
+					__netif_rx_schedule(CUR_NAPI_DEV);
+				} else {
+					PDEBUG("lan driver bug! interrupt while in poll\n");
+				}
+			}
+
+		}
+	}
+#endif
+#else
+	// TODO: mask interrupt
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSRC_BIT_INDEX);
+	// MASK Interrupt
+	INTC_INTERRUPT_MASK |= (0x1 << INTC_GSW_FSRC_BIT_INDEX);
+	INTC_INTERRUPT_MASK |= (0x1 << INTC_GSW_FSQF_BIT_INDEX);
+	++fsrc_count;
+	star_gsw_receive_packet(0); // Receive Once
+	// TODO: unmask interrupt
+	INTC_INTERRUPT_MASK &= ~(0x1 << INTC_GSW_FSRC_BIT_INDEX);
+	INTC_INTERRUPT_MASK &= ~(0x1 << INTC_GSW_FSQF_BIT_INDEX);
+#endif
+
+	return IRQ_HANDLED;
+}
+
+
+#ifdef STAR_GSW_FSQF_ISR
+IRQ_RETURN star_gsw_fsqf_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSQF_BIT_INDEX);
+#ifdef CONFIG_STAR_GSW_NAPI
+	// because in normal state, fsql only invoke once and set_bit is atomic function.
+	// so I don't mask it.
+	set_bit(0, &is_qf);
+#else
+	INTC_INTERRUPT_MASK |= (0x1 << INTC_GSW_FSRC_BIT_INDEX);
+	INTC_INTERRUPT_MASK |= (0x1 << INTC_GSW_FSQF_BIT_INDEX);
+
+	star_gsw_receive_packet(1); // Receive at Queue Full Mode
+
+	// TODO: unmask interrupt
+	INTC_INTERRUPT_MASK &= ~(0x1 << INTC_GSW_FSRC_BIT_INDEX);
+	INTC_INTERRUPT_MASK &= ~(0x1 << INTC_GSW_FSQF_BIT_INDEX);
+	//INTC_INTERRUPT_MASK &= (0x0 << INTC_GSW_FSRC_BIT_INDEX);
+	//INTC_INTERRUPT_MASK &= (0x0 << INTC_GSW_FSQF_BIT_INDEX);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef STAR_GSW_STATUS_ISR
+static char *star_gsw_status_tbl[] = {
+	"\nGlobal threshold reached and Port 0 queue threshold reached.\n",
+	"\nGlobal threshold reached and Port 1 queue threshold reached.\n",
+	"\nGlobal threshold reached and CPU port queue threshold reached.\n",
+	"\nGlobal threshold reached and HNAT queue threshold reached.\n",
+	"\nGlobal threshold reached.\n",
+	"\nAll pages of packet buffer are used.\n",
+	"\nPort change link state.\n",
+	"\nPort 0 received intruder packets.\n",
+	"\nPort 1 received intruder packets.\n",
+	"\n",
+	"\nPort 0 received packets with unknown VLAN.\n",
+	"\nPort 1 received packets with unknown VLAN.\n",
+	"\nPort CPU received packets with unknown VLAN.\n",
+	"\n",
+	"\n",
+	"\n",
+	"\nDrop by no free links(Port 0).\n",
+	"\nDrop by broadcast storm(Port 0).\n",
+	"\nDrop by rx packet error(Port 0).\n",
+	"\nDrop by backpressure(Port 0).\n",
+	"\nDrop by no destination(Port 0).\n",
+	"\nDrop by reserved MC packets(Port 0).\n",
+	"\nDrop by local traffic(Port 0).\n",
+	"\nDrop by ingress check(Port 0).\n",
+	"\nDrop by no free links(Port 1).\n",
+	"\nDrop by broadcast storm(Port 1).\n",
+	"\nDrop by rx packet error(Port 1).\n",
+	"\nDrop by backpressure(Port 1).\n",
+	"\nDrop by no destination(Port 1).\n",
+	"\nDrop by reserved MC packets(Port 1).\n",
+	"\nDrop by local traffic(Port 1).\n",
+	"\nDrop by ingress checki(Port 1).\n",
+};
+
+IRQ_RETURN star_gsw_status_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 int_status;
+	u32 i;
+
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_STATUS_BIT_INDEX);
+
+	GSW_READ_INTERRUPT_STATUS(int_status);
+
+	PDEBUG("\n status:%08X \n",int_status);
+	PDEBUG("\n GSW_MAC_PORT_0_CONFIG:%08X\n",GSW_MAC_PORT_0_CONFIG);
+	PDEBUG("\n GSW_MAC_PORT_1_CONFIG:%08X\n",GSW_MAC_PORT_1_CONFIG);
+
+	for (i = 0; i < 32; i++) {
+		if (int_status & (1 << i)) {
+			PRINT_INFO(star_gsw_status_tbl[i]);
+		}
+	}
+
+	GSW_CLEAR_INTERRUPT_STATUS_SOURCES(int_status);
+
+	INTC_ENABLE_INTERRUPT_SOURCE(INTC_GSW_STATUS_BIT_INDEX);
+
+	return IRQ_HANDLED;
+
+}
+#endif // STAR_GSW_STATUS_ISR
+
+static int star_gsw_uninstall_isr(struct net_device *dev)
+{
+	--install_isr_account;
+	if (install_isr_account == 0) {
+		PDEBUG("star gsw uninstall isr\n");
+		free_irq(INTC_GSW_FSRC_BIT_INDEX, STAR_GSW_LAN_DEV);
+
+#ifdef STAR_GSW_FSQF_ISR
+		free_irq(INTC_GSW_FSQF_BIT_INDEX, STAR_GSW_LAN_DEV);
+#endif
+
+#ifdef STAR_GSW_STATUS_ISR
+		free_irq(INTC_GSW_STATUS_BIT_INDEX, STAR_GSW_LAN_DEV);
+#endif
+
+
+#ifdef CONFIG_STAR_GSW_NAPI
+{
+	struct star_gsw_private *sp = netdev_priv(STAR_NAPI_DEV);
+
+	napi_disable(&sp->napi);
+	netif_stop_queue(STAR_NAPI_DEV);
+}
+#endif
+
+	}
+
+	return 0;
+}
+
+static int star_gsw_install_isr(struct net_device *dev)
+{
+	int retval;
+
+	
+	if (install_isr_account == 0) {
+#ifdef STAR_GSW_DELAYED_INTERRUPT
+		GSW_DELAYED_INTERRUPT_CONFIG = (1 << 16) | (max_pend_int_cnt << 8) | (max_pend_time);
+#endif
+#ifdef STAR_GSW_STATUS_ISR
+		str9100_set_interrupt_trigger(INTC_GSW_STATUS_BIT_INDEX, INTC_LEVEL_TRIGGER, INTC_ACTIVE_HIGH);
+#endif
+		str9100_set_interrupt_trigger((u32)INTC_GSW_FSRC_BIT_INDEX, (u32)INTC_EDGE_TRIGGER, (u32)INTC_RISING_EDGE);
+#ifdef STAR_GSW_FSQF_ISR
+		str9100_set_interrupt_trigger(INTC_GSW_FSQF_BIT_INDEX, INTC_EDGE_TRIGGER, INTC_RISING_EDGE);
+#endif
+
+
+		retval = request_irq(INTC_GSW_FSRC_BIT_INDEX, &star_gsw_receive_isr, IRQF_SHARED, "GSW FSRC INT", STAR_GSW_LAN_DEV);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n", "GSW FSRC INT", INTC_GSW_FSRC_BIT_INDEX, retval);
+			return 1;
+		}
+
+#ifdef STAR_GSW_FSQF_ISR
+		/*  QUEUE full interrupt handler */
+		retval = request_irq(INTC_GSW_FSQF_BIT_INDEX, &star_gsw_fsqf_isr, IRQF_SHARED, "GSW FSQF INT", STAR_GSW_LAN_DEV);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n", "GSW FSQF INT", INTC_GSW_FSQF_BIT_INDEX, retval);
+			return 2;
+		}
+#endif	
+
+#ifdef STAR_GSW_STATUS_ISR
+		/*  GSW Status interrupt handler */
+		retval = request_irq(INTC_GSW_STATUS_BIT_INDEX, &star_gsw_status_isr, IRQF_SHARED, "GSW STATUS", STAR_GSW_LAN_DEV);
+
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n", "GSW STATUS INT", INTC_GSW_STATUS_BIT_INDEX, retval);
+			return 3;
+		}
+		GSW_ENABLE_ALL_INTERRUPT_STATUS_SOURCES();
+#endif
+
+#ifdef CONFIG_STAR_GSW_NAPI
+{
+	struct star_gsw_private *sp = netdev_priv(STAR_NAPI_DEV);    
+        napi_enable(&sp->napi);
+        netif_start_queue(STAR_NAPI_DEV);
+}
+#endif
+	} // end if(install_isr_account == 0)
+
+	++install_isr_account;
+
+	return 0;
+}
+
+// add by descent 2006/07/12
+void enable_cpu_port(int y)
+{
+	u32 cpu_port_config;
+	cpu_port_config = GSW_CPU_PORT_CONFIG;		
+	if (y==1) // enable CPU
+		cpu_port_config &= ~(0x1 << 18);
+	if (y==0) // disable CPU
+		cpu_port_config |= (0x1 << 18);
+	GSW_CPU_PORT_CONFIG = cpu_port_config;
+}
+
+static int star_gsw_open(struct net_device *dev)
+{
+
+
+	OPEN_PORT(dev)
+	enable_cpu_port(1);
+	//memcpy(dev->dev_addr, star_gsw_info.vlan[1].vlan_mac, 6);
+
+	star_gsw_hnat_setup_vlan_src_mac();
+
+#if 0
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+#endif
+
+
+
+	//CUR_NAPI_DEV = dev;
+
+	star_gsw_enable(dev);
+
+	netif_start_queue(dev);
+
+	GSW_ENABLE_ALL_INTERRUPT_STATUS_SOURCES();
+
+	star_gsw_install_isr(dev);
+
+	return 0;
+}
+
+
+
+static struct net_device_stats *star_gsw_get_stats(struct net_device *dev)
+{
+	struct star_gsw_private *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static void star_gsw_timeout(struct net_device *dev)
+{
+	PRINT_INFO("%s:star_gsw_timeout\n", dev->name);
+	star_gsw_enable(dev);
+	netif_wake_queue(dev);
+	dev->trans_start = jiffies;
+}
+
+
+
+static int star_gsw_close(struct net_device *dev)
+{
+	star_gsw_uninstall_isr(dev);
+	//star_gsw_shutdown(dev);
+
+	//CLOSE_PORT0
+	//CLOSE_PORT1
+	CLOSE_PORT(dev)
+
+#if 0
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+#endif
+
+#if 0
+	if (dev == STAR_GSW_WAN_DEV) {
+		CUR_NAPI_DEV = STAR_GSW_LAN_DEV;
+	} else if (dev == STAR_GSW_LAN_DEV) {
+		CUR_NAPI_DEV = STAR_GSW_WAN_DEV;
+	} else if (dev == STAR_GSW_EWC_DEV) {
+		CUR_NAPI_DEV = STAR_GSW_LAN_DEV;
+	}
+	//} // if (dev == STAR_GSW_LAN_DEV)
+#endif
+
+	//phy_power_down_ptr(1,1);
+	return 0;
+}
+
+static inline struct sk_buff *star_gsw_alloc_skb(void)
+{
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(MAX_PACKET_LEN + 2);
+
+	if (unlikely(!skb)) {
+		PDEBUG("\n dev_alloc_skb fail!! while allocate RFD ring !!\n");
+		return NULL;
+	}
+
+
+	/* Make buffer alignment 2 beyond a 16 byte boundary
+	 * this will result in a 16 byte aligned IP header after
+	 * the 14 byte MAC header is removed
+	 */
+	
+	skb_reserve(skb, 2);	/* 16 bit alignment, 4N + 2 mode */
+
+	return skb;
+}
+
+static void star_gsw_buffer_free(void)
+{
+	int i;
+
+	if (rxring.vir_addr) {
+		for (i = 0; i < STAR_GSW_MAX_RFD_NUM; i++) {
+			if (rxring.skb_ptr[i]) {
+				dev_kfree_skb(rxring.skb_ptr[i]);
+			}
+		}
+		dma_free_coherent(NULL, STAR_GSW_MAX_RFD_NUM * sizeof(STAR_GSW_RXDESC), rxring.vir_addr, rxring.phy_addr);
+	}
+
+	if (txring.vir_addr) {
+		dma_free_coherent(NULL, STAR_GSW_MAX_TFD_NUM * sizeof(STAR_GSW_TXDESC), txring.vir_addr, txring.phy_addr);
+	}
+}
+
+static int __init star_gsw_buffer_alloc(void)
+{
+	STAR_GSW_RXDESC	volatile *rxdesc_ptr;
+	STAR_GSW_TXDESC	volatile *txdesc_ptr;
+	struct sk_buff	*skb_ptr;
+	int err;
+	int i;
+
+	rxring.vir_addr = dma_alloc_coherent(NULL, STAR_GSW_MAX_RFD_NUM * sizeof(STAR_GSW_RXDESC), &rxring.phy_addr, GFP_KERNEL);
+	if (!rxring.vir_addr) {
+		PDEBUG("\n ERROR: Allocate RFD Failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	txring.vir_addr = dma_alloc_coherent(NULL, STAR_GSW_MAX_TFD_NUM * sizeof(STAR_GSW_TXDESC), &txring.phy_addr, GFP_KERNEL);
+	if (!txring.vir_addr) {
+		PDEBUG("\n ERROR: Allocate TFD Failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	// Clean RX Memory
+	memset((void *)rxring.vir_addr, 0, STAR_GSW_MAX_RFD_NUM * sizeof(STAR_GSW_RXDESC));
+	PDEBUG("    rxring.vir_addr=0x%08X rxring.phy_addr=0x%08X\n", (u32)rxring.vir_addr, (u32)rxring.phy_addr);
+	rxring.cur_index = 0;	// Set cur_index Point to Zero
+	rxdesc_ptr = rxring.vir_addr;
+	for (i = 0; i < STAR_GSW_MAX_RFD_NUM; i++, rxdesc_ptr++) {
+		if (i == (STAR_GSW_MAX_RFD_NUM - 1)) { 
+			rxdesc_ptr->eor = 1;	// End bit == 0;
+		}
+		skb_ptr = star_gsw_alloc_skb();
+		if (!skb_ptr) {
+			PDEBUG("ERROR: Allocate skb Failed!\n");
+			err = -ENOMEM;
+			goto err_out;
+		}
+		// Trans Packet from Virtual Memory to Physical Memory
+		rxring.skb_ptr[i]	= skb_ptr;
+		rxdesc_ptr->data_ptr	= (u32)virt_to_phys(skb_ptr->data);
+		rxdesc_ptr->length	= MAX_PACKET_LEN;
+	}
+
+	// Clean TX Memory
+	memset((void *)txring.vir_addr, 0, STAR_GSW_MAX_TFD_NUM * sizeof(STAR_GSW_TXDESC));
+	PDEBUG("    txring.vir_addr=0x%08X txring.phy_addr=0x%08X\n", (u32)txring.vir_addr, (u32)txring.phy_addr);
+	txring.cur_index = 0;	// Set cur_index Point to Zero
+	txdesc_ptr = txring.vir_addr;
+	for (i = 0; i < STAR_GSW_MAX_TFD_NUM; i++, txdesc_ptr++) {
+		if (i == (STAR_GSW_MAX_TFD_NUM - 1)) { 
+			txdesc_ptr->eor = 1;	// End of Ring ==1
+		}
+		txdesc_ptr->cown = 1;	// TX Ring , Cown == 1
+
+#ifdef STAR_GSW_TX_HW_CHECKSUM
+		// Enable Checksum
+		txdesc_ptr->ico		= 0;
+		txdesc_ptr->uco		= 1;
+		txdesc_ptr->tco		= 1;
+#else
+		txdesc_ptr->ico		= 0;
+		txdesc_ptr->uco		= 0;
+		txdesc_ptr->tco		= 0;
+#endif
+		txring.skb_ptr[i] 	= NULL;	// clear txring.skb_ptr
+	}
+
+	return 0;
+
+err_out:
+	star_gsw_buffer_free();
+	return err;
+}
+
+#ifdef CONFIG_STAR_GSW_NAPI
+
+#if 0
+static int star_gsw_poll(struct net_device *netdev, int *budget)
+{
+	int work_done = 0;
+	int work_to_do = min(*budget, netdev->quota); // where is min define
+
+	star_gsw_receive_packet(0, &work_done, work_to_do);
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+
+        if (work_done) {
+                if (is_qf) {
+                        is_qf = 0;
+                        HAL_GSW_FS_DMA_START();
+                        return 1;
+                }
+        }
+        else {
+                netif_rx_complete(&STAR_NAPI_DEV);
+                enable_irq(INTC_GSW_FSRC_BIT_INDEX);
+                return 0;
+        }
+
+
+	return 1;
+}
+#else
+
+static int star_gsw_poll(struct napi_struct *napi, int budget)
+{
+
+	struct star_gsw_private *sp = container_of(napi, struct star_gsw_private, napi);
+	int work_done = 0;
+	int work_to_do = budget; // where is min define
+
+	star_gsw_receive_packet(0, &work_done, work_to_do);
+
+	budget -= work_done;
+
+        if (work_done) {
+			if (test_bit(0, (unsigned long *)&is_qf) == 1){
+				clear_bit(0, (unsigned long *)&is_qf);
+                HAL_GSW_FS_DMA_START();
+                return 1;
+            }
+        }
+        else {
+            netif_rx_complete(STAR_NAPI_DEV, &sp->napi);
+            enable_irq(INTC_GSW_FSRC_BIT_INDEX);
+            return 0;
+        }
+
+
+	return 1;
+}
+#endif
+
+
+#ifdef LINUX26_
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+__attribute__((section(".ispad")))
+#endif
+
+static int star_gsw_poll(struct napi_struct *napi, int budget)
+{
+
+	struct star_gsw_private *sp = container_of(napi, struct star_gsw_private, napi);
+	int work_done = 0;
+	int work_to_do = budget; // where is min define
+
+	star_gsw_receive_packet(0, &work_done, work_to_do);
+
+	budget -= work_done;
+
+        if (work_done) {
+			if (test_bit(0, (unsigned long *)&is_qf) == 1){
+				clear_bit(0, (unsigned long *)&is_qf);
+                HAL_GSW_FS_DMA_START();
+                return 1;
+            }
+        }
+        else {
+            netif_rx_complete(STAR_NAPI_DEV, &sp->napi);
+            enable_irq(INTC_GSW_FSRC_BIT_INDEX);
+            return 0;
+        }
+
+
+	return 1;
+}
+#endif // LINUX26
+
+
+
+
+
+#endif // CONFIG_STAR_GSW_NAPI
+
+static int star_gsw_get_rfd_buff(int index)
+{
+	struct star_gsw_private *priv;
+	STAR_GSW_RXDESC volatile *rxdesc_ptr;
+	struct sk_buff *skb_ptr;
+	unsigned char *data;
+	int len;
+#ifdef CONFIG_STR9100_VLAN_BASE
+	u32 vlan_gid = 0;
+	u8 *src_mac;
+#endif
+
+	rxdesc_ptr = rxring.vir_addr + index;
+	skb_ptr = rxring.skb_ptr[index];
+	len = rxdesc_ptr->length;
+
+	dma_cache_maint(skb_ptr->data, len, PCI_DMA_FROMDEVICE);
+
+#ifdef CONFIG_STR9100_PORT_BASE
+	if (rxdesc_ptr->sp == 0) {
+		/*
+		 * Note this packet is from GSW Port 0, and the device index of GSW Port 0 is 1
+		 * Note the device index = 0 is for internal loopback device
+		 */
+		//skb_ptr->dev = STAR_GSW_LAN_DEV;
+		skb_ptr->dev = NET_DEV0;
+		if (skb_ptr->dev)
+			goto determine_dev_ok;
+	} else {
+		// Note this packet is from GSW Port 1, and the device index of GSW Port 1 is 2
+		//skb_ptr->dev = STAR_GSW_WAN_DEV;
+		skb_ptr->dev = NET_DEV1;
+		if (skb_ptr->dev)
+			goto determine_dev_ok;
+	}
+
+#endif /* CONFIG_STR9100_PORT_BASE */
+
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	if (rxdesc_ptr->hr == 0x27 && star9100_shnat_hook_ready) {
+		if(star9100_shnat_pci_fp_getdev_hook(skb_ptr)){
+			skb_put(skb_ptr, len);
+
+#if CONFIG_HAVE_VLAN_TAG
+	#define PPPOE_ID_1_LOC 16
+	#define PPPOE_ID_2_LOC 17
+#else
+	#define PPPOE_ID_1_LOC 12
+	#define PPPOE_ID_2_LOC 13
+#endif
+
+			if (skb_ptr->data[PPPOE_ID_1_LOC] == 0x88 && skb_ptr->data[PPPOE_ID_2_LOC]==0x64) { // pppoe session 
+				/* Remove PPPoE Header */
+                memmove(skb_ptr->data+8, skb_ptr->data, 12); 
+                skb_ptr->data+=8; 
+                skb_ptr->len-=8; 
+                skb_ptr->data[PPPOE_ID_1_LOC]=0x08; 
+                skb_ptr->data[PPPOE_ID_2_LOC]=0x0; 
+       		 } else { 
+				/* Remove VLAN Tag */
+#ifdef CONFIG_HAVE_VLAN_TAG
+				memmove(skb_ptr->data + 4, skb_ptr->data, 12);
+				skb_ptr->len-=4;
+				skb_ptr->data+=4;
+#endif
+			} 
+			skb_ptr->dev->hard_start_xmit(skb_ptr, skb_ptr->dev);
+			return 0;
+			}
+	}
+#endif /* CONFIG_STAR9100_SHNAT_PCI_FASTPATH */
+
+RECV_PACKET:
+
+#ifdef CONFIG_STR9100_VLAN_BASE
+
+#ifdef CONFIG_HAVE_VLAN_TAG
+
+
+// 20060922 descent
+	{ // NIC MODE off
+
+		const char lan_tag[]={0x81, 0x00, 0x00, 0x01};
+		const char wan_tag[]={0x81, 0x00, 0x00, 0x02};
+
+
+
+		if (memcmp(skb_ptr->data+12, lan_tag,4)==0) {
+			//printk("lan dev\n");
+			skb_ptr->dev = STAR_GSW_LAN_DEV;
+		} else if (memcmp(skb_ptr->data+12, wan_tag,4)==0) {
+			//printk("wan dev\n");
+			skb_ptr->dev = STAR_GSW_WAN_DEV;
+		} else {
+			PDEBUG("no vlan tag\n");
+			//print_packet(skb_ptr->data, 32);
+			goto freepacket;
+
+		}
+// 20070503 descent
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+		// let 8021Q to determine vlan tag
+#else  /* defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE) */
+		memmove(skb_ptr->data + 4, skb_ptr->data, 12);
+		//skb_ptr->data += 4; 
+		skb_reserve(skb_ptr, 4);
+		len -= 4; // minus 4 byte vlan tag
+#endif /* defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE) */
+
+#else  /* CONFIG_HAVE_VLAN_TAG */
+	
+// 20060922 descent
+#ifdef CONFIG_NIC_MODE
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+// do nothing
+#else // defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	// if NIC MODE on
+        if ( ((GSW_SWITCH_CONFIG >> 30) & 0x1) ==1){
+		const char lan_tag[]={0x81, 0x00, 0x00, 0x01};
+		const char wan_tag[]={0x81, 0x00, 0x00, 0x02};
+
+		//printk("NIC mode on\n");
+		if (memcmp(skb_ptr->data+12, lan_tag,4)==0) {
+			//printk("lan dev\n");
+			skb_ptr->dev = STAR_GSW_LAN_DEV;
+		} else if (memcmp(skb_ptr->data+12, wan_tag,4)==0) {
+			//printk("wan dev\n");
+			skb_ptr->dev = STAR_GSW_WAN_DEV;
+		} else {
+			//printk("no vlan tag\n");
+			//print_packet(skb_ptr->data, 32);
+			goto freepacket;
+
+		}
+
+		memmove(skb_ptr->data + 4, skb_ptr->data, 12);
+		skb_ptr->data += 4; 
+		goto determine_dev_ok;
+
+	}
+#endif // defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#endif
+// 20060922 descent end
+
+	src_mac = skb_ptr->data + 6; // get source mac address
+
+	// use gid and source mac to serarch arl table
+	vlan_gid = 1; // lan
+	if (star_gsw_search_arl_table(src_mac, vlan_gid)) {
+		//printk("STAR_GSW_LAN_DEV\n");
+		skb_ptr->dev = STAR_GSW_LAN_DEV;
+		#ifdef STR9100_GSW_FAST_AGE_OUT
+		star_gsw_del_arl_table(src_mac, vlan_gid);
+		#endif
+		goto determine_dev_ok;
+	} else {
+		vlan_gid = 0; // wan
+		if (star_gsw_search_arl_table(src_mac, vlan_gid)) {
+			//printk("STAR_GSW_WAN_DEV\n");
+			skb_ptr->dev = STAR_GSW_WAN_DEV;
+			#ifdef STR9100_GSW_FAST_AGE_OUT
+			star_gsw_del_arl_table(src_mac, vlan_gid);
+			#endif
+			goto determine_dev_ok;
+		} else {
+			PDEBUG("not determine come from lan or wan\n"); // should not go here
+			PDEBUG("not determine come from lan or wan\n"); // should not go here
+			goto freepacket;
+		}
+	}
+
+#endif // CONFIG_HAVE_VLAN_TAG
+
+#endif /* CONFIG_STR9100_VLAN_BASE */
+
+
+determine_dev_ok:
+	skb_put(skb_ptr, len);
+
+
+
+	if (skb_ptr->dev!=NULL) {
+		priv = netdev_priv(skb_ptr->dev);
+	}
+	else{
+		PDEBUG("skb_ptr->dev==NULL\n");
+		//goto freepacket;
+	}
+
+#ifdef STAR_GSW_RX_HW_CHECKSUM
+	if (rxdesc_ptr->ipf == 1 || rxdesc_ptr->l4f == 1) {
+		if (rxdesc_ptr->prot != 0x11) {
+			skb_ptr->ip_summed = CHECKSUM_NONE;
+		} else {
+			// CheckSum Fail
+			priv->stats.rx_errors++;
+			goto freepacket;
+		}
+	} else {
+			skb_ptr->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+#else
+	skb_ptr->ip_summed = CHECKSUM_NONE;
+#endif
+
+	// this line must, if no, packet will not send to network layer
+	skb_ptr->protocol = eth_type_trans(skb_ptr, skb_ptr->dev);
+	//skb_ptr->protocol = htons(ETH_P_8021Q);
+
+#ifndef CONFIG_STAR_GSW_BRIDGE
+	// send any packet in bridge mode
+	/*
+	 * This is illegality packet so drop it.
+	*/
+	if (skb_ptr->protocol == htons(ETH_P_802_2)) {
+		PDEBUG("ETH_P_802_2\n");
+		goto freepacket;
+	}
+#endif
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+	skb_ptr->dev->last_rx = jiffies;
+
+
+	//PRINT_PACKET(skb_ptr->data, 32, "RX")
+
+	// if netif_rx any package, will let this driver core dump.
+#ifdef CONFIG_STAR_GSW_NAPI
+	netif_receive_skb(skb_ptr);
+#else
+	netif_rx(skb_ptr);
+#endif
+
+	return 0;
+
+freepacket:
+	dev_kfree_skb_any(skb_ptr);
+	return 0;
+}
+
+#ifdef CONFIG_STAR_GSW_NAPI
+void star_gsw_receive_packet(int mode, int *work_done, int work_to_do)
+#else
+void star_gsw_receive_packet(int mode)
+#endif
+{
+	int fssd_index;
+	int fssd_current;
+	STAR_GSW_RXDESC volatile *rxdesc_ptr = rxring.vir_addr + rxring.cur_index;
+	struct sk_buff *skb_ptr;
+#ifndef CONFIG_STAR_GSW_NAPI
+	int fsqf = 0; // Queue Full Mode =0
+#endif
+	int i, rxcount = 0;
+	GSW_READ_FSSD(fssd_current);
+	fssd_index = (fssd_current - (u32)rxring.phy_addr) >> 4;
+
+	if (fssd_index > rxring.cur_index) {
+		rxcount = fssd_index - rxring.cur_index;
+	} else if (fssd_index < rxring.cur_index) {
+		rxcount = (STAR_GSW_MAX_RFD_NUM - rxring.cur_index) + fssd_index;
+	} else {
+		if (rxdesc_ptr->cown == 0) {
+			goto receive_packet_exit;
+		} else {
+			// Queue Full
+#ifndef CONFIG_STAR_GSW_NAPI
+			fsqf = 1;
+#endif
+			rxcount = STAR_GSW_MAX_RFD_NUM;
+			//set_bit(0, &is_qf);
+		}
+	}
+
+#ifndef CONFIG_STAR_GSW_NAPI
+	if (mode == 1) {
+		fsqf = 1;
+		rxcount = STAR_GSW_MAX_RFD_NUM;
+	}
+#endif
+
+	for (i = 0; i < rxcount; i++) {
+#ifdef CONFIG_STAR_GSW_NAPI
+		if (*work_done >= work_to_do)
+			break;
+		++(*work_done);
+#endif
+		if (rxdesc_ptr->cown != 0) {
+			// Alloc New skb_buff 
+			skb_ptr = star_gsw_alloc_skb();
+			// Check skb_buff
+			if (skb_ptr != NULL) {
+				star_gsw_get_rfd_buff(rxring.cur_index);
+				rxring.skb_ptr[rxring.cur_index] = skb_ptr;
+				rxdesc_ptr->data_ptr	= (u32)virt_to_phys(skb_ptr->data);
+				rxdesc_ptr->length	= MAX_PACKET_LEN;	
+				rxdesc_ptr->cown	= 0; // set cbit to 0 for CPU Transfer	
+			} else {
+				// TODO:
+				// I will add dev->lp.stats->rx_dropped, it will effect the performance
+				PDEBUG("%s: Alloc sk_buff fail, reuse the buffer\n", __FUNCTION__);
+				rxdesc_ptr->cown	= 0; // set cbit to 0 for CPU Transfer	
+				return;
+			}
+		}
+
+		if (rxring.cur_index == (STAR_GSW_MAX_RFD_NUM - 1)) {
+			rxring.cur_index	= 0;
+			rxdesc_ptr		= rxring.vir_addr;
+		} else {
+			rxring.cur_index++;
+			rxdesc_ptr++;
+		}
+	}
+
+#ifndef CONFIG_STAR_GSW_NAPI
+	if (fsqf) {
+		rxring.cur_index = fssd_index;
+		mb();
+		GSW_FS_DMA_START();
+	}
+#endif
+
+receive_packet_exit:
+	return;
+}
+
+#ifdef FREE_TX_SKB_MULTI
+#define MAX_TX_SKB_FREE_NUM     16
+#endif
+
+
+static int star_gsw_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct star_gsw_private *priv = netdev_priv(dev);
+	STAR_GSW_TXDESC volatile *txdesc_ptr;
+	unsigned long flags;
+	u16 vlan_tag;
+
+#ifdef FREE_TX_SKB_MULTI
+	int i;
+	int tssd_index;
+	int tssd_current;
+	int skb_free_count = 0;
+	struct sk_buff *skb_free[MAX_TX_SKB_FREE_NUM];
+#endif
+
+
+#if defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	int org_index;
+	int cur_index;
+
+	unsigned int f;
+	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+	unsigned int len = skb->len - skb->data_len;
+	unsigned int offset;
+
+#ifndef FREE_TX_SKB_MULTI
+	int skb_free_count = 0;
+	struct sk_buff *skb_free[MAX_SKB_FRAGS];
+#endif
+#else /* defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG) */
+#ifndef FREE_TX_SKB_MULTI
+	struct sk_buff *skb_free = NULL;
+#endif
+#endif /* defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG) */
+
+	HAL_GSW_TS_DMA_STOP();
+	spin_lock_irqsave(&star_gsw_send_lock, flags);
+
+#ifdef FREE_TX_SKB_MULTI
+	HAL_GSW_READ_TSSD(tssd_current);
+	tssd_index = (tssd_current - (u32)txring.phy_addr) >> 4;
+
+	if (tssd_index > txring.to_free_index) {
+		skb_free_count = tssd_index - txring.to_free_index;
+	} else if (tssd_index < txring.to_free_index) {
+		skb_free_count = STAR_GSW_MAX_TFD_NUM + tssd_index - txring.to_free_index;
+	}
+
+	if (skb_free_count >= MAX_TX_SKB_FREE_NUM) {
+		int count = 0;
+		for (i = 0; i < skb_free_count; i++) {
+			txdesc_ptr = txring.vir_addr + txring.to_free_index;
+			if (txdesc_ptr->cown == 0) {
+				break;
+			}
+			if (txring.skb_ptr[txring.to_free_index]) {
+				skb_free[count++] = txring.skb_ptr[txring.to_free_index];
+				txring.skb_ptr[txring.to_free_index] = NULL;
+			}
+			txring.to_free_index++;
+			if (txring.to_free_index == STAR_GSW_MAX_TFD_NUM) {
+				txring.to_free_index = 0;
+			}
+			if (count == MAX_TX_SKB_FREE_NUM) {
+				break;
+			}
+		}
+		skb_free_count = count;
+	} else {
+		skb_free_count = 0;
+	}
+#endif
+
+
+
+#if defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	org_index = txring.cur_index;
+	cur_index = txring.cur_index;
+	//printk("nr_frags: %d\n", nr_frags);
+	for (f = 0; f < (nr_frags + 1); f++) {
+		txdesc_ptr = txring.vir_addr + cur_index;
+
+		if (txdesc_ptr->cown == 0) {
+			spin_unlock_irqrestore(&star_gsw_send_lock, flags);
+			// re-queue the skb
+			return 1;
+		}
+
+#ifndef FREE_TX_SKB_MULTI
+		if (txring.skb_ptr[cur_index]) {
+			skb_free[skb_free_count++] = txring.skb_ptr[cur_index];
+#ifdef STAR_GSW_TIMER
+			txring.to_free_index = cur_index + 1;
+			if (txring.to_free_index == STAR_GSW_MAX_TFD_NUM) {
+				txring.to_free_index = 0;
+			}
+#endif
+		}
+#endif
+
+		if (f == 0) {
+			txdesc_ptr->fs		= 1;
+		} else {
+			txdesc_ptr->fs		= 0;
+		}
+		if (f == nr_frags) {
+			txdesc_ptr->ls		= 1;
+		} else {
+			txdesc_ptr->ls		= 0;
+		}
+
+#if 0
+		if (skb->protocol == __constant_htons(ETH_P_IP)) {
+			txdesc_ptr->ico = 1;
+			if (skb->nh.iph->protocol == IPPROTO_UDP) {
+				txdesc_ptr->uco = 1;
+				txdesc_ptr->tco = 0;
+			} else if (skb->nh.iph->protocol == IPPROTO_TCP) {
+				txdesc_ptr->uco = 0;
+				txdesc_ptr->tco = 1;
+			} else {
+				txdesc_ptr->uco = 0;
+				txdesc_ptr->tco = 0;
+			}
+		} else {
+			txdesc_ptr->ico = 0;
+			txdesc_ptr->uco = 0;
+			txdesc_ptr->tco = 0;
+		}
+#endif
+
+		txdesc_ptr->interrupt = 0;
+		txdesc_ptr->fr = 1;
+
+
+
+#ifdef CONFIG_STR9100_VLAN_BASE
+		if (priv->pmap==-1) {
+			txdesc_ptr->insv	= 1;
+			txdesc_ptr->pmap	= 1; // MAC0
+			if (dev == STAR_GSW_WAN_DEV) {
+				txdesc_ptr->vid	= VLAN0_GROUP_ID; 
+			} else {
+				txdesc_ptr->vid	= VLAN1_GROUP_ID; 
+			}
+		}
+#endif // CONFIG_STR9100_VLAN_BASE
+
+#ifdef CONFIG_STR9100_PORT_BASE
+		if (priv->pmap != -1) {
+			txdesc_ptr->insv	= 0;
+			txdesc_ptr->pmap	= priv->pmap;
+		}
+#endif
+
+		cur_index++;
+		if (cur_index == STAR_GSW_MAX_TFD_NUM) {
+			cur_index = 0;
+		}
+	} // end for (f = 0; f < (nr_frags + 1); f++) 
+
+	txdesc_ptr = (txring.vir_addr + txring.cur_index);
+	txdesc_ptr->data_ptr			= virt_to_phys(skb->data);
+	if ((nr_frags == 0) && (len < MIN_PACKET_LEN)) {
+		txdesc_ptr->length		= MIN_PACKET_LEN;
+		memset(skb->data + len, 0x00, MIN_PACKET_LEN - len);
+	} else {
+		txdesc_ptr->length		= len;
+	}
+	if (nr_frags) {
+		txring.skb_ptr[txring.cur_index]	= NULL;
+	} else {
+		txring.skb_ptr[txring.cur_index]	= skb;
+	}
+	dma_cache_maint(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+
+#if 0
+	printk("txdesc_ptr : %x\n", txdesc_ptr);
+	printk("txdesc_ptr->length: %d\n", txdesc_ptr->length);
+	printk("txdesc_ptr->insv : %d\n", txdesc_ptr->insv);
+	printk("txdesc_ptr->pmap : %d\n", txdesc_ptr->pmap);
+	printk("txdesc_ptr->vid : %d\n", txdesc_ptr->vid);
+#endif
+
+	txring.cur_index++;
+	if (txring.cur_index == STAR_GSW_MAX_TFD_NUM) {
+		txring.cur_index = 0;
+	}
+
+	for (f = 0; f < nr_frags; f++) {
+		struct skb_frag_struct *frag; 
+		txdesc_ptr = txring.vir_addr + txring.cur_index;
+		frag = &skb_shinfo(skb)->frags[f]; 
+		len = frag->size; 
+		offset = frag->page_offset; 
+
+		txdesc_ptr->data_ptr		= virt_to_phys(page_address(frag->page) + offset);
+		txdesc_ptr->length		= len;
+		if (f == (nr_frags - 1)) {
+			txring.skb_ptr[txring.cur_index] = skb;
+		} else {
+			txring.skb_ptr[txring.cur_index] = NULL;
+		}
+		dma_cache_maint(page_address(frag->page) + offset, txdesc_ptr->length, PCI_DMA_TODEVICE);
+
+		txring.cur_index++;
+		if (txring.cur_index == STAR_GSW_MAX_TFD_NUM) {
+			txring.cur_index = 0;
+		}
+	}
+
+	for (f = 0; f < (nr_frags + 1); f++) {
+		txdesc_ptr = txring.vir_addr + org_index;
+
+		txdesc_ptr->cown = 0;
+
+		org_index++;
+		if (org_index == STAR_GSW_MAX_TFD_NUM) {
+			org_index = 0;
+		}
+	}
+
+#else // defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	txdesc_ptr = txring.vir_addr + txring.cur_index;
+
+
+	if (txdesc_ptr->cown == 0) { // This TFD is busy
+		spin_unlock_irqrestore(&star_gsw_send_lock, flags);
+		// re-queue the skb
+		return 1;
+	}
+
+	if (txdesc_ptr->data_ptr != 0) {
+		// MUST TODO: Free skbuff
+		dev_kfree_skb_any(txring.skb_ptr[txring.cur_index]);
+	}
+
+	/* clean dcache range  in order that data synchronization*/
+	txring.skb_ptr[txring.cur_index]	= skb;
+	txdesc_ptr->data_ptr			= virt_to_phys(skb->data);
+
+        if (skb->len < MIN_PACKET_LEN) {
+                txdesc_ptr->length              = MIN_PACKET_LEN;
+                memset(skb->data + skb->len, 0x00, MIN_PACKET_LEN - skb->len);
+        } else {
+                txdesc_ptr->length              = skb->len;
+        }
+
+ 
+
+        /* clean dcache range  in order that data synchronization*/
+        dma_cache_maint(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+
+
+	// 20060922 descent
+	// if NIC MODE on
+	#ifdef CONFIG_NIC_MODE
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	// do nothing
+#else
+        if ( ((GSW_SWITCH_CONFIG >> 30) & 0x1) ==1){
+		const char lan_tag[]={0x81, 0x00, 0x00, 0x01};
+		const char wan_tag[]={0x81, 0x00, 0x00, 0x02};
+		unsigned char	data; /* Data head pointer */
+
+		// insert vlan tag and move other byte to back
+		memmove(skb->data+16, skb->data + 12, skb->len-12);
+		skb->len+=4;
+
+                txdesc_ptr->length = skb->len;
+
+		if (dev == STAR_GSW_LAN_DEV) {
+			memcpy(skb->data+12, lan_tag, 4);
+		}
+		if (dev == STAR_GSW_WAN_DEV) {
+			memcpy(skb->data+12, wan_tag, 4);
+		}
+        	dma_cache_maint(skb->data, txdesc_ptr->length, PCI_DMA_TODEVICE);
+	}
+#endif //defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	#endif // ifdef CONFIG_NIC_MODE
+	// 20060922 descent end
+
+	/*
+	* Basically, according to the result of the search of the destination 
+	* address in the routing table, the specific network interface will be 
+	* correctly selected
+	* According to the device entry index value, we can know the packet will 
+	* be destined for LAN port (port 0) or WAN port (port 1)
+	*
+	* Note:
+	* device entry index = 0 means local loopback network interface
+	* device entry index = 1 means GSW port 0 for LAN port network interface
+	* device entry index = 2 means GSW port 1 for WAN port network interface
+	* and also note:
+	* Force Route Port Map = 1 : GSW port 0
+	*                      = 2 : GSW port 1
+	*                      = 4 : GSW CPU port 
+	*/     
+
+
+	PDEBUG("\n00 priv->pmap: %d\n", priv->pmap);
+
+
+#ifdef CONFIG_STR9100_VLAN_BASE
+	PDEBUG("CONFIG_STR9100_VLAN_BASE\n");
+
+
+
+	if (priv->pmap==-1)
+	{
+		// 20060922 descent
+		// if NIC MODE on
+		#ifdef CONFIG_NIC_MODE
+       		if ( ((GSW_SWITCH_CONFIG >> 30) & 0x1) ==1)
+		{
+			txdesc_ptr->insv	= 0;
+		}
+		else
+		#endif
+		// 20060922 descent end
+		{
+			txdesc_ptr->insv	= 1;
+		}
+
+
+		PDEBUG("txdesc_ptr->insv	= 1;\n");
+
+
+
+
+		txdesc_ptr->pmap	= 1; // MAC0
+
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	// let 8021Q insert vlan tag
+	// so insv set to 0
+	txdesc_ptr->insv	= 0;
+	#if 0
+        if (priv->vlgrp && vlan_tx_tag_present(skb)) {
+                //vlan_tag = cpu_to_be16(vlan_tx_tag_get(skb));
+                //vlan_tag = ntohl(vlan_tx_tag_get(skb));
+                //vlan_tag = (vlan_tx_tag_get(skb));
+                vlan_tag = cpu_to_le16(vlan_tx_tag_get(skb));
+		//printk("vlan_tag : %x\n", vlan_tag);
+		if (vlan_tag == 1) {
+			txdesc_ptr->vid	= VLAN1_GROUP_ID; // lan
+		}
+		if (vlan_tag == 2) {
+			txdesc_ptr->vid	= VLAN0_GROUP_ID; // wan
+		}
+	}
+	#endif
+#else // #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+
+
+
+		PDEBUG("txdesc_ptr->pmap = 1\n");
+		if (dev == STAR_GSW_WAN_DEV) {
+			txdesc_ptr->vid	= VLAN0_GROUP_ID; 
+			PDEBUG("VLAN0_GROUP_ID: %d\n", VLAN0_GROUP_ID);
+		} else {
+			txdesc_ptr->vid	= VLAN1_GROUP_ID; 
+			PDEBUG("VLAN1_GROUP_ID: %d\n", VLAN1_GROUP_ID);
+		}
+
+#endif // end #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+
+	}
+
+#endif // CONFIG_STR9100_VLAN_BASE
+
+#ifdef CONFIG_STR9100_PORT_BASE
+	if (priv->pmap != -1)
+	{
+		txdesc_ptr->insv	= 0;
+		PDEBUG("txdesc_ptr->insv        = 0;\n");
+		txdesc_ptr->pmap	= priv->pmap;
+		PDEBUG("txdesc_ptr->pmap	= priv->pmap;\n");
+	}
+	PDEBUG("CONFIG_STR9100_PORT_BASE\n");
+#endif
+	PDEBUG("txdesc_ptr->pmap: %d\n", txdesc_ptr->pmap);
+
+	txdesc_ptr->fr		= 1;
+
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	if (star9100_shnat_pci_fp_forward_skb_ptr == 0) 
+		goto SEND_PACKET;
+	if(priv->pmap == PORT_BASE_PMAP_TUN_PORT){
+
+		struct iphdr *iph = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
+		star9100_arp_table volatile *arp_table;
+		u32			fp_gvid = 0;
+
+		arp_table = star9100_shnat_getarptable_hook(iph->saddr);
+		if(arp_table != NULL){
+			fp_gvid = arp_table->unused &= 0x7; 
+		}
+#if 0
+	   printk("[SEND PACKET] FP Path send_packet\n");
+#endif
+	   txdesc_ptr->fr = 0;
+	   txdesc_ptr->insv  = 1;
+	   txdesc_ptr->vid = fp_gvid;
+#if 0
+	   print_packet(skb->data,128);
+#endif
+	}
+#endif /*  CONFIG_STAR9100_SHNAT_PCI_FASTPATH */
+
+SEND_PACKET:
+
+	txdesc_ptr->fs		= 1;
+	txdesc_ptr->ls		= 1;
+	// Wake interrupt
+	txdesc_ptr->interrupt	= 0;
+	txdesc_ptr->cown	= 0;
+
+
+	if (txring.cur_index == (STAR_GSW_MAX_TFD_NUM - 1)) {
+		txring.cur_index = 0;
+	} else {
+		txring.cur_index++;
+	}
+	
+
+#endif // defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	mb();
+	GSW_TS_DMA_START();
+
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	dev->trans_start = jiffies;
+
+sendpacket_exit:
+	spin_unlock_irqrestore(&star_gsw_send_lock, flags);
+
+#ifdef FREE_TX_SKB_MULTI
+	for (i = 0; i < skb_free_count; i++) {
+		dev_kfree_skb(skb_free[i]);
+	}
+#else
+#if defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	for (f = 0; f < skb_free_count; f++) {
+		dev_kfree_skb(skb_free[f]);
+	}
+#else
+	if (skb_free) {
+		dev_kfree_skb(skb_free);
+	}
+#endif
+#endif
+
+#ifdef STAR_GSW_TIMER
+	mod_timer(&star_gsw_timer, jiffies + 10);
+#endif
+
+
+
+
+	return 0;
+}
+
+// modify parameter type by descent.
+// move dev->dev_addr to set mac function.
+static void star_gsw_set_mac_addr(int index, struct net_device *dev, void *addr)
+{
+	const char *mac = ((struct sockaddr *)addr)->sa_data;
+	int mac_len = dev->addr_len;
+	gsw_arl_table_entry_t arl_table_entry;
+
+	memcpy(dev->dev_addr, mac, 6);
+
+	//printk("addr: %x:%x:%x:%x:%x:%x\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+	// erase old mac
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[index].vlan_gid;
+	arl_table_entry.age_field	= 0x0; // invalid mean erase this entry
+	arl_table_entry.port_map	= star_gsw_info.vlan[index].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[index].vlan_mac, 6);
+	star_gsw_write_arl_table_entry(&arl_table_entry);
+
+	// copy new mac to star_gsw_info
+	memcpy(star_gsw_info.vlan[index].vlan_mac, mac, mac_len);
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[index].vlan_gid;
+	arl_table_entry.age_field	= 0x7;
+	arl_table_entry.port_map	= star_gsw_info.vlan[index].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[index].vlan_mac, 6);
+	star_gsw_write_arl_table_entry(&arl_table_entry);
+}
+
+#if 0
+static void star_gsw_set_mac_addr(int index, const char *mac, int mac_len)
+{
+	gsw_arl_table_entry_t arl_table_entry;
+
+	// erase old mac
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[index].vlan_gid;
+	arl_table_entry.age_field	= 0x0; // invalid mean erase this entry
+	arl_table_entry.port_map	= star_gsw_info.vlan[index].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[index].vlan_mac, 6);
+	star_gsw_write_arl_table_entry(&arl_table_entry);
+
+	// copy new mac to star_gsw_info
+	memcpy(star_gsw_info.vlan[index].vlan_mac, mac, mac_len);
+	arl_table_entry.filter		= 0;
+	arl_table_entry.vlan_mac	= 1;
+	arl_table_entry.vlan_gid	= star_gsw_info.vlan[index].vlan_gid;
+	arl_table_entry.age_field	= 0x7;
+	arl_table_entry.port_map	= star_gsw_info.vlan[index].vlan_group;
+	memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[index].vlan_mac, 6);
+	star_gsw_write_arl_table_entry(&arl_table_entry);
+}
+#endif
+
+
+static int star_gsw_set_lan_mac_addr(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock_addr = addr;
+	struct star_gsw_private *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+	star_gsw_set_mac_addr(LAN_GID, dev, addr);
+	//star_gsw_set_mac_addr(LAN_GID, sock_addr->sa_data, dev->addr_len);
+	//star_gsw_set_mac_addr(0, sock_addr->sa_data, dev->addr_len);
+	spin_unlock_irq(&priv->lock);
+
+	return 0;
+}
+
+static int star_gsw_set_wan_mac_addr(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock_addr = addr;
+	struct star_gsw_private *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+	star_gsw_set_mac_addr(WAN_GID, dev, addr);
+	spin_unlock_irq(&priv->lock);
+
+	return 0;
+}
+
+// current dorado2 use this function
+static int star_gsw_set_ewc_mac_addr(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock_addr = addr;
+	struct star_gsw_private *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+	//star_gsw_set_mac_addr(2, sock_addr->sa_data, dev->addr_len);
+	star_gsw_set_mac_addr(2, dev, addr);
+	spin_unlock_irq(&priv->lock);
+
+	return 0;
+}
+
+static void __init star_gsw_hw_init(void)
+{
+	u32 mac_port_config;
+	int i;
+	u32 cfg_reg = 0;
+
+	cfg_reg = PWRMGT_SOFTWARE_RESET_CONTROL;
+	// set reset bit to HIGH active;
+	cfg_reg |=0x10;
+	PWRMGT_SOFTWARE_RESET_CONTROL = cfg_reg;
+
+	//pulse delay
+	udelay(100);
+
+	// set reset bit to LOW active;
+	cfg_reg &=~0x10;
+	PWRMGT_SOFTWARE_RESET_CONTROL = cfg_reg;
+
+	//pulse delay
+	udelay(100);
+
+	// set reset bit to HIGH active;
+	cfg_reg |= 0x10;
+	PWRMGT_SOFTWARE_RESET_CONTROL = cfg_reg; 
+
+	for (i = 0; i < 1000; i++) {
+		cfg_reg = GSW_BIST_RESULT_TEST_0;
+		if ((cfg_reg & BIT(17))) {
+			break;
+		} else {
+			udelay(10);
+		}
+	}
+	// Set to defaule value
+	GSW_SWITCH_CONFIG = 0x007AA7A1;
+
+	// Set Mac port 0 to default value
+	GSW_MAC_PORT_0_CONFIG = 0x00423D80;
+
+	// Set Mac port 1 to default value
+	GSW_MAC_PORT_1_CONFIG = 0x00423D80;
+
+	// Set CPU port to default Value
+	GSW_CPU_PORT_CONFIG = 0x004C0000;
+
+	// Disable Port 0
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+	mac_port_config |= ((0x1 << 18)); 
+	GSW_MAC_PORT_0_CONFIG = mac_port_config; 
+
+	// Disable Port 1
+	mac_port_config = GSW_MAC_PORT_1_CONFIG;
+	mac_port_config |= ((0x1 << 18)); 
+	GSW_MAC_PORT_1_CONFIG = mac_port_config; 
+}
+
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+static int tundev_close(struct net_device *dev){
+	netif_stop_queue(dev);
+	printk("Close Orion Fast Path Tunnel Device \n");
+	return 0;
+}
+static int tundev_open(struct net_device *dev){
+	netif_start_queue(dev);
+	printk("Open Orion Fast Path Tunnel Device \n");
+	return 0;
+}
+static void tundev_init(struct net_device *dev){
+	return;
+}
+static int __init star_gsw_probe_tun(void){
+	struct net_device *netdev;
+	struct star_gsw_private *priv;
+	int err=0;
+
+	//netdev = alloc_netdev(sizeof(struct star_gsw_private),"fp",tundev_init);
+	netdev = alloc_etherdev(sizeof(struct star_gsw_private));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto progend;
+	}
+
+	sprintf(netdev->name,"fp"); // force name
+
+	priv = netdev_priv(netdev);
+	memset(priv, 0, sizeof(struct star_gsw_private));
+	spin_lock_init(&priv->lock);
+
+	//netdev->base_addr			= IO_ADDRESS(GSW_BASE_ADDR);
+	netdev->base_addr			= 0;
+	netdev->stop				= tundev_close;
+	netdev->hard_start_xmit		= star_gsw_send_packet;
+	netdev->open				= tundev_open;
+        netdev->do_ioctl = gsw_do_ioctl;
+
+	//netdev->set_mac_address		= star_gsw_set_lan_mac_addr;
+
+	netdev->features			= NETIF_F_NO_CSUM;
+	netdev->hard_header			= NULL;
+	netdev->rebuild_header 		= NULL;
+	netdev->hard_header_cache	= NULL;
+	netdev->header_cache_update = NULL;
+	netdev->hard_header_parse   = NULL;
+	netdev->flags				= 0; // Don't need any flags
+	priv->pmap			= PORT_BASE_PMAP_TUN_PORT;
+
+
+
+	err = register_netdev(netdev);
+	if (err) {
+		free_netdev(netdev);
+		err = -ENOMEM;
+	}
+
+progend:
+	return err;
+}
+#endif
+
+
+static int __init star_gsw_probe(int port_type)
+{
+	struct net_device *netdev;
+	struct star_gsw_private *priv;
+	int err;
+        struct sockaddr sock_addr;
+
+
+	netdev = alloc_etherdev(sizeof(struct star_gsw_private));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+
+	SET_NETDEV_DEV(netdev, NULL);
+
+	priv = netdev_priv(netdev);
+	memset(priv, 0, sizeof(struct star_gsw_private));
+	spin_lock_init(&priv->lock);
+
+
+	//netdev->base_addr		= IO_ADDRESS(GSW_BASE_ADDR);
+	netdev->base_addr		= 0;
+	netdev->open			= star_gsw_open;
+	netdev->stop			= star_gsw_close;
+	netdev->hard_start_xmit		= star_gsw_send_packet;
+	netdev->tx_timeout		= star_gsw_timeout;
+	netdev->get_stats		= star_gsw_get_stats;
+#if defined(MAX_SKB_FRAGS) && defined(STAR_GSW_SG)
+	netdev->features		= NETIF_F_IP_CSUM | NETIF_F_SG;
+#elif defined(STAR_GSW_TX_HW_CHECKSUM)
+	netdev->features		= NETIF_F_IP_CSUM;
+#endif
+
+#ifdef CONFIG_STAR_GSW_NAPI
+	netif_napi_add(netdev, &priv->napi, star_gsw_poll, 64);
+#endif
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	// do not let 8021Q module insert vlan tag
+	// can use the snippet code to get vlan tage
+	// if (priv->vlgrp && vlan_tx_tag_present(skb)) {
+	//   vlan_tag = cpu_to_be16(vlan_tx_tag_get(skb));
+        //netdev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+        netdev->features |= NETIF_F_HW_VLAN_RX; // remove NETIF_F_HW_VLAN_TX flag that 8021Q module to insert vlan tag.
+
+        netdev->vlan_rx_register = gsw_vlan_rx_register;
+        netdev->vlan_rx_kill_vid = gsw_vlan_rx_kill_vid;
+#endif
+
+
+
+	switch (port_type) {
+	case LAN_PORT:
+		netdev->set_mac_address	= star_gsw_set_lan_mac_addr;
+	        memcpy(sock_addr.sa_data, star_gsw_info.vlan[LAN_GID].vlan_mac, 6);
+	        star_gsw_set_lan_mac_addr(netdev, &sock_addr);
+		//priv->pmap		= PMAP_PORT0;
+		//priv->pmap		= PORT_BASE_PORT0;
+		priv->pmap		= PORT_BASE_PMAP_LAN_PORT;
+		break;
+
+	case WAN_PORT:
+		//netdev->open		= star_gsw_wan_open;
+		netdev->set_mac_address	= star_gsw_set_wan_mac_addr;
+	        memcpy(sock_addr.sa_data, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);
+	        star_gsw_set_wan_mac_addr(netdev, &sock_addr);
+		//priv->pmap		= PMAP_PORT1;
+		priv->pmap		= PORT_BASE_PMAP_WAN_PORT;
+		break;
+
+	case EWC_PORT:
+		//netdev->open		= star_gsw_ewc_open;
+		netdev->set_mac_address	= star_gsw_set_ewc_mac_addr;
+	        //memcpy(sock_addr.sa_data, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);
+		//priv->pmap		= PMAP_PORT1;
+		priv->pmap		= PORT_BASE_PMAP_EWC_PORT;
+		break;
+
+	default:
+		break;
+	}
+
+	err = register_netdev(netdev);
+	if (err) {
+        printk("Register network dev :%s failed \n", netdev->name);
+		goto err_register_netdev;
+	}
+
+
+
+	switch (port_type) {
+	case LAN_PORT:
+		STAR_GSW_LAN_DEV = netdev;
+		break;
+
+	case WAN_PORT:
+		STAR_GSW_WAN_DEV = netdev;
+
+
+		break;
+
+	case EWC_PORT:
+		PDEBUG("create ewc port\n");
+		STAR_GSW_EWC_DEV = netdev;
+		break;
+
+	default:
+		break;
+	}
+
+#if 0 
+	if (net_dev_array[0] == 0) {
+		net_dev_array[0] = netdev;
+	}
+#endif
+	++all_netdevice;
+	return 0;
+
+err_register_netdev:
+	free_netdev(netdev);
+
+err_alloc_etherdev:
+	return err;
+}
+
+#ifdef LINUX26
+extern struct proc_dir_entry *str9100_proc_dir;
+static int __init star_gsw_proc_init(void)
+{
+        star_gsw_proc_entry = create_proc_entry("gsw", S_IFREG | S_IRUGO, str9100_proc_dir);
+        if (star_gsw_proc_entry) {
+                star_gsw_proc_entry->read_proc = star_gsw_read_proc;
+                star_gsw_proc_entry->write_proc = star_gsw_write_proc;
+        }
+        return 1;
+}
+#endif
+
+
+#ifdef LINUX24
+static int __init star_gsw_proc_init(void)
+{
+	struct proc_dir_entry *procdir=0;
+
+	const char proc_str[]="str9100";
+
+	//str9100_gsw_procdir=proc_mkdir(proc_str, NULL);
+	
+        procdir=create_proc_str9100(PROC_STR);
+
+        if (procdir)
+        {
+		star_gsw_proc_entry = create_proc_entry("gsw", S_IFREG | S_IRUGO, procdir);
+		if (star_gsw_proc_entry) {
+			star_gsw_proc_entry->read_proc = star_gsw_read_proc;
+			star_gsw_proc_entry->write_proc = star_gsw_write_proc;
+		}
+		return 1;
+        }
+	else
+		return -1;
+	
+
+
+}
+#endif
+
+static int star_gsw_notify_reboot(struct notifier_block *nb, unsigned long event, void *ptr)
+{
+	u32 mac_port_config;
+
+	/* stop the DMA engine */
+	GSW_TS_DMA_STOP();
+	GSW_FS_DMA_STOP();
+
+	// disable Port 0
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+	mac_port_config |= ((0x1 << 18)); 
+	GSW_MAC_PORT_0_CONFIG = mac_port_config; 
+
+	// disable Port 1
+	mac_port_config = GSW_MAC_PORT_1_CONFIG;
+	mac_port_config |= ((0x1 << 18)); 
+	GSW_MAC_PORT_1_CONFIG = mac_port_config; 
+
+	// disable all interrupt status sources
+	GSW_DISABLE_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// clear previous interrupt sources
+	GSW_CLEAR_ALL_INTERRUPT_STATUS_SOURCES();
+
+	// disable all DMA-related interrupt sources
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_FSRC_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_TSQE_BIT_INDEX);
+	INTC_DISABLE_INTERRUPT_SOURCE(INTC_GSW_FSQF_BIT_INDEX);
+
+	// clear previous interrupt sources
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_TSTC_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSRC_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_TSQE_BIT_INDEX);
+	INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GSW_FSQF_BIT_INDEX);
+
+	return NOTIFY_DONE;
+}
+
+
+
+
+
+static int __init star_gsw_init_module(void)
+{
+	int err = 0;
+	u8 mac_num[6]; // get from flash
+
+	spin_lock_init(&star_gsw_send_lock);
+
+
+//#define CONFIG_GET_FLASH_MAC
+#ifdef CONFIG_GET_FLASH_MAC
+	char *mac_addr;
+
+	PRINT_INFO(KERN_INFO "%s", star_gsw_driver_version);
+	mac_addr=get_flash_env("ethaddr");
+	if (mac_addr)
+	{
+		printk("mac addr: %s\n", mac_addr);
+		printk("mac len: %d\n", strlen(mac_addr) );
+
+	}
+	sscanf(mac_addr ,"%x:%x:%x:%x:%x:%x", (unsigned int *)&mac_num[0], (unsigned int *)&mac_num[1], (unsigned int *)&mac_num[2], (unsigned int *)&mac_num[3], (unsigned int *)&mac_num[4], (unsigned int *)&mac_num[5]);
+	printk("flash mac : %x:%x:%x:%x:%x:%x\n", *mac_num,*(mac_num+1),*(mac_num+2), *(mac_num+3), *(mac_num+4), *(mac_num+5) );
+
+
+	memcpy(my_vlan0_mac, mac_num, 6);
+	++mac_num[5];
+	memcpy(my_vlan1_mac, mac_num, 6);
+	++mac_num[5];
+	memcpy(my_vlan2_mac, mac_num, 6);
+	++mac_num[5];
+	memcpy(my_vlan3_mac, mac_num, 6);
+
+
+
+#endif
+
+
+
+	star_gsw_hw_init();
+	err = star_gsw_buffer_alloc();
+	if (err != 0) {
+		return err;
+	}
+	star_gsw_vlan_init();
+	star_gsw_config_cpu_port();
+	init_switch();
+
+//#if 0
+	CREATE_NET_DEV0 
+	CREATE_NET_DEV1
+	CREATE_NET_DEV2
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	CREATE_NET_DEV_AD
+#endif
+
+	str9100_gsw_config_mac_port0();
+	str9100_gsw_config_mac_port1();
+
+#ifdef CONFIG_STAR_GSW_NAPI
+	{
+		struct star_gsw_private *priv;
+		STAR_NAPI_DEV = alloc_etherdev(sizeof(struct star_gsw_private));
+		if (!STAR_NAPI_DEV) {
+			printk("Cannot allocate NAPI virtual device \n");
+			BUG();
+		}
+
+		priv = netdev_priv(STAR_NAPI_DEV);
+		memset(priv, 0, sizeof(struct star_gsw_private));
+
+		netif_napi_add(STAR_NAPI_DEV, &priv->napi , star_gsw_poll, 64);
+        dev_hold(STAR_NAPI_DEV);
+        set_bit(__LINK_STATE_START, &STAR_NAPI_DEV->state);
+		}
+#endif
+//#endif
+
+#if 0
+	star_gsw_lan_init();
+
+#ifndef CONFIG_STAR_GSW_TYPE_9109
+	star_gsw_wan_init();
+#endif
+#ifdef CONFIG_STAR_GSW_TYPE_EWC
+	star_gsw_ewc_init();
+#endif
+#endif
+
+	star_gsw_proc_init();
+
+	register_reboot_notifier(&star_gsw_notifier_reboot);
+#ifdef STAR_GSW_TIMER
+        init_timer(&star_gsw_timer);
+        star_gsw_timer.function = &star_gsw_timer_func;
+        star_gsw_timer.data = (unsigned long)NULL;
+#endif
+
+
+	return 0;
+}
+
+static void __exit star_gsw_exit_module(void)
+{
+	int i=0;
+
+#if 1
+	for (i=0 ; i < all_netdevice ; ++i) {
+		char netdev_name[20];
+		struct net_device * netdev=0;
+
+		sprintf(netdev_name, "eth%d", i);
+		//printk("net_dev_array[0]: %x\n", net_dev_array[0]);
+		netdev=__dev_get_by_name(&init_net, netdev_name);
+		// if no unregister_netdev and free_netdev,
+		// after remove module, ifconfig will hang.
+		#if 1
+		if (netdev) {
+			unregister_netdev(netdev);
+			free_netdev(netdev);
+		}
+		#endif
+	}
+#endif
+
+#ifdef CONFIG_STAR_GSW_NAPI
+	free_netdev(STAR_NAPI_DEV);
+#endif
+
+#if 0
+	unregister_netdev(STAR_GSW_LAN_DEV);
+	free_netdev(STAR_GSW_LAN_DEV);
+
+	unregister_netdev(STAR_GSW_WAN_DEV);
+	free_netdev(STAR_GSW_WAN_DEV);
+#endif
+	//unregister_netdev(STAR_GSW_EWC_DEV);
+	//free_netdev(STAR_GSW_EWC_DEV);
+
+	unregister_reboot_notifier(&star_gsw_notifier_reboot);
+	star_gsw_buffer_free(); 
+}
+
+
+// this snippet code ref 8139cp.c
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+void gsw_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+        struct star_gsw_private *priv = netdev_priv(dev);
+        unsigned long flags;
+
+        spin_lock_irqsave(&priv->lock, flags);
+	printk("gsw_vlan_rx_register\n");
+        priv->vlgrp = grp;
+        spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+void gsw_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+        struct star_gsw_private *priv = netdev_priv(dev);
+        unsigned long flags;
+
+        spin_lock_irqsave(&priv->lock, flags);
+        if (priv->vlgrp)
+                priv->vlgrp->vlan_devices[vid] = NULL;
+        spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+#endif
+
+//#define CONFIG_SWITCH_IOCTL
+#ifdef CONFIG_SWITCH_IOCTL
+
+/* ADD MAC into ARL */
+/***
+ * add_mac_into_arl  -  add extra(without hnat support) my mac in ARL table.
+ * 
+ * INPUTS:
+ *        gid    -   vlan group (0-7)
+ *        mac    -   mac address
+ * 
+ * OUTPUTS:
+ *        None
+ * 
+ * RETURNS:
+ *        void
+ ***/
+int add_mac_into_arl(u16 gid, u8 *mac)
+{
+        gsw_arl_table_entry_t arl_table_entry;
+
+        arl_table_entry.filter          = 0;
+        arl_table_entry.vlan_mac        = 1;    // the MAC in this table entry is MY VLAN MAC 
+        arl_table_entry.vlan_gid        = gid;
+        arl_table_entry.age_field       = 0x7;  // static entry
+        arl_table_entry.port_map        = star_gsw_info.vlan[gid].vlan_group;
+        memcpy(arl_table_entry.mac_addr, mac, 6); 
+
+        if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+                //DEBUG_MSG(WARNING_MSG, "star_gsw_write_arl_table_entry fail\n");
+                return 1;
+        }
+
+        return 0; 
+}
+
+/* DEL MAC from ARL*/
+//void del_my_vlan_mac_2argu(u8 gid, u8 *mac)
+/***
+ * star_gsw_del_arl_table - delete my mac from ARL table
+ * 
+ * INPUTS:
+ *        mac      - mac address
+ *        vlan_gid - gid value 
+ * 
+ * OUTPUTS:
+ *        None
+ * 
+ * RETURNS:
+ *        0		-   successful
+ *
+ ***/
+void del_mac_from_arl(u8 gid, u8 *mac)
+{
+    gsw_arl_table_entry_t arl_table_entry;
+
+    // erase old mac
+    arl_table_entry.filter        = 0;
+    arl_table_entry.vlan_mac    = 1;
+    //arl_table_entry.vlan_gid    = star_gsw_info.vlan[gid].vlan_gid;
+    arl_table_entry.vlan_gid    = gid;
+    arl_table_entry.age_field    = 0x0; // invalid mean erase this entry
+    arl_table_entry.port_map    = star_gsw_info.vlan[gid].vlan_group;
+    memcpy(arl_table_entry.mac_addr, mac, 6);
+    star_gsw_write_arl_table_entry(&arl_table_entry);
+}
+
+
+/***
+ * del_my_vlan_mac  -  delete my mac of default setting from ARL table.
+ * 
+ * INPUTS:
+ *        gid    -   vlan group (0-7)
+ * 
+ * OUTPUTS:
+ *        None
+ * 
+ * RETURNS:
+ *        void
+ ***/
+void del_my_vlan_mac(u8 gid)
+{
+    gsw_arl_table_entry_t arl_table_entry; 
+
+    // erase old mac
+    arl_table_entry.filter        = 0; 
+    arl_table_entry.vlan_mac    = 1;
+    arl_table_entry.vlan_gid    = gid;
+    arl_table_entry.age_field    = 0x0; // invalidate this entry 
+    arl_table_entry.port_map    = star_gsw_info.vlan[gid].vlan_group;
+    memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[gid].vlan_mac, 6);
+    star_gsw_write_arl_table_entry(&arl_table_entry);
+}
+
+/***
+ * config_my_vlan_mac  -  change my mac default setting, according to 
+ * gid and vid value.
+ * 
+ * INPUTS:
+ *        gid    -   vlan group (0-7)
+ *        vid    -   vlan id (12 bits)
+ *        mac    -   mac address
+ * 
+ * OUTPUTS:
+ *        None
+ * 
+ * RETURNS:
+ *        0  -  successful
+ *        1  -  fail
+ ***/
+int config_my_vlan_mac(u16 gid, u16 vid, u8 *mac)
+{
+	gsw_arl_table_entry_t arl_table_entry; 
+
+        star_gsw_info.vlan[gid].vlan_gid          = gid;
+        star_gsw_info.vlan[gid].vlan_vid          = vid;
+        star_gsw_info.vlan[gid].vlan_group        = (PORT0 | CPU_PORT); // this case always (PORT0 | CPU_PORT)
+        star_gsw_info.vlan[gid].vlan_tag_flag     = 0;
+        memcpy(star_gsw_info.vlan[gid].vlan_mac, mac, 6);
+
+
+
+	arl_table_entry.filter          = 0;
+        arl_table_entry.vlan_mac        = 1;    // the MAC in this table entry is MY VLAN MAC
+        arl_table_entry.vlan_gid        = star_gsw_info.vlan[gid].vlan_gid;
+        arl_table_entry.age_field       = 0x7;  // static entry
+        arl_table_entry.port_map        = star_gsw_info.vlan[gid].vlan_group;
+        memcpy(arl_table_entry.mac_addr, star_gsw_info.vlan[gid].vlan_mac, 6);
+
+        if (!star_gsw_write_arl_table_entry(&arl_table_entry)) {
+		//DEBUG_MSG(WARNING_MSG, "star_gsw_write_arl_table_entry fail\n");
+        	return 1;
+        }
+
+	return 0;
+}
+
+#endif // end CONFIG_SWITCH_IOCTL
+
+// reference e100.c
+static int gsw_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	printk("gsw_do_ioctl\n");
+	return 0;
+}
+
+
+MODULE_AUTHOR("Star Corporation, <tech@starsemi.com>");
+MODULE_DESCRIPTION("Star Switch Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+
+
+module_init(star_gsw_init_module);
+module_exit(star_gsw_exit_module);
+
diff -Nur linux-2.6.35.11/drivers/net/str9100/star_gsw_config.h linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_config.h
--- linux-2.6.35.11/drivers/net/str9100/star_gsw_config.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_config.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,288 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __STAR_GSW_CONFIG_H__
+#define __STAR_GSW_CONFIG_H__
+
+
+// add by descent 2006/07/05
+// this debug macro reference linux device drivers, 2e
+
+
+// 20060922 descent
+// in dorado, if NIC mode on, and use ARL search, need enable STR9100_GSW_FAST_AGE_OUT
+// NIC mode is experiment, don't recommand use it.
+#define CONFIG_NIC_MODE
+
+// 20060922 descent end
+
+//#define STR9100_GSW_DEBUG
+
+
+#ifdef SHOW_DEBUG_MESSAGE
+
+#define NORMAL_MSG 1
+#define WARNING_MSG (1 << 1)
+#define CRITICAL_MSG (1 << 2)
+
+#define DEBUG_MSG(msg_level, fmt, args...)\
+{ \
+        int i=0; \
+\
+        for(i=0 ; i < 3 ; ++i) { \
+                if ((MSG_LEVEL & msg_level) >> i) \
+                        printk (KERN_INFO "*str9100_gsw_debug* " fmt, ## args); \
+        } \
+}
+
+#endif
+
+
+
+// direction is "TX" or "RX"
+#define PRINT_PACKET(data, len, direction) \
+{ \
+	printk(direction); \
+	print_packet(data, len); \
+}
+
+#undef PDEBUG
+  #ifdef STR9100_GSW_DEBUG
+    #ifdef __KERNEL__
+      #define PDEBUG(fmt, args...) printk (KERN_INFO "*str9100_gsw_debug* " fmt, ## args)
+      //#define PDEBUG printk 
+    #else
+      #define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
+    #endif // __KERNEL__
+  #else
+    #define PDEBUG(fmt, args...)
+  #endif
+
+#undef PDEBUGG
+#define PDEBUGG(fmt, args...)
+
+// 20061103 descent
+//#define CONFIG_CONF_VID
+// 20061103 descent end
+
+
+// modify by descent 2006/07/05
+// use for print needed message
+#if 1
+#define PRINT_INFO printk 
+#else
+#define PRINT_INFO(arg...)
+#endif
+
+
+#define CONFIG_STAR_GSW_NAPI
+
+// add by descent 2006/07/07
+// in star_gsw_get_rfd_buff
+// if define CONFIG_STAR_GSW_BRIDGE drop no packets
+// else drop invalid packets.
+
+
+#include <linux/config.h>
+#ifdef CONFIG_BRIDGE // reference linux config network bridge
+#define CONFIG_STAR_GSW_BRIDGE
+#endif
+
+// add by descent 2006/07/05
+// 1 mean rate controll on
+// 0 mean rate controll off
+#define STR9100_GSW_BROADCAST_RATE_CONTROL 0
+#define STR9100_GSW_MULTICAST_RATE_CONTROL 0
+#define STR9100_GSW_UNKNOW_PACKET_RATE_CONTROL 0
+
+// 1 mean forwarding off
+// 0 mean forwarding on
+#define STR9100_GSW_DISABLE_FORWARDING_BROADCAST_PACKET 0
+#define STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET 0
+#define STR9100_GSW_DISABLE_FORWARDING_UNKNOW_PACKET 0
+
+//#define STR9100_GSW_FAST_AGE_OUT
+
+#define STAR_GSW_TX_HW_CHECKSUM
+#define STAR_GSW_RX_HW_CHECKSUM
+
+
+//#define STAR_GSW_TIMER
+//#define FREE_TX_SKB_MULTI
+#define STAR_GSW_SG
+#if defined(STAR_GSW_SG) && !defined(STAR_GSW_TX_HW_CHECKSUM)
+#define STAR_GSW_TX_HW_CHECKSUM
+#endif
+
+
+//#define ADJUSTMENT_TX_RX_SKEW
+//#define STAR_GSW_STATUS_ISR
+#define STAR_GSW_FSQF_ISR
+
+
+// adjust MAX_PEND_INT_CNT and MAX_PEND_TIME at run time.
+//#define CHANGE_DELAY_INT
+
+#define STAR_GSW_DELAYED_INTERRUPT
+
+#define MAX_PEND_INT_CNT	0x06
+#define MAX_PEND_TIME		0x20
+
+/*
+ * This tag is for 9102 + 9109 Case only, and 9102's MAC0 Connect ot 9102's MAC1
+ */
+#ifdef CONFIG_STAR_GSW_TYPE_EWC
+#define CONFIG_STAR_GSW_TYPE_ONEARM "y"
+#undef CONFIG_SERCOMM_VSC7385
+#endif
+
+#if 0
+
+#define VLAN0_GROUP_ID			(0)
+#define VLAN1_GROUP_ID			(1)
+#define VLAN2_GROUP_ID			(2)
+#define VLAN3_GROUP_ID			(3)
+#define VLAN4_GROUP_ID			(4)
+#define VLAN5_GROUP_ID			(5)
+#define VLAN6_GROUP_ID			(6)
+#define VLAN7_GROUP_ID			(7)
+
+
+
+
+
+#ifdef CONFIG_STAR_GSW_TYPE_ONEARM
+#ifdef CONFIG_SERCOMM_VSC7385
+#define VLAN0_VID			(0x1)
+#define VLAN1_VID			(0x2)
+#define VLAN2_VID			(0x3)
+#define VLAN3_VID			(0x4)
+#define VLAN4_VID			(0x5)
+#define VLAN5_VID			(0x6)
+#define VLAN6_VID			(0x7)
+#define VLAN7_VID			(0x8)
+#else
+#define VLAN0_VID			(0x2)
+#define VLAN1_VID			(0x1)
+#define VLAN2_VID			(0x3)
+#define VLAN3_VID			(0x4)
+#define VLAN4_VID			(0x5)
+#define VLAN5_VID			(0x6)
+#define VLAN6_VID			(0x7)
+#define VLAN7_VID			(0x8)
+#endif
+#else
+#define VLAN0_VID			(0x111)
+#define VLAN1_VID			(0x222)
+#define VLAN2_VID			(0x333)
+#define VLAN3_VID			(0x444)
+#define VLAN4_VID			(0x555)
+#define VLAN5_VID			(0x666)
+#define VLAN6_VID			(0x777)
+#define VLAN7_VID			(0x888)
+#endif
+
+#define PORT0				(1 << 0)	/* bit map : bit 0 */
+#define PORT1				(1 << 1)	/* bit map : bit 1 */
+#define CPU_PORT			(1 << 2)	/* bit map : bit 2 */
+
+#ifdef CONFIG_STAR_GSW_TYPE_ONEARM
+#define VLAN0_GROUP			(PORT0 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#ifdef CONFIG_STAR_GSW_TYPE_EWC
+#define VLAN2_GROUP			(PORT1 | CPU_PORT)
+#define VLAN3_GROUP			(PORT1 | CPU_PORT)
+#else
+#define VLAN2_GROUP			(0)
+#define VLAN3_GROUP			(0)
+#endif
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#ifdef CONFIG_STAR_GSW_TYPE_EWC
+#define VLAN7_GROUP			(PORT1 | CPU_PORT)
+#else
+#define VLAN7_GROUP			(0)
+#endif
+
+#else
+#define VLAN0_GROUP			(PORT0 | PORT1 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(PORT1 | CPU_PORT)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+#endif
+
+#ifdef CONFIG_STAR_GSW_TYPE_ONEARM
+
+#ifdef CONFIG_HAVE_VLAN_TAG
+
+#define VLAN0_VLAN_TAG			(5)	// cpu port and mac 0 port
+#define VLAN1_VLAN_TAG			(5)	// cpu port and mac 0 port
+
+#else
+#define VLAN0_VLAN_TAG			(1)	// only mac 0 port
+#define VLAN1_VLAN_TAG			(1)	// only mac 0 port
+#endif
+
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#ifdef CONFIG_STAR_GSW_TYPE_EWC
+#define VLAN7_VLAN_TAG			(0)	// MAC1 don't need Tag
+#else
+#define VLAN7_VLAN_TAG			(0)
+#endif
+#else
+#define VLAN0_VLAN_TAG			(0)
+#define VLAN1_VLAN_TAG			(0)
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+#endif
+
+
+#define PORT0_PVID			(VLAN1_GROUP_ID)
+#define PORT1_PVID			(VLAN2_GROUP_ID)
+#define CPU_PORT_PVID			(VLAN0_GROUP_ID)
+
+#endif
+
+#define MAX_PACKET_LEN			(1536)
+
+/* 
+ * Maximum Transmit/Receive Frame Descriptors for GSW's MAC frame
+ * the value of tx/rx set to 40/48 is suggested.
+ */
+#define STAR_GSW_MAX_TFD_NUM		40
+#define STAR_GSW_MAX_RFD_NUM		48
+
+#endif /* __STAR_GSW_CONFIG_H__ */
diff -Nur linux-2.6.35.11/drivers/net/str9100/star_gsw.h linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw.h
--- linux-2.6.35.11/drivers/net/str9100/star_gsw.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,682 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef STAR_GSW_H
+#define STAR_GSW_H
+
+#include "star_gsw_phy.h"
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/reboot.h>
+#include <asm/bitops.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/if_ether.h>
+#include <linux/icmp.h>
+#include <linux/udp.h>
+#include <linux/tcp.h>
+#include <linux/if_arp.h>
+#include <net/arp.h>
+
+#if defined(LINUX24)
+#include <asm/arch/str9100/star_gsw.h>
+#include <asm/arch/str9100/star_gpio.h>
+#include <asm/arch/str9100/star_powermgt.h>
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+
+
+
+#include "star_gsw_config.h"
+
+#ifndef BIT
+#define BIT(x)		((1 << (x)))
+#endif
+
+#define LAN_PORT	1
+#define WAN_PORT	2
+#define EWC_PORT	3
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+
+#define TUN_PORT	4
+#define PMAP_TUN_PORT	8
+#define CREATE_NET_DEV_AD star_gsw_probe_tun();
+#define PORT_BASE_PMAP_TUN_PORT	PMAP_TUN_PORT
+#else
+#define CREATE_NET_DEV_AD
+#define PORT_BASE_PMAP_TUN_PORT
+#endif
+
+
+// add by descent 2006/07/10
+#define PMAP_PORT0	1
+#define PMAP_PORT1	2
+#define PMAP_CPU_PORT	4
+
+
+/*
+ * macro declarations
+ */
+#define GSW_SET_PORT0_PVID(port0_pvid) \
+{ \
+	((GSW_VLAN_PORT_PVID) &= (~(0x7 << 0))); \
+	((GSW_VLAN_PORT_PVID) |= ((port0_pvid) & 0x07)); \
+}
+
+#define GSW_SET_PORT1_PVID(port1_pvid) \
+{ \
+	((GSW_VLAN_PORT_PVID) &= (~(0x7 << 4))); \
+	((GSW_VLAN_PORT_PVID) |= (((port1_pvid) & 0x07) << 4)); \
+}
+
+#define GSW_SET_CPU_PORT_PVID(cpu_port_pvid) \
+{ \
+	((GSW_VLAN_PORT_PVID) &= (~(0x7 << 8))); \
+	((GSW_VLAN_PORT_PVID) |= (((cpu_port_pvid) & 0x07) << 8)); \
+}
+
+#define GSW_SET_VLAN_0_VID(vid) \
+{ \
+	((GSW_VLAN_VID_0_1) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_0_1) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_1_VID(vid) \
+{ \
+	((GSW_VLAN_VID_0_1) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_0_1) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_2_VID(vid) \
+{ \
+	((GSW_VLAN_VID_2_3) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_2_3) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_3_VID(vid) \
+{ \
+	((GSW_VLAN_VID_2_3) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_2_3) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_4_VID(vid) \
+{ \
+	((GSW_VLAN_VID_4_5) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_4_5) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_5_VID(vid) \
+{ \
+	((GSW_VLAN_VID_4_5) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_4_5) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_6_VID(vid) \
+{ \
+	((GSW_VLAN_VID_6_7) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_6_7) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_7_VID(vid) \
+{ \
+	((GSW_VLAN_VID_6_7) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_6_7) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_0_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 0))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 0)); \
+}
+
+#define GSW_SET_VLAN_1_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 3))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 3)); \
+}
+
+#define GSW_SET_VLAN_2_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 6))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 6)); \
+}
+
+#define GSW_SET_VLAN_3_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 9))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 9)); \
+}
+
+#define GSW_SET_VLAN_4_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 12))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 12)); \
+}
+
+#define GSW_SET_VLAN_5_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 15))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 15)); \
+}
+
+#define GSW_SET_VLAN_6_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 18))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 18)); \
+}
+
+#define GSW_SET_VLAN_7_MEMBER(vlan_member) \
+{ \
+	((GSW_VLAN_MEMBER_PORT_MAP) &= (~(0x7 << 21))); \
+	((GSW_VLAN_MEMBER_PORT_MAP) |= (((vlan_member) & 0x7) << 21)); \
+}
+
+#define GSW_SET_VLAN_0_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 0))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 0)); \
+}
+
+#define GSW_SET_VLAN_1_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 3))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 3)); \
+}
+
+#define GSW_SET_VLAN_2_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 6))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 6)); \
+}
+
+#define GSW_SET_VLAN_3_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 9))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 9)); \
+}
+
+#define GSW_SET_VLAN_4_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 12))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 12)); \
+}
+
+#define GSW_SET_VLAN_5_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 15))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 15)); \
+}
+
+#define GSW_SET_VLAN_6_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 18))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 18)); \
+}
+
+#define GSW_SET_VLAN_7_TAG(vlan_tag) \
+{ \
+	((GSW_VLAN_TAG_PORT_MAP) &= (~(0x7 << 21))); \
+	((GSW_VLAN_TAG_PORT_MAP) |= (((vlan_tag) & 0x7) << 21)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_0_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_0_1) &= (~(0xFFFF << 0))); \
+	((GSW_PPPOE_SESSION_ID_0_1) |= (((session_id) & 0xFFFF) << 0)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_1_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_0_1) &= (~(0xFFFF << 16))); \
+	((GSW_PPPOE_SESSION_ID_0_1) |= (((session_id) & 0xFFFF) << 16)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_2_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_2_3) &= (~(0xFFFF << 0))); \
+	((GSW_PPPOE_SESSION_ID_2_3) |= (((session_id) & 0xFFFF) << 0)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_3_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_2_3) &= (~(0xFFFF << 16))); \
+	((GSW_PPPOE_SESSION_ID_2_3) |= (((session_id) & 0xFFFF) << 16)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_4_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_4_5) &= (~(0xFFFF << 0))); \
+	((GSW_PPPOE_SESSION_ID_4_5) |= (((session_id) & 0xFFFF) << 0)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_5_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_4_5) &= (~(0xFFFF << 16))); \
+	((GSW_PPPOE_SESSION_ID_4_5) |= (((session_id) & 0xFFFF) << 16)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_6_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_6_7) &= (~(0xFFFF << 0))); \
+	((GSW_PPPOE_SESSION_ID_6_7) |= (((session_id) & 0xFFFF) << 0)); \
+}
+
+#define GSW_SET_PPPOE_SESSION_7_ID(session_id) \
+{ \
+	((GSW_PPPOE_SESSION_ID_6_7) &= (~(0xFFFF << 16))); \
+	((GSW_PPPOE_SESSION_ID_6_7) |= (((session_id) & 0xFFFF) << 16)); \
+}
+
+#define GSW_READ_INTERRUPT_STATUS(int_status) \
+	((int_status) = (GSW_INTERRUPT_STATUS))
+
+#define GSW_CLEAR_ALL_INTERRUPT_STATUS_SOURCES()\
+	((GSW_INTERRUPT_STATUS) = (0x00001FFF))
+
+#define GSW_CLEAR_INTERRUPT_STATUS_SOURCES(source) \
+	((GSW_INTERRUPT_STATUS) |= (source))
+
+#define GSW_CLEAR_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+	((GSW_INTERRUPT_STATUS) |= (1 << (source_bit_index)))
+
+#define GSW_DISABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+	((GSW_INTERRUPT_MASK) = (0x00001FFF))
+
+#define GSW_ENABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+	((GSW_INTERRUPT_MASK) = (0x00000000))
+
+#define GSW_DISABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+	((GSW_INTERRUPT_MASK) |= (1 << (source_bit_index)))
+
+#define GSW_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+	((GSW_INTERRUPT_MASK) &= ~(1 << (source_bit_index)))
+
+#define GSW_TS_DMA_START() \
+	((GSW_TS_DMA_CONTROL) = (1))
+
+#define GSW_TS_DMA_STOP() \
+	((GSW_TS_DMA_CONTROL) = (0))
+
+#define GSW_READ_TS_DMA_STATE(state) \
+	((state) = (GSW_TS_DMA_CONTROL))
+
+#define GSW_FS_DMA_START() \
+	((GSW_FS_DMA_CONTROL) = (1))
+
+#define GSW_FS_DMA_STOP() \
+	((GSW_FS_DMA_CONTROL) = (0))
+
+#define GSW_WRITE_TSSD(tssd_value) \
+	((GSW_TS_DESCRIPTOR_POINTER) = (tssd_value))
+
+#define GSW_READ_TSSD(tssd_value) \
+	((tssd_value) = (GSW_TS_DESCRIPTOR_POINTER))
+
+#define GSW_WRITE_FSSD(fssd_value) \
+	((GSW_FS_DESCRIPTOR_POINTER) = (fssd_value))
+
+#define GSW_READ_FSSD(fssd_value) \
+	((fssd_value) = (GSW_FS_DESCRIPTOR_POINTER))
+
+#define GSW_WRITE_TS_BASE(ts_base_value) \
+	((GSW_TS_DESCRIPTOR_BASE_ADDR) = (ts_base_value))
+
+#define GSW_READ_TS_BASE(ts_base_value) \
+	((ts_base_value) = (GSW_TS_DESCRIPTOR_BASE_ADDR))
+
+#define GSW_WRITE_FS_BASE(fs_base_value) \
+	((GSW_FS_DESCRIPTOR_BASE_ADDR) = (fs_base_value))
+
+#define GSW_READ_FS_BASE(fs_base_value) \
+	((fs_base_value) = (GSW_FS_DESCRIPTOR_BASE_ADDR))
+
+/*
+ * HNAT macros defines
+ */
+#define GSW_WRITE_HNAT_CONFIGURATION(hnat_config) \
+	((GSW_HNAT_CONFIG) = (hnat_config))
+
+#define GSW_READ_HNAT_CONFIGURATION(hnat_config) \
+	((hnat_config) = (GSW_HNAT_CONFIG))
+
+#define GSW_WRITE_PRIVATE_IP_BASE(ip_base) \
+	((GSW_HNAT_PRIVATE_IP_BASE) = (ip_base & 0x000FFFFF))
+
+#define GSW_WRITE_HNAT_FW_RULE_START_INDEX(rule_start_index) \
+	((GSW_HNAT_FW_RULE_START_ADDR) = (rule_start_index & 0x1FF))
+
+#define GSW_WRITE_HNAT_FW_RULE_END_INDEX(rule_end_index) \
+	((GSW_HNAT_FW_RULE_END_ADDR) = (rule_end_index & 0x1FF))
+
+#define GSW_READ_HNAT_FW_RULE_START_INDEX(rule_start_index) \
+	((rule_start_index) = ((GSW_HNAT_FW_RULE_START_ADDR) & 0x1FF))
+
+#define GSW_READ_HNAT_FW_RULE_END_INDEX(rule_end_index) \
+	((rule_end_index) = ((GSW_HNAT_FW_RULE_END_ADDR) & 0x1FF))
+
+#define GSW_WRITE_HNAT_FL_RULE_START_INDEX(rule_start_index) \
+	((GSW_HNAT_FL_RULE_START_ADDR) = (rule_start_index & 0x1FF))
+
+#define GSW_WRITE_HNAT_FL_RULE_END_INDEX(rule_end_index) \
+	((GSW_HNAT_FL_RULE_END_ADDR) = (rule_end_index & 0x1FF))
+
+#define GSW_READ_HNAT_FL_RULE_START_INDEX(rule_start_index) \
+	((rule_start_index) = ((GSW_HNAT_FL_RULE_START_ADDR) & 0x1FF))
+
+#define GSW_READ_HNAT_FL_RULE_END_INDEX(rule_end_index) \
+	((rule_end_index) = ((GSW_HNAT_FL_RULE_END_ADDR) & 0x1FF))
+
+#define GSW_WRITE_HNAT_ALG_START_INDEX(rule_start_index) \
+	((GSW_HNAT_ALG_START_ADDR) = (rule_start_index & 0x1FF))
+
+#define GSW_WRITE_HNAT_ALG_END_INDEX(rule_end_index) \
+	((GSW_HNAT_ALG_END_ADDR) = (rule_end_index & 0x1FF))
+
+#define GSW_READ_HNAT_ALG_START_INDEX(rule_start_index) \
+	((rule_start_index) = ((GSW_HNAT_ALG_START_ADDR) & 0x1FF))
+
+#define GSW_READ_HNAT_ALG_END_INDEX(rule_end_index) \
+	((rule_end_index) = ((GSW_HNAT_ALG_END_ADDR) & 0x1FF))
+
+#define GSW_WRITE_HNAT_SIP_START_INDEX(rule_start_index) \
+	((GSW_HNAT_SIP_BASE_ADDR) = (rule_start_index & 0x1FF))
+
+#define GSW_READ_HNAT_SIP_START_INDEX(rule_start_index) \
+	((rule_start_index) = ((GSW_HNAT_SIP_BASE_ADDR) & 0x1FF))
+
+#define GSW_WRITE_HNAT_NAPT_BASE_ADDR(base_addr) \
+	((GSW_HNAT_NAPT_BASE_ADDR) = (base_addr))
+
+#define GSW_READ_HNAT_NAPT_BASE_ADDR(base_addr) \
+	((base_addr) = (GSW_HNAT_NAPT_BASE_ADDR))
+
+#define GSW_WRITE_HNAT_NAPT_PORT_BASE(port_base) \
+	((GSW_HNAT_NAPT_PORT_BASE) = (port_base & 0xFFFF))
+
+#define GSW_WRITE_HNAT_ARP_BASE_ADDR(base_addr) \
+	((GSW_HNAT_ARP_BASE_ADDR) = (base_addr))
+
+#define GSW_READ_HNAT_ARP_BASE_ADDR(base_addr) \
+	((base_addr) = (GSW_HNAT_ARP_BASE_ADDR))
+
+//---------------------------------------------------
+//      STAR9100   INTC  macro define
+//---------------------------------------------------
+/*
+ * macro declarations
+ */
+#define INTC_ENABLE_INTERRUPT_SOURCE(source_bit_index) \
+	(INTC_INTERRUPT_MASK) &= (~(1 << source_bit_index))
+
+#define INTC_DISABLE_INTERRUPT_SOURCE(source_bit_index) \
+	(INTC_INTERRUPT_MASK) |= ((1 << source_bit_index))
+
+#define INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(source_bit_index) \
+	(INTC_INTERRUPT_CLEAR_EDGE_TRIGGER) |= ((1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_EDGE_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_MODE) |= ((1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_LEVEL_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_MODE) &= (~(1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_RISING_EDGE_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_LEVEL) &= (~(1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_FALLING_EDGE_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_LEVEL) |= ((1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_ACTIVE_HIGH_LEVEL_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_LEVEL) &= (~(1 << source_bit_index))
+
+#define INTC_SET_INTERRUPT_ACTIVE_LOW_LEVEL_TRIGGER(source_bit_index) \
+	(INTC_INTERRUPT_TRIGGER_LEVEL) |= ((1 << source_bit_index))
+
+#define INTC_ASSIGN_INTERRUPT_TO_IRQ(source_bit_index) \
+	(INTC_FIQ_MODE_SELECT) &= (~(1 << source_bit_index))
+
+#define INTC_ASSIGN_INTERRUPT_TO_FIQ(source_bit_index) \
+	(INTC_FIQ_MODE_SELECT) |= ((1 << source_bit_index))
+
+/*-------------------------------------------------*/
+//                       PHY define
+/*-------------------------------------------------*/
+#define PHY_CONTROL_REG_ADDR		0x00
+#define PHY_STATUA_REG_ADDR		0x01
+#define PHY_ID1_REG_ADDR		0x02
+#define PHY_ID2_REG_ADDR		0x03
+#define PHY_AN_ADVERTISEMENT_REG_ADDR	0x04
+#define PHY_AN_REAMOTE_CAP_REG_ADDR	0x05
+#define PHY_RESERVED1_REG_ADDR		0x10
+#define PHY_RESERVED2_REG_ADDR		0x11
+#define PHY_CH_STATUS_OUTPUT_REG_ADDR	0x12
+#define PHY_RESERVED3_REG_ADDR		0x13
+#define PHY_RESERVED4_REG_ADDR		0x14
+
+#define PHY_LSI_L84225_ID1		0x0016
+#define PHY_LSI_L84225_ID2		0xF840	// 0xF870????
+
+//--------------------------------------------------------
+//         STAR9100 Hnat related define
+//--------------------------------------------------------
+/*Define for status print for Inerrrupt Status Register */
+#define INT_PORT0_Q_FULL		BIT(0)
+#define INT_PORT1_Q_FULL		BIT(1)
+#define INT_CPU_Q_FULL			BIT(2)
+#define INT_HNAT_Q_FULL			BIT(3)
+#define INT_GLOBAL_Q_FULL		BIT(4)
+#define INT_BUFFER_FULL			BIT(5)
+#define INT_PORT_STATUS_CHG		BIT(6)
+#define INT_INTRUDER0			BIT(7)
+#define INT_INTRUDER1			BIT(8)
+#define INT_CPU_HOLD			BIT(9)
+#define INT_PORT0_UNKNOWN_VLAN		BIT(10)
+#define INT_PORT1_UNKNOWN_VLAN		BIT(11)
+#define INT_CPU_UNKNOWN_VLAN		BIT(12)
+#define INT_PORT0_NO_LINK_DROP		BIT(16)
+#define INT_PORT0_BCS_DROP		BIT(17)
+#define INT_PORT0_RX_CRC_DROP		BIT(18)
+#define INT_PORT0_JAMED_DROP		BIT(19)
+#define INT_PORT0_QUEUE_DROP		BIT(20)
+#define INT_PORT0_RMC_DROP		BIT(21)
+#define INT_PORT0_LOCAL_DROP		BIT(22)
+#define INT_PORT0_INGRESS_DROP		BIT(23)
+#define INT_PORT1_NO_LINK_DROP		BIT(24)
+#define INT_PORT1_BCS_DROP		BIT(25)
+#define INT_PORT1_RX_CRC_DROP		BIT(26)
+#define INT_PORT1_JAMED_DROP		BIT(27)
+#define INT_PORT1_QUEUE_DROP		BIT(28)
+#define INT_PORT1_RMC_DROP		BIT(29)
+#define PORT1_LOCAL_DROP		BIT(30)
+#define PORT1_INGRESS_DROP		0x80000000
+
+#define MAX_VLAN_NUM			(8)
+#define MAX_PORT_NUM			(3)	/* including port 0, port 1, and CPU port */
+
+typedef struct _vlan_config_ {
+	u32	vlan_gid;	/* 3-bit VLAN group ID */
+	u32	vlan_vid;	/* 12-bit VLAN ID */
+	u32	vlan_group;	/* 3-bit VLAN group port map */
+	u32	vlan_tag_flag;	/* 3-bit VLAN tag port map */
+	u8	vlan_mac[6];
+	u8	pad[2];
+} vlan_config_t;
+
+typedef struct _port_config_ {
+	u32	pvid;	/* 3-bit Port PVID */
+	u32	config_flag;
+	u32	status_flag;
+} port_config_t;
+
+typedef struct _gsw_info_ {
+	vlan_config_t vlan[MAX_VLAN_NUM];
+	port_config_t port[MAX_PORT_NUM];
+} gsw_info_t;
+
+/* store this information for the driver.. */
+struct star_gsw_private {
+	struct net_device_stats stats;
+	spinlock_t lock;
+	/* Note:
+	 * device entry pmap = 0 means local loopback network interface
+	 * device entry pmap = 1 means GSW port 0 for LAN port network interface
+	 * device entry pmap = 2 means GSW port 1 for WAN port network interface
+	 * device entry pmap = 4 means GSW cpu port
+	 */
+	int pmap;
+	struct napi_struct  napi;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+        struct vlan_group               *vlgrp;
+#endif
+
+};
+
+#define __REG(reg)	(*(u32 volatile *)(reg))
+
+/*
+ * Network Driver, Receive/Send and Initial Buffer Function
+ */
+typedef struct {
+	// 1st 32Bits
+	u32 data_ptr;
+
+	// 2nd  32Bits
+	u32 length:16;
+	u32 tco:1;
+	u32 uco:1;
+	u32 ico:1;
+	u32 pmap:3;
+	u32 fr:1;
+	u32 pri:3;
+	u32 fp:1;
+	u32 interrupt:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 cown:1;
+
+	// 3rd 32Bits
+	u32 vid:3;
+	u32 insv:1;
+	u32 sid:3;
+	u32 inss:1;
+	u32 unused:24;
+
+	// 4th 32Bits
+	u32 unused2;
+
+} __attribute__((packed)) STAR_GSW_TXDESC;
+
+typedef struct {
+	// 1st 32Bits
+	u32 data_ptr;
+
+	// 2nd  32Bits
+	u32 length:16;
+	u32 l4f:1;
+	u32 ipf:1;
+	u32 prot:2;
+	u32 hr:6;
+	u32 sp:2;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 cown:1;
+
+	// 3rd 32Bits
+	u32 unused;
+
+	// 4th 32Bits
+	u32 unused2;
+
+} __attribute__((packed)) STAR_GSW_RXDESC;
+
+/* 
+ * Transmit Frame Descriptor Ring for TFDS
+ */
+
+typedef struct {
+	u32			phy_addr;
+	STAR_GSW_TXDESC		*vir_addr;
+	unsigned int		cur_index; // TX's current will point to Free Descriptors
+	struct sk_buff		*skb_ptr[STAR_GSW_MAX_TFD_NUM]; // TX's sk_buff ptr
+#if defined(FREE_TX_SKB_MULTI) || defined(STAR_GSW_TIMER)
+        u32                     to_free_index;
+#endif
+
+} TXRING_INFO;
+/* 
+ * Receive Frame Descriptor Ring for RFDS
+ */
+
+typedef struct {
+	u32			phy_addr;
+	STAR_GSW_RXDESC		*vir_addr;
+	u32			cur_index;
+	struct sk_buff		*skb_ptr[STAR_GSW_MAX_RFD_NUM];	// RX's sk_buff ptr
+} RXRING_INFO;
+
+extern void str9100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+/*
+ * data structure defines
+ */
+typedef struct _gsw_arl_table_entry_
+{
+    u32    filter;
+    u32    vlan_mac;
+    u32    vlan_gid;
+    u32    age_field;
+    u32    port_map;
+    u8     mac_addr[6];
+    u8     pad[2];
+
+} gsw_arl_table_entry_t;
+
+#endif
+
diff -Nur linux-2.6.35.11/drivers/net/str9100/star_gsw_phy.c linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_phy.c
--- linux-2.6.35.11/drivers/net/str9100/star_gsw_phy.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_phy.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,1224 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include "star_gsw_phy.h"
+#include "star_gsw.h"
+#include "star_gsw_config.h"
+
+
+#if 0
+void init_switch()
+{
+        u32 sw_config;
+
+	PDEBUG("init_switch\n");
+        /*
+         * Configure GSW configuration
+         */
+        sw_config = GSW_SWITCH_CONFIG;
+
+#if 0
+        // orignal virgon configuration
+        // enable fast aging
+        sw_config |= (0xF);
+
+        // CRC stripping
+        sw_config |= (0x1 << 21);
+
+        // IVL learning
+        sw_config |= (0x1 << 22);
+
+        // HNAT disable
+        sw_config &= ~(0x1 << 23);
+
+        GSW_SWITCH_CONFIG = sw_config;
+
+        sw_config = GSW_SWITCH_CONFIG;
+#endif
+
+        /* configure switch */
+        sw_config = GSW_SWITCH_CONFIG;
+
+        sw_config &= ~0xF;      /* disable aging */
+        sw_config |= 0x1;       /* disable aging */
+
+#ifdef JUMBO_ENABLE
+
+        // CRC stripping and GSW_CFG_MAX_LEN_JMBO
+        sw_config |= (GSW_CFG_CRC_STRP | GSW_CFG_MAX_LEN_JMBO);
+#else
+        // CRC stripping and 1536 bytes
+        sw_config |= (GSW_CFG_CRC_STRP | GSW_CFG_MAX_LEN_1536);
+#endif
+
+        /* IVL */
+        sw_config |= GSW_CFG_IVL;
+
+        /* disable HNAT */
+        sw_config &= ~GSW_CFG_HNAT_EN;
+
+        GSW_SWITCH_CONFIG = sw_config;
+}
+#endif
+
+
+
+
+
+
+// add by descent 2006/07/05
+// for configure packet forward and rate control
+void init_packet_forward(int port)
+{
+	u32 mac_port_config;
+
+	PDEBUG("port%d configure\n", port);
+	if (port==0)
+		mac_port_config = GSW_MAC_PORT_0_CONFIG;
+	if (port==1)
+		mac_port_config = GSW_MAC_PORT_1_CONFIG;
+	if (STR9100_GSW_BROADCAST_RATE_CONTROL)
+		mac_port_config |=  (0x1 << 31); // STR9100_GSW_BROADCAST_RATE_CONTROLL on
+	else
+		mac_port_config &=  (~(0x1 << 31)); // STR9100_GSW_BROADCAST_RATE_CONTROLL off
+
+	if (STR9100_GSW_MULTICAST_RATE_CONTROL)
+		mac_port_config |=  (0x1 << 30); // STR9100_GSW_MULTICAST_RATE_CONTROLL on
+	else
+		mac_port_config &=  (~(0x1 << 30)); // STR9100_GSW_MULTICAST_RATE_CONTROLL off
+
+	if (STR9100_GSW_UNKNOW_PACKET_RATE_CONTROL)
+		mac_port_config |=  (0x1 << 29); // STR9100_GSW_UNKNOW_PACKET_RATE_CONTROLL on
+	else
+		mac_port_config &=  (~(0x1 << 29)); // STR9100_GSW_UNKNOW_PACKET_RATE_CONTROLL off
+
+
+	if (STR9100_GSW_DISABLE_FORWARDING_BROADCAST_PACKET)
+		mac_port_config |=  (0x1 << 27); // STR9100_GSW_DISABLE_FORWARDING_BROADCAST_PACKET on
+	else
+		mac_port_config &=  (~(0x1 << 27)); // STR9100_GSW_DISABLE_FORWARDING_BROADCAST_PACKET off
+
+	if(STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET)
+	{
+		mac_port_config |=  (0x1 << 26); // STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET on
+		PDEBUG("STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET on\n");
+	}
+	else
+	{
+		mac_port_config &=  (~(0x1 << 26)); // STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET off
+		PDEBUG("STR9100_GSW_DISABLE_FORWARDING_MULTICAST_PACKET off\n");
+	}
+
+	if(STR9100_GSW_DISABLE_FORWARDING_UNKNOW_PACKET)
+		mac_port_config |=  (0x1 << 25); // STR9100_GSW_DISABLE_FORWARDING_UNKNOW_PACKET on
+	else
+		mac_port_config &=  (~(0x1 << 25)); // STR9100_GSW_DISABLE_FORWARDING_UNKNOW_PACKET off
+
+	//GSW_MAC_PORT_0_CONFIG = mac_port_config;
+	if (port==0)
+		GSW_MAC_PORT_0_CONFIG = mac_port_config;
+	if (port==1)
+		GSW_MAC_PORT_1_CONFIG = mac_port_config;
+}
+
+static int star_gsw_set_phy_addr(u8 mac_port, u8 phy_addr)
+{
+	u32 status = 0;	/* for failure indication */
+
+	if ((mac_port > 1) || (phy_addr > 31)) {
+		return status;
+	}
+
+	if (mac_port == 0) {
+		GSW_PORT_MIRROR &= ~(0x3 << 0); /* clear bit[1:0] for PHY_ADDR[1:0] */
+		GSW_PORT_MIRROR &= ~(0x3 << 4); /* clear bit[5:4] for PHY_ADDR[3:2] */
+		GSW_QUEUE_STATUS_TEST_1 &= ~(0x1 << 25); /* clear bit[25] for PHY_ADDR[4] */
+		GSW_PORT_MIRROR |= (((phy_addr >> 0) & 0x3) << 0);
+		GSW_PORT_MIRROR |= (((phy_addr >> 2) & 0x3) << 4);
+		GSW_QUEUE_STATUS_TEST_1 |= (((phy_addr >> 4) & 0x1) << 25);
+		status = 1; /* for ok indication */
+	} else if (mac_port == 1) {
+		GSW_PORT_MIRROR &= ~(0x1 << 6); /* clear bit[6] for PHY_ADDR[0] */
+		GSW_PORT_MIRROR &= ~(0x7 << 8); /* clear bit[10:8] for PHY_ADDR[3:1] */
+		GSW_QUEUE_STATUS_TEST_1 &= ~(0x1 << 26); /* clear bit[26] for PHY_ADDR[4] */
+		GSW_PORT_MIRROR |= (((phy_addr >> 0) & 0x1) << 6);
+		GSW_PORT_MIRROR |= (((phy_addr >> 1) & 0x7) << 8);
+		GSW_QUEUE_STATUS_TEST_1 |= (((phy_addr >> 4) & 0x1) << 26);
+		status = 1; /* for ok indication */
+	}
+
+	return status;
+}
+
+static int star_gsw_read_phy(u8 phy_addr, u8 phy_reg, u16 *read_data)
+{
+	u32 status;
+	int i;
+
+	// clear previous rw_ok status
+	GSW_PHY_CONTROL = (0x1 << 15);
+
+        // 20061013 descent 
+	// for ORION EOC
+        GSW_QUEUE_STATUS_TEST_1 &= ~( 0XF << 16);
+
+        GSW_PHY_CONTROL   &= ~(0x1<<0);
+
+        GSW_QUEUE_STATUS_TEST_1 |= (((phy_addr >> 1) & 0xF) << 16);
+        // 20061013 descent end
+
+
+	GSW_PHY_CONTROL = ((phy_addr & 0x1) | ((phy_reg & 0x1F) << 8) | (0x1 << 14));
+
+	for (i = 0; i < 0x1000; i++) {
+		status = GSW_PHY_CONTROL;
+		if (status & (0x1 << 15)) {
+			// clear the rw_ok status, and clear other bits value
+			GSW_PHY_CONTROL = (0x1 << 15);
+			*read_data = (u16) ((status >> 16) & 0xFFFF);
+			return (1);
+		} else {
+			udelay(10);
+		}
+	}
+
+	return (0);
+}
+
+static int star_gsw_write_phy(u8 phy_addr, u8 phy_reg, u16 write_data)
+{
+	int i;
+
+	// clear previous rw_ok status
+	GSW_PHY_CONTROL = (0x1 << 15);
+
+        // 20061013 descent 
+	// for ORION EOC
+        GSW_QUEUE_STATUS_TEST_1 &= ~( 0XF << 16);
+
+        GSW_PHY_CONTROL   &= ~(0x1<<0);
+
+        GSW_QUEUE_STATUS_TEST_1 |= (((phy_addr >> 1) & 0xF) << 16);
+        // 20061013 descent end
+
+
+	GSW_PHY_CONTROL = ((phy_addr & 0x1) |
+		((phy_reg & 0x1F) << 8) |
+		(0x1 << 13) | ((write_data & 0xFFFF) << 16));
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((GSW_PHY_CONTROL) & (0x1 << 15)) {
+			// clear the rw_ok status, and clear other bits value
+			GSW_PHY_CONTROL = (0x1 << 15);
+			return (1);
+		} else {
+			udelay(10);
+		}
+	}
+
+	return (0);
+}
+
+#ifdef DORADO2_PCI_FASTPATH_MAC_PORT1_LOOPBACK
+static int star_gsw_config_mac_port1_loopback(void)
+{
+	u32 mac_port_base;
+	u32 mac_port_config;
+	int i;
+
+	PRINT_INFO("\nconfigure mac port1 loopback\n");
+	
+	mac_port_base = GSW_PORT1_CFG_REG;
+
+	mac_port_config = __REG(mac_port_base);
+
+	// disable PHY's AN
+	mac_port_config &= ~(0x1 << 7);
+
+	// enable RGMII-PHY mode
+	mac_port_config |= (0x1 << 15);
+
+	// reversed RGMII mode
+	mac_port_config |= (0x1 << 14);
+
+	// enable GSW MAC port 0
+	mac_port_config &= ~(0x1 << 18);
+
+	__REG(mac_port_base) = mac_port_config;
+
+	// SA learning disable
+	mac_port_config |= (0x1 << 19);
+
+	// disable TX flow control
+	mac_port_config &= ~(0x1 << 12);
+
+	// disable RX flow control
+	mac_port_config &= ~(0x1 << 11);
+
+	// force duplex
+	mac_port_config |= (0x1 << 10);
+
+	// force speed at 1000Mbps
+	mac_port_config &= ~(0x3 << 8);
+	mac_port_config |= (0x2 << 8);
+
+	__REG(mac_port_base) = mac_port_config;
+
+	// adjust MAC port 1 RX/TX clock skew
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 28) | (0x3 << 30));
+	//GSW_BIST_RESULT_TEST_0 |= ((0x2 << 28) | (0x2 << 30));
+	GSW_BIST_RESULT_TEST_0 |= (0x2 << 30);
+
+	return 0;
+}
+#endif
+
+int VSC8201_phy_power_down(int phy_addr, int y)
+{
+	u16 phy_data = 0;
+	// power-down or up the PHY
+	star_gsw_read_phy(phy_addr, 0, &phy_data);
+	if (y==1) // down
+		phy_data |= (0x1 << 11);
+	if (y==0) // up
+		phy_data |= (~(0x1 << 11));
+	star_gsw_write_phy(phy_addr, 0, phy_data);
+	return 0;
+
+}
+
+static int star_gsw_config_VSC8201(u8 mac_port, u8 phy_addr)	// include cicada 8201
+{
+	u32 mac_port_base = 0;
+	u32 mac_port_config;
+	u16 phy_reg;
+	int i;
+
+	PRINT_INFO("\nconfigure VSC8201\n");
+	PDEBUG("mac port : %d phy addr : %d\n", mac_port, phy_addr);
+	/*
+	 * Configure MAC port 0
+	 * For Cicada CIS8201 single PHY
+	 */
+	if (mac_port == 0) {
+		PDEBUG("port 0\n");
+		mac_port_base = GSW_PORT0_CFG_REG;
+	}
+	if (mac_port == 1) {
+		PDEBUG("port 1\n");
+		mac_port_base = GSW_PORT1_CFG_REG;
+	}
+
+	star_gsw_set_phy_addr(mac_port, phy_addr);
+	//star_gsw_set_phy_addr(1, 1);
+
+	mac_port_config = __REG(mac_port_base);
+
+	// enable PHY's AN
+	mac_port_config |= (0x1 << 7);
+
+	// enable RGMII-PHY mode
+	mac_port_config |= (0x1 << 15);
+
+	// enable GSW MAC port 0
+	mac_port_config &= ~(0x1 << 18);
+
+	__REG(mac_port_base)=  mac_port_config;
+
+	/*
+	 * Configure Cicada's CIS8201 single PHY
+	 */
+	/* 2007.04.24 Richard.Liu Marked, we don't need VSC8201 lookback mode */
+#if 0
+#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+	/* near-end loopback mode */
+	star_gsw_read_phy(phy_addr, 0x0, &phy_reg);
+	phy_reg |= (0x1 << 14);
+	star_gsw_write_phy(phy_addr, 0x0, phy_reg);
+#endif
+#endif
+
+	star_gsw_read_phy(phy_addr, 0x1C, &phy_reg);
+
+	// configure SMI registers have higher priority over MODE/FRC_DPLX, and ANEG_DIS pins
+	phy_reg |= (0x1 << 2);
+
+	star_gsw_write_phy(phy_addr, 0x1C, phy_reg);
+
+	star_gsw_read_phy(phy_addr, 0x17, &phy_reg);
+
+	// enable RGMII MAC interface mode
+	phy_reg &= ~(0xF << 12);
+	phy_reg |= (0x1 << 12);
+
+	// enable RGMII I/O pins operating from 2.5V supply
+	phy_reg &= ~(0x7 << 9);
+	phy_reg |= (0x1 << 9);
+
+	star_gsw_write_phy(phy_addr, 0x17, phy_reg);
+
+	star_gsw_read_phy(phy_addr, 0x4, &phy_reg);
+
+	// Enable symmetric Pause capable
+	phy_reg |= (0x1 << 10);
+
+	star_gsw_write_phy(phy_addr, 0x4, phy_reg);
+
+	mac_port_config = __REG(mac_port_base);
+
+	/* 2007.04.24 Richard.Liu Marked, we don't need VSC8201 lookback mode */
+//#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+#if 0
+	// near-end loopback mode, must disable AN
+	mac_port_config &= ~(0x1 << 7);
+
+	// SA learning disable
+	mac_port_config |= (0x1 << 19);
+
+	// disable TX flow control
+	mac_port_config &= ~(0x1 << 12);
+
+	// disable RX flow control
+	mac_port_config &= ~(0x1 << 11);
+
+	// force duplex
+	mac_port_config |= (0x1 << 10);
+
+	// force speed at 1000Mpbs
+	mac_port_config &= ~(0x3 << 8);
+	mac_port_config |= (0x2 << 8);
+#else
+	// enable PHY's AN
+	mac_port_config |= (0x1 << 7);
+#endif
+
+	__REG(mac_port_base) = mac_port_config;
+
+	/*
+	 * Enable PHY1 AN restart bit to restart PHY1 AN
+	 */
+	star_gsw_read_phy(phy_addr, 0x0, &phy_reg);
+
+	phy_reg |= (0x1 << 9) | (0x1 << 12);
+
+	star_gsw_write_phy(phy_addr, 0x0, phy_reg);
+
+	/*
+	 * Polling until PHY0 AN restart is complete
+	 */
+	for (i = 0; i < 0x1000; i++) {
+		star_gsw_read_phy(phy_addr, 0x1, &phy_reg);
+
+		if ((phy_reg & (0x1 << 5)) && (phy_reg & (0x1 << 2))) {
+			printk("0x1 phy reg: %x\n", phy_reg);
+			break;
+		} else {
+			udelay(100);
+		}
+	}
+
+	mac_port_config = __REG(mac_port_base);
+
+	if (((mac_port_config & 0x1) == 0) || (mac_port_config & 0x2)) {
+		printk("Check MAC/PHY%s Link Status : DOWN!\n", (mac_port == 0 ? "0" : "1"));
+	} else {
+		printk("Check MAC/PHY%s Link Status : UP!\n", (mac_port == 0 ? "0" : "1"));
+		/*
+		 * There is a bug for CIS8201 PHY operating at 10H mode, and we use the following
+		 * code segment to work-around
+		 */
+		star_gsw_read_phy(phy_addr, 0x05, &phy_reg);
+
+		if ((phy_reg & (0x1 << 5)) && (!(phy_reg & (0x1 << 6))) && (!(phy_reg & (0x1 << 7))) && (!(phy_reg & (0x1 << 8)))) {	/* 10H,10F/100F/100H off */
+			star_gsw_read_phy(phy_addr, 0x0a, &phy_reg);
+
+			if ((!(phy_reg & (0x1 << 10))) && (!(phy_reg & (0x1 << 11)))) {	/* 1000F/1000H off */
+				star_gsw_read_phy(phy_addr, 0x16, &phy_reg);
+
+				phy_reg |= (0x1 << 13) | (0x1 << 15);	// disable "Link integrity check(B13)" & "Echo mode(B15)"
+
+				star_gsw_write_phy(phy_addr, 0x16, phy_reg);
+			}
+		}
+	}
+
+	if (mac_port == 0) {
+		// adjust MAC port 0 RX/TX clock skew
+		GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 24) | (0x3 << 26));
+		GSW_BIST_RESULT_TEST_0 |= ((0x2 << 24) | (0x2 << 26));
+	}
+
+	if (mac_port == 1) {
+		// adjust MAC port 1 RX/TX clock skew
+		GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 28) | (0x3 << 30));
+		GSW_BIST_RESULT_TEST_0 |= ((0x2 << 28) | (0x2 << 30));
+	}
+
+	return 0;
+}
+
+// add by descent 2006/07/10
+// port : 0 => port0 ; port : 1 => port1
+// y = 1 ; disable AN
+int disable_AN(int port, int y)
+{
+	u32 mac_port_config;
+	if (port==0)
+		mac_port_config = GSW_MAC_PORT_0_CONFIG;
+	if (port==1)
+		mac_port_config = GSW_MAC_PORT_1_CONFIG;
+	// disable PHY's AN
+	if (y==1)
+	{
+	  PDEBUG("disable AN\n");
+	  mac_port_config &= ~(0x1 << 7);
+	}
+
+	// enable PHY's AN
+	if (y==0)
+	{
+	  PDEBUG("enable AN\n");
+	  mac_port_config |= (0x1 << 7);
+	}
+
+	if (port==0)
+		GSW_MAC_PORT_0_CONFIG = mac_port_config;
+	if (port==1)
+		GSW_MAC_PORT_1_CONFIG = mac_port_config;
+	return 0;
+}
+
+int disable_AN_VSC7385(int y)
+{
+	u32 mac_port_config;
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+	// disable PHY's AN
+	if (y==1)
+	{
+	  PDEBUG("disable AN\n");
+	  mac_port_config &= ~(0x1 << 7);
+	}
+
+	// enable PHY's AN
+	if (y==0)
+	{
+	  PDEBUG("enable AN\n");
+	  mac_port_config |= (0x1 << 7);
+	}
+
+	GSW_MAC_PORT_0_CONFIG = mac_port_config;
+	return 0;
+}
+
+void star_gsw_config_VSC7385(void)
+{
+	u32 mac_port_config;
+
+
+	printk("\nconfigure VSC7385\n");
+	/*
+	 * Configure GSW's MAC port 0
+	 * For ASIX's 5-port GbE Switch setting
+	 * 1. No SMI (MDC/MDIO) connection between Orion's MAC port 0 and ASIX's MAC port 4
+	 * 2. Force Orion's MAC port 0 to be 1000Mbps, and full-duplex, and flow control on
+	 */
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+
+	// enable RGMII-PHY mode
+	mac_port_config |= (0x1 << 15);
+
+	// force speed = 1000Mbps
+	mac_port_config &= ~(0x3 << 8);
+	mac_port_config |= (0x2 << 8);
+
+	// force full-duplex
+	mac_port_config |= (0x1 << 10);
+
+	// force Tx/Rx flow-control on
+	mac_port_config |= (0x1 << 11) | (0x1 << 12);
+
+	GSW_MAC_PORT_0_CONFIG = mac_port_config;
+
+	udelay(1000);
+
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+	if (((mac_port_config & 0x1) == 0) || (mac_port_config & 0x2)) {
+		printk("Check MAC/PHY 0 Link Status : DOWN!\n");
+	} else {
+		printk("Check MAC/PHY 0 Link Status : UP!\n");
+	}
+
+	/* adjust MAC port 0 /RX/TX clock skew */
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 24) | (0x3 << 26));
+	GSW_BIST_RESULT_TEST_0 |= ((0x2 << 24) | (0x2 << 26));
+}
+
+
+
+void star_gsw_config_ASIX()
+{
+	u32 mac_port_config;
+
+	printk("configure port0 ASIX\n");
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+	//Disable AN
+	mac_port_config &= (~(0x1 << 7));
+
+	//force speed to 1000Mbps
+	mac_port_config &= (~(0x3 << 8));
+	mac_port_config |= (0x2 << 8);	//jacky
+
+	//force tx and rx follow control
+	mac_port_config |= (0x1 << 11) | (0x1 << 12);
+
+	//force full deplex
+	mac_port_config |= 0x1 << 10;
+
+	//RGMII ENABLR
+	mac_port_config |= 0x1 << 15;
+
+	GSW_MAC_PORT_0_CONFIG = mac_port_config;
+
+	udelay(1000);
+
+	/* adjust MAC port 0 RX/TX clock skew */
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 24) | (0x3 << 26));
+	GSW_BIST_RESULT_TEST_0 |= ((0x2 << 24) | (0x2 << 26));
+	
+	// configure MAC port 0 pad drive strength = 10/100 mode
+	*(u32 volatile *) (0xf770001C) |= (0x1 << 2);
+}
+
+
+
+// agere power down/up
+int AGERE_phy_power_down(int phy_addr, int y)
+{
+	u16 phy_data = 0;
+	// power-down or up the PHY
+	star_gsw_read_phy(phy_addr, 0, &phy_data);
+	if (y==1) // down
+		phy_data |= (0x1 << 11);
+	if (y==0) // up
+		phy_data &= (~(0x1 << 11));
+	star_gsw_write_phy(phy_addr, 0, phy_data);
+	return 0;
+}
+
+// add by descent 2006/07/31
+// standard phy register 0 and offset is 11 is power down
+int std_phy_power_down(int phy_addr, int y)
+{
+	u16 phy_data = 0;
+	// power-down or up the PHY
+	star_gsw_read_phy(phy_addr, 0, &phy_data);
+	if (y==1) // down
+		phy_data |= (0x1 << 11);
+	if (y==0) // up
+		phy_data &= (~(0x1 << 11));
+	star_gsw_write_phy(phy_addr, 0, phy_data);
+	return 0;
+}
+
+
+/*
+ *  AGERE PHY is attached to MAC PORT 1
+ * with phy_addr 1
+ */
+void star_gsw_config_AGERE()
+{
+	u32 mac_port_config;
+	u16 phy_data = 0;
+	int i;
+
+	printk("configure port1 AGERE\n");
+
+	/*
+	 * Configure MAC port 1
+	 * For Agere Systems's ET1011 single PHY
+	 */
+	mac_port_config = GSW_MAC_PORT_1_CONFIG;
+
+	// disable PHY's AN
+	mac_port_config &= ~(0x1 << 7);
+
+	// enable RGMII-PHY mode
+	mac_port_config |= (0x1 << 15);
+
+	GSW_MAC_PORT_1_CONFIG = mac_port_config;
+
+#if 1
+	/*
+	 * configure Agere's ET1011 Single PHY
+	 */
+	/* Configure Agere's ET1011 by Agere's programming note */
+	//1. power-down the PHY
+	star_gsw_read_phy(1, 0, &phy_data);
+	phy_data |= (0x1 << 11);
+	star_gsw_write_phy(1, 0, phy_data);
+
+	//2. Enable PHY programming mode
+	star_gsw_read_phy(1, 18, &phy_data);
+	phy_data |= (0x1 << 0);
+	phy_data |= (0x1 << 2);
+	star_gsw_write_phy(1, 18, phy_data);
+
+	//3.Perform some PHY register with the Agere-specfic value
+	star_gsw_write_phy(1, 16, 0x880e);
+	star_gsw_write_phy(1, 17, 0xb4d3);
+
+	star_gsw_write_phy(1, 16, 0x880f);
+	star_gsw_write_phy(1, 17, 0xb4d3);
+
+	star_gsw_write_phy(1, 16, 0x8810);
+	star_gsw_write_phy(1, 17, 0xb4d3);
+
+	star_gsw_write_phy(1, 16, 0x8817);
+	star_gsw_write_phy(1, 17, 0x1c00);
+
+	star_gsw_write_phy(1, 16, 0x8805);
+	star_gsw_write_phy(1, 17, 0xb03e);
+
+	star_gsw_write_phy(1, 16, 0x8806);
+	star_gsw_write_phy(1, 17, 0xb03e);
+
+	star_gsw_write_phy(1, 16, 0x8807);
+	star_gsw_write_phy(1, 17, 0xff00);
+
+	star_gsw_write_phy(1, 16, 0x8808);
+	star_gsw_write_phy(1, 17, 0xe110);
+
+	star_gsw_write_phy(1, 16, 0x300d);
+	star_gsw_write_phy(1, 17, 0x0001);
+
+	//4. Disable PHY programming mode
+	star_gsw_read_phy(1, 18, &phy_data);
+	phy_data &= ~(0x1 << 0);
+	phy_data &= ~(0x1 << 2);
+	star_gsw_write_phy(1, 18, phy_data);
+
+	//5. power-up the PHY
+	star_gsw_read_phy(1, 0, &phy_data);
+	phy_data &= ~(0x1 << 11);
+	star_gsw_write_phy(1, 0, phy_data);
+
+	star_gsw_read_phy(1, 22, &phy_data);
+
+	// enable RGMII MAC interface mode : RGMII/RMII (dll delay or trace delay) mode
+	phy_data &= ~(0x7 << 0);
+
+	// phy_data |= (0x6 << 0); // RGMII/RMII dll delay mode : not work!!
+	phy_data |= (0x4 << 0);	// RGMII/RMII trace delay mode
+
+	star_gsw_write_phy(1, 22, phy_data);
+#endif
+
+	mac_port_config = GSW_MAC_PORT_1_CONFIG;
+
+	// enable PHY's AN
+	mac_port_config |= (0x1 << 7);
+
+	GSW_MAC_PORT_1_CONFIG = mac_port_config;
+
+	/*
+	 * Enable flow-control on (Symmetric PAUSE frame)
+	 */
+	star_gsw_read_phy(1, 0x4, &phy_data);
+
+	phy_data |= (0x1 << 10);
+
+	star_gsw_write_phy(1, 0x4, phy_data);
+
+	/*
+	 * Enable PHY1 AN restart bit to restart PHY1 AN
+	 */
+	star_gsw_read_phy(1, 0x0, &phy_data);
+
+	phy_data |= (0x1 << 9) | (0x1 << 12);
+
+	star_gsw_write_phy(1, 0x0, phy_data);
+
+	/*
+	 * Polling until PHY1 AN restart is complete and PHY1 link status is UP
+	 */
+	for (i = 0; i < 0x2000; i++) {
+		star_gsw_read_phy(1, 0x1, &phy_data);
+		if ((phy_data & (0x1 << 5)) && (phy_data & (0x1 << 2))) {
+			break;
+		}
+	}
+
+	// adjust MAC port 1 RX/TX clock skew
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 28) | (0x3 << 30));
+	GSW_BIST_RESULT_TEST_0 |= ((0x2 << 28) | (0x3 << 30));
+
+	udelay(100);
+
+	mac_port_config = GSW_MAC_PORT_1_CONFIG;
+	if (!(mac_port_config & 0x1) || (mac_port_config & 0x2)) {
+		/*
+		 * Port 1 PHY link down or no TXC in Port 1
+		 */
+		PDEBUG("PHY1: Link Down, 0x%08x!\n", mac_port_config);
+		return;
+	}
+
+}
+
+
+
+int str9100_gsw_config_mac_port0()
+{
+        PDEBUG("str9100_gsw_config_mac_port0\n");
+        INIT_PORT0_PHY
+	INIT_PORT0_MAC
+        PORT0_LINK_DOWN
+        return 0;
+}
+
+int str9100_gsw_config_mac_port1()
+{
+        INIT_PORT1_PHY
+	INIT_PORT1_MAC
+        PORT1_LINK_DOWN
+        //PORT1_LINK_UP
+        return 0;
+}
+
+
+#define PHY_CONTROL_REG_ADDR 0x00
+#define PHY_AN_ADVERTISEMENT_REG_ADDR 0x04
+
+
+int icp_101a_init (int port)
+{
+	u32 mac_port_config;
+        u16 phy_data = 0;
+
+
+	PRINT_INFO("init IC+101A\n");
+
+	if (port == 0)		// port 0
+		mac_port_config = GSW_MAC_PORT_0_CONFIG;
+	if (port == 1)		// port 1
+		mac_port_config = GSW_MAC_PORT_1_CONFIG;
+
+	if (!(mac_port_config & (0x1 << 5))) {
+		if (!star_gsw_read_phy (port, PHY_AN_ADVERTISEMENT_REG_ADDR, &phy_data))
+	    	{
+			PDEBUG("\n PORT%d, enable local flow control capability Fail\n", port);
+			return (1);
+	    	}
+		else
+	    	{
+	      		// enable PAUSE frame capability
+			phy_data |= (0x1 << 10);
+
+	      		if (!star_gsw_write_phy (port, PHY_AN_ADVERTISEMENT_REG_ADDR, phy_data))
+			{
+				PDEBUG("\nPORT%d, enable PAUSE frame capability Fail\n", port);
+				return (1);
+			}
+	    	}
+	}
+
+
+	// restart PHY0 AN
+	if (!star_gsw_read_phy (port, PHY_CONTROL_REG_ADDR, &phy_data)) {
+		PDEBUG ("\n restart PHY%d AN Fail \n", port);
+		return (1);
+	}
+	else {
+		// enable PHY0 AN restart
+		phy_data |= (0x1 << 9);
+
+		if (!star_gsw_write_phy (port, PHY_CONTROL_REG_ADDR, phy_data)) {
+			PDEBUG ("\n  enable PHY0 AN restart \n");
+			return (1);
+		}
+	}
+
+
+
+	while (1)
+	{
+		PDEBUG ("\n Polling  PHY%d AN \n", port);
+		star_gsw_read_phy (port, PHY_CONTROL_REG_ADDR, &phy_data);
+
+		if (phy_data & (0x1 << 9)) {
+		  continue;
+		}
+		else {
+			PDEBUG ("\n PHY%d AN restart is complete \n", port);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LIBRA
+void icp_175c_all_phy_power_down(int y)
+{
+	int i=0;
+
+	for (i=0 ; i < 5 ; ++i)
+		std_phy_power_down(i, y);
+
+}
+
+#define CONFIG_PORT0_5
+
+void configure_icplus_175c_phy(void)
+{
+	u32 volatile	II, jj;
+	u32 volatile	mac_port_config;
+	u16 volatile reg;
+	u32 volatile reg2;
+	int i=0;
+
+	//star_gsw_set_phy_addr(0, 0);
+	//star_gsw_set_phy_addr(1, 1);
+
+	printk("\n ICPLUS175C_PHY,enable PORT0 local flow control capability \n");
+	/* adjust MAC port 0 /RX/TX clock skew */
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 24) | (0x3 << 26));
+	GSW_BIST_RESULT_TEST_0 |= ((0x2 << 24) | (0x2 << 26));
+
+// 20061117 descent
+	// auto polling default phy address is 0
+	// so set phy address to not exist address to avoid auto polling
+	// in STAR library board if no these code, port 0 link state will get half duplex
+	// port 1-4 get full duplex
+        if (star_gsw_set_phy_addr(0, 15))
+                printk ("star_gsw_set_phy_addr(0,2) is successful\n");
+        else
+                printk ("star_gsw_set_phy_addr(0,2) is fail\n");
+
+        if (star_gsw_set_phy_addr(1, 16))
+                printk ("star_gsw_set_phy_addr(1,3) is successful\n");
+        else
+                printk ("star_gsw_set_phy_addr(1,3) is fail\n");
+
+
+
+	#if 0
+	// for PHY_AN_ADVERTISEMENT_REG_ADDR
+	// in this case needn't this code, only for reference
+		star_gsw_read_phy(i, 4, &phy_data);
+		phy_data |= (0x1 << 10);  // Enable PAUSE frame capability of PHY 0
+		phy_data |= (0x1 << 5) | (0x1 << 6) | (0x1 << 7) | (0x1 << 8);
+		star_gsw_write_phy(i, 4, phy_data);
+		star_gsw_read_phy(i, 0, &phy_data);
+		phy_data |= (0x1 << 9) | (0x1 << 12);  // Enable AN and Restart-AN
+		star_gsw_write_phy(i, 0, phy_data);
+	#endif
+// 20061117 descent end
+
+
+#if 0
+	for (i=0 ; i < 10; ++i)
+	{
+	  star_gsw_read_phy(i, 2, &reg);
+	  printk("addr: %d, phyid: %x\n", i, reg);
+	}
+
+
+
+
+	/*
+	 * Configure GSW's MAC port 0
+	 * For ASIX's 5-port GbE Switch setting
+	 * 1. No SMI (MDC/MDIO) connection between Orion's MAC port 0 and ASIX's MAC port 4
+	 * 2. Force Orion's MAC port 0 to be 1000Mbps, and full-duplex, and flow control on
+	 */
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+
+
+	// enable RGMII-PHY mode
+	mac_port_config &= ~(0x1 << 15);
+
+	// force speed = 100Mbps
+	mac_port_config &= ~(0x3 << 8);
+	mac_port_config |= (0x1 << 8);
+
+	// force full-duplex
+	mac_port_config |= (0x1 << 10);
+
+	// force Tx/Rx flow-control on
+	mac_port_config |= (0x1 << 11) | (0x1 << 12);
+
+	GSW_MAC_PORT_0_CONFIG = mac_port_config;
+	star_gsw_write_phy(29, 31, 0x175C);
+	//star_gsw_write_phy(30, 9, 0x1089);
+	star_gsw_write_phy(29, 23, 0x2);
+
+	star_gsw_write_phy(29, 24, 0x2);
+	star_gsw_write_phy(29, 25, 0x1);
+	star_gsw_write_phy(29, 26, 0x1);
+	star_gsw_write_phy(29, 27, 0x1);
+	star_gsw_write_phy(29, 28, 0x1);
+	star_gsw_write_phy(29, 29, 0x2);
+
+	star_gsw_write_phy(30, 1, (0x3e << 8) );
+	star_gsw_write_phy(30, 2, 0x21);
+	star_gsw_write_phy(30, 9, 0x80);
+
+	udelay(1000);
+
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+	if (((mac_port_config & 0x1) == 0) || (mac_port_config & 0x2)) {
+		printk("Check MAC/PHY 0 Link Status : DOWN!\n");
+	} else {
+		printk("Check MAC/PHY 0 Link Status : UP!\n");
+	}
+
+	/* adjust MAC port 0 /RX/TX clock skew */
+	GSW_BIST_RESULT_TEST_0 &= ~((0x3 << 24) | (0x3 << 26));
+	GSW_BIST_RESULT_TEST_0 |= ((0x2 << 24) | (0x2 << 26));
+
+
+#endif
+
+
+
+#if 1
+
+	
+#if 1
+	reg2 = __REG(PWR_PAD_DRV_REG);
+	PDEBUG("[PWR_PAD_DRV_REG = %x]\n", reg2);
+	reg2 = reg2 | 0x4;
+
+	__REG(PWR_PAD_DRV_REG) = reg2;
+
+	reg2 = __REG(PWR_PAD_DRV_REG);
+	PDEBUG("[PWR_PAD_DRV_REG = %x]\n", reg2);
+#endif
+	
+	star_gsw_write_phy(29, 31, 0x175C);
+	
+
+	star_gsw_read_phy(0, 2, &reg);
+	PDEBUG("[0,%d,%x]\n", 2, reg);
+	star_gsw_read_phy(29, 31, &reg);
+	PDEBUG("[29,%d,%x]\n", 31, reg);
+
+	star_gsw_write_phy(29, 23, 0x7C2);
+	star_gsw_write_phy(29, 24, 0x1);
+	star_gsw_write_phy(29, 25, 0x1);
+	star_gsw_write_phy(29, 26, 0x1);
+
+#ifdef CONFIG_PORT0_5
+	star_gsw_write_phy(29, 27, 0x1);
+#else
+	star_gsw_write_phy(29, 27, 0x2);
+#endif
+	star_gsw_write_phy(29, 28, 0x2);
+	star_gsw_write_phy(29, 30, 0x2);
+
+#ifdef CONFIG_PORT0_5
+	printk("CONFIG_PORT0_5\n");
+	star_gsw_write_phy(30, 1, 0x2f00);
+	star_gsw_write_phy(30, 2, 0x30);
+#else // port0_4
+	printk("not CONFIG_PORT0_5\n");
+
+
+        //star_gsw_write_phy(30, 1, 0x2f00);
+        star_gsw_write_phy(30, 1, 0x2700);
+        //star_gsw_write_phy(30, 2, 0x30);
+        star_gsw_write_phy(30, 2, 0x38);
+
+#endif
+
+
+	star_gsw_write_phy(30, 9, 0x80);
+
+// 20061115 descent
+// If no these code,
+// in STAR libra board, will get crc drop
+	// configure port 4 (MII 0)
+	// configure port 4 (MII 0)
+
+	// P4_FORCE
+	star_gsw_read_phy(29, 22, &reg);
+	reg |= (0x1 << 15);
+        star_gsw_write_phy(29, 22, reg);
+
+	
+	// MAC_X_EN, flow control enable of MII0 and MII2
+	star_gsw_read_phy(29, 18, &reg);
+	reg |= (0x1 << 10);
+        star_gsw_write_phy(29, 18, reg);
+
+
+	// P4_FORCE 100 Mbps
+	star_gsw_read_phy(29, 22, &reg);
+	reg |= (0x1 << 10);
+        star_gsw_write_phy(29, 22, reg);
+
+
+	// P4_FORCE_FULL duplex
+	star_gsw_read_phy(29, 22, &reg);
+	reg |= (0x1 << 5);
+        star_gsw_write_phy(29, 22, reg);
+
+// 20061115 descent end
+
+
+
+
+
+	
+	#if 0
+	// enable flow control
+	star_gsw_read_phy(29, 18, &reg);
+	reg |= (0x1 < 13);
+	star_gsw_write_phy(29, 18, reg);
+	star_gsw_read_phy(29, 18, &reg);
+	printk("[29,%d,%x]\n", 18, reg);
+	#endif
+#if 0
+	//star_gsw_read_phy(29, 23, &reg);
+	//reg = reg & 0xF800;
+	//reg = reg | 0x7C2;
+
+
+	star_gsw_write_phy(29, 24, 0x1);
+
+	star_gsw_read_phy(29, 24, &reg);
+	PDEBUG("[  29, 24, %x]\n", reg);
+
+	star_gsw_write_phy(29, 25, 0x2);
+	udelay(1000);
+
+	star_gsw_read_phy(29, 25, &reg);
+	PDEBUG("[  29, 25, %x]\n", reg);
+
+	star_gsw_write_phy(29, 26, 0x1);
+	star_gsw_write_phy(29, 27, 0x1);
+	star_gsw_write_phy(29, 28, 0x1);
+	star_gsw_write_phy(29, 30, 0x2);
+
+	// tag vlan mask
+
+	star_gsw_write_phy(30, 1, 0x3F3D);
+
+	star_gsw_write_phy(30, 2, 0x3F22);
+	star_gsw_write_phy(30, 9, 0x1089);
+	// star_gsw_write_phy(30, 1, 0x3D22);
+	// star_gsw_write_phy(30, 9, 0x028A);
+#endif
+
+#if 0
+
+	for(II=18;II<=30;II++)
+	{
+		star_gsw_read_phy(29, II, &reg);
+		PDEBUG("[29,%d,%x]\n", II, reg);
+	}
+
+	for(II=1;II<=10;II++)
+	{
+		star_gsw_read_phy(30, II, &reg);
+		PDEBUG("[30,%d,%x]\n", II, reg);
+	}
+
+#endif
+
+	mac_port_config = GSW_MAC_PORT_0_CONFIG;
+
+	// disable PHY's AN
+	mac_port_config &= ~(0x1 << 7);
+
+	// disable RGMII-PHY mode
+	mac_port_config &= ~(0x1 << 15);
+
+	// force speed = 100Mbps
+	mac_port_config &= ~(0x3 << 8);
+	mac_port_config |= (0x1 << 8);
+	
+	// force full-duplex
+	mac_port_config |= (0x1 << 10);
+
+	// force Tx/Rx flow-control on
+	mac_port_config |= (0x1 << 11) | (0x1 << 12);
+
+	GSW_MAC_PORT_0_CONFIG = mac_port_config;
+
+
+#if 0
+	for (II = 0; II < 0x2000; II++)
+	{
+		mac_port_config = GSW_MAC_PORT_0_CONFIG;
+		
+		if ((mac_port_config & 0x1) && !(mac_port_config & 0x2))
+		{
+
+			/* enable MAC port 0
+			*/
+			mac_port_config &= ~(0x1 << 18);
+
+		
+			/*
+			* enable the forwarding of unknown, multicast and broadcast packets to CPU
+			*/
+			mac_port_config &= ~((0x1 << 25) | (0x1 << 26) | (0x1 << 27));
+		
+			/*
+			* include unknown, multicast and broadcast packets into broadcast storm
+			*/
+			mac_port_config |= ((0x1 << 29) | (0x1 << 30) | ((u32)0x1 << 31));
+			// mac_port_config |= ( (0x1 << 30) | ((u32)0x1 << 31));
+			
+			GSW_MAC_PORT_0_CONFIG = mac_port_config;
+			
+			break;
+		}
+	}
+#endif
+
+	if (!(mac_port_config & 0x1) || (mac_port_config & 0x2))
+	{
+		/*
+		* Port 0 PHY link down or no TXC in Port 0
+		*/
+		printk("\rCheck MAC/PHY 0 Link Status : DOWN!\n");
+		
+	}
+	else
+	{
+		printk("\rCheck MAC/PHY 0 Link Status : UP!\n");
+	}
+#endif
+
+	//printk("Found ICPLUS175C_PHY\n");
+}
+#endif
diff -Nur linux-2.6.35.11/drivers/net/str9100/star_gsw_phy.h linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_phy.h
--- linux-2.6.35.11/drivers/net/str9100/star_gsw_phy.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/star_gsw_phy.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,160 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __STAR_GSW_PHY_H__
+#define __STAR_GSW_PHY_H__
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,32)
+#define LINUX24 1
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26 1
+#endif
+
+#include <linux/types.h>
+
+
+//#define CONFIG_VIRGO
+//#define CONFIG_DORADO
+//#define CONFIG_DORADO2
+//#define CONFIG_LEO
+//#undef CONFIG_VIRGO
+//#undef CONFIG_DORADO
+//#undef CONFIG_DORADO2
+//#undef CONFIG_LEO
+
+#ifdef CONFIG_LIBRA
+#include "libra.h"
+#endif
+
+#ifdef CONFIG_VELA
+#include "vela.h"
+#endif
+
+#ifdef CONFIG_DORADO2
+#include "dorado2.h"
+#endif
+
+#ifdef CONFIG_DORADO
+#include "dorado.h"
+#endif
+
+#ifdef CONFIG_LEO
+#include "leo.h"
+#endif
+
+#ifdef CONFIG_VIRGO
+#include "virgo.h"
+#endif
+
+
+void star_gsw_config_ASIX(void);
+void star_gsw_config_AGERE(void);
+int AGERE_phy_power_down(int phy_addr, int y);
+int disable_AN_VSC7385(int y);
+void star_gsw_config_VSC7385(void);
+
+
+
+
+void star_gsw_config_AGERE(void);
+
+int str9100_gsw_config_mac_port0(void);
+int str9100_gsw_config_mac_port1(void);
+
+
+
+#define PORT0				(1 << 0)	/* bit map : bit 0 */
+#define PORT1				(1 << 1)	/* bit map : bit 1 */
+#define CPU_PORT			(1 << 2)	/* bit map : bit 2 */
+
+#define VLAN0_GROUP_ID			(0)
+#define VLAN1_GROUP_ID			(1)
+#define VLAN2_GROUP_ID			(2)
+#define VLAN3_GROUP_ID			(3)
+#define VLAN4_GROUP_ID			(4)
+#define VLAN5_GROUP_ID			(5)
+#define VLAN6_GROUP_ID			(6)
+#define VLAN7_GROUP_ID			(7)
+
+#define PORT0_PVID			(VLAN1_GROUP_ID)
+#define PORT1_PVID			(VLAN2_GROUP_ID)
+#define CPU_PORT_PVID			(VLAN0_GROUP_ID)
+
+#define INVALID_PORT_BASE_PMAP_PORT -1
+
+
+#ifdef LINUX26
+#define GSW_MAC_PORT_0_CONFIG GSW_MAC_PORT_0_CONFIG_REG
+#define GSW_MAC_PORT_1_CONFIG GSW_MAC_PORT_1_CONFIG_REG
+#define GSW_PORT_MIRROR GSW_PORT_MIRROR_REG
+#define GSW_QUEUE_STATUS_TEST_1 GSW_QUEUE_STATUS_TEST_1_REG
+#define GSW_PHY_CONTROL GSW_PHY_CONTROL_REG
+#define GSW_BIST_RESULT_TEST_0 GSW_BIST_RESULT_TEST_0_REG
+#define GSW_PORT0_CFG_REG (SYSVA_GSW_BASE_ADDR + 0x08)
+#define GSW_PORT1_CFG_REG (SYSVA_GSW_BASE_ADDR + 0x0C)
+#define GSW_SWITCH_CONFIG GSW_SWITCH_CONFIG_REG
+#define GSW_ARL_TABLE_ACCESS_CONTROL_0 GSW_ARL_TABLE_ACCESS_CONTROL_0_REG
+#define GSW_ARL_TABLE_ACCESS_CONTROL_1 GSW_ARL_TABLE_ACCESS_CONTROL_1_REG
+#define GSW_ARL_TABLE_ACCESS_CONTROL_2 GSW_ARL_TABLE_ACCESS_CONTROL_2_REG
+#define GSW_VLAN_PORT_PVID GSW_VLAN_PORT_PVID_REG
+#define GSW_VLAN_VID_0_1 GSW_VLAN_VID_0_1_REG
+#define GSW_VLAN_VID_2_3 GSW_VLAN_VID_2_3_REG
+#define GSW_VLAN_VID_4_5 GSW_VLAN_VID_4_5_REG
+#define GSW_VLAN_VID_6_7 GSW_VLAN_VID_6_7_REG
+#define GSW_VLAN_MEMBER_PORT_MAP GSW_VLAN_MEMBER_PORT_MAP_REG
+#define GSW_VLAN_TAG_PORT_MAP GSW_VLAN_TAG_PORT_MAP_REG
+#define GSW_INTERRUPT_MASK GSW_INTERRUPT_MASK_REG
+#define GSW_INTERRUPT_STATUS GSW_INTERRUPT_STATUS_REG
+#define INTC_INTERRUPT_CLEAR_EDGE_TRIGGER INTC_INTERRUPT_CLEAR_EDGE_TRIGGER_REG
+#define GSW_TS_DMA_CONTROL GSW_TS_DMA_CONTROL_REG
+#define GSW_FS_DMA_CONTROL GSW_FS_DMA_CONTROL_REG
+#define GSW_TS_DESCRIPTOR_POINTER GSW_TS_DESCRIPTOR_POINTER_REG
+#define GSW_TS_DESCRIPTOR_BASE_ADDR GSW_TS_DESCRIPTOR_BASE_ADDR_REG
+#define GSW_FS_DESCRIPTOR_POINTER GSW_FS_DESCRIPTOR_POINTER_REG
+#define GSW_FS_DESCRIPTOR_BASE_ADDR GSW_FS_DESCRIPTOR_BASE_ADDR_REG
+#define GSW_CPU_PORT_CONFIG GSW_CPU_PORT_CONFIG_REG
+#define INTC_INTERRUPT_MASK INTC_INTERRUPT_MASK_REG
+#define GSW_DELAYED_INTERRUPT_CONFIG GSW_DELAYED_INTERRUPT_CONFIG_REG
+#define GSW_HNAT_SOURCE_MAC_0_HIGH GSW_HNAT_SOURCE_MAC_0_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_0_LOW GSW_HNAT_SOURCE_MAC_0_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_1_HIGH GSW_HNAT_SOURCE_MAC_1_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_1_LOW GSW_HNAT_SOURCE_MAC_1_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_2_HIGH GSW_HNAT_SOURCE_MAC_2_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_2_LOW GSW_HNAT_SOURCE_MAC_2_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_3_HIGH GSW_HNAT_SOURCE_MAC_3_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_3_LOW GSW_HNAT_SOURCE_MAC_3_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_4_HIGH GSW_HNAT_SOURCE_MAC_4_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_4_LOW GSW_HNAT_SOURCE_MAC_4_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_5_HIGH GSW_HNAT_SOURCE_MAC_5_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_5_LOW GSW_HNAT_SOURCE_MAC_5_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_6_HIGH GSW_HNAT_SOURCE_MAC_6_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_6_LOW GSW_HNAT_SOURCE_MAC_6_LOW_REG
+#define GSW_HNAT_SOURCE_MAC_7_HIGH GSW_HNAT_SOURCE_MAC_7_HIGH_REG
+#define GSW_HNAT_SOURCE_MAC_7_LOW GSW_HNAT_SOURCE_MAC_7_LOW_REG
+#define PWRMGT_SOFTWARE_RESET_CONTROL PWRMGT_SOFTWARE_RESET_CONTROL_REG
+
+#endif
+
+#endif /* __STAR_GSW_PHY_H__ */
diff -Nur linux-2.6.35.11/drivers/net/str9100/vela.h linux-2.6.35.11-ts7500//drivers/net/str9100/vela.h
--- linux-2.6.35.11/drivers/net/str9100/vela.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/vela.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef VELA_H
+#define VELA_H
+
+// add by descent 2006/07/07
+#define VELA
+#ifdef VELA
+// init phy or switch chip
+#define INIT_PORT0_PHY icp_101a_init(0);
+#define INIT_PORT1_PHY icp_101a_init(1);
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC init_packet_forward(1);
+
+#define PORT0_LINK_DOWN std_phy_power_down(0, 1);
+#define PORT0_LINK_UP std_phy_power_down(0, 0);
+
+#define PORT1_LINK_DOWN std_phy_power_down(1, 1);
+#define PORT1_LINK_UP std_phy_power_down(1, 0);
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 star_gsw_probe(WAN_PORT);
+#define CREATE_NET_DEV2
+
+
+#undef CONFIG_STR9100_VLAN_BASE
+#undef CONFIG_HAVE_VLAN_TAG
+
+#define CONFIG_STR9100_PORT_BASE
+// for port base, port base max is 2 port.
+// NET_DEV0 : rx->sp 0 (port 0)
+#define NET_DEV0 STAR_GSW_LAN_DEV
+// NET_DEV1 : rx->sp 1 (port 1)
+#define NET_DEV1 STAR_GSW_WAN_DEV
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT PORT0
+#define PORT_BASE_PMAP_WAN_PORT PORT1
+#define PORT_BASE_PMAP_EWC_PORT INVALID_PORT_BASE_PMAP_PORT
+
+
+// OPEN_PORT include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[LAN_GID].vlan_mac, 6);\
+       		PRINT_INFO("open mac port 0\n");\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* enable port 0 */ \
+	        mac_port_config &= (~(0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+		PORT0_LINK_UP\
+	} \
+	if(dev == STAR_GSW_WAN_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);\
+       		PRINT_INFO("open mac port 1\n");\
+	        mac_port_config = GSW_MAC_PORT_1_CONFIG;\
+       		/* enable port 0 */ \
+	        mac_port_config &= (~(0x1 << 18));\
+       		GSW_MAC_PORT_1_CONFIG = mac_port_config;\
+		PORT1_LINK_UP\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+       		PRINT_INFO("close mac port 0\n");\
+		PORT0_LINK_DOWN\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* disable port 0 */ \
+	        mac_port_config |= ((0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	} \
+	if(dev == STAR_GSW_WAN_DEV) { \
+       		PRINT_INFO("close mac port 1\n");\
+		PORT1_LINK_DOWN\
+	        mac_port_config = GSW_MAC_PORT_1_CONFIG;\
+       		/* disable port 1 */ \
+	        mac_port_config |= ((0x1 << 18));\
+       		GSW_MAC_PORT_1_CONFIG = mac_port_config;\
+	} \
+}
+
+
+#define VLAN0_VID			(0x111)
+#define VLAN1_VID			(0x222)
+#define VLAN2_VID			(0x333)
+#define VLAN3_VID			(0x444)
+#define VLAN4_VID			(0x555)
+#define VLAN5_VID			(0x666)
+#define VLAN6_VID			(0x777)
+#define VLAN7_VID			(0x888)
+
+
+#define VLAN0_GROUP			(PORT0 | PORT1 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(PORT1 | CPU_PORT)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+
+#define VLAN0_VLAN_TAG			(0)
+#define VLAN1_VLAN_TAG			(0)
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+//#define PORT0_PVID			(VLAN0_GROUP_ID)
+//#define PORT1_PVID			(VLAN2_GROUP_ID)
+//#define CPU_PORT_PVID			(VLAN1_GROUP_ID)
+
+static u8 my_vlan0_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xcc, 0x11};
+static u8 my_vlan1_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xcc, 0x21};
+static u8 my_vlan2_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xcc, 0x31};
+static u8 my_vlan3_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xcc, 0x41};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 1
+#define WAN_GID 2
+
+
+#define MODEL "VELA"
+
+#endif // VELA
+
+#endif
+
diff -Nur linux-2.6.35.11/drivers/net/str9100/virgo.h linux-2.6.35.11-ts7500//drivers/net/str9100/virgo.h
--- linux-2.6.35.11/drivers/net/str9100/virgo.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/net/str9100/virgo.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef VIRGO_H
+#define VIRGO_H
+
+// add by descent 2006/07/07
+#define VIRGO
+#ifdef VIRGO
+// init phy or switch chip
+#define INIT_PORT0_PHY star_gsw_config_ASIX();
+#define INIT_PORT1_PHY star_gsw_config_AGERE();
+
+// configure mac0/mac1 register
+#define INIT_PORT0_MAC init_packet_forward(0);
+#define INIT_PORT1_MAC init_packet_forward(1);
+
+#define PORT0_LINK_DOWN disable_AN_VSC7385(0);
+#define PORT0_LINK_UP disable_AN_VSC7385(1);
+
+#define PORT1_LINK_DOWN AGERE_phy_power_down(1,1);
+#define PORT1_LINK_UP AGERE_phy_power_down(1,0);
+
+#define CREATE_NET_DEV0 star_gsw_probe(LAN_PORT);
+#define CREATE_NET_DEV1 star_gsw_probe(WAN_PORT);
+#define CREATE_NET_DEV2
+
+
+#undef CONFIG_STR9100_VLAN_BASE
+#undef CONFIG_HAVE_VLAN_TAG
+
+#define CONFIG_STR9100_PORT_BASE
+// for port base, port base max is 2 port.
+// NET_DEV0 : rx->sp 0 (port 0)
+#define NET_DEV0 STAR_GSW_LAN_DEV
+// NET_DEV1 : rx->sp 1 (port 1)
+#define NET_DEV1 STAR_GSW_WAN_DEV
+
+// for star_gsw_send_packet
+// port base and vlan base packet flow
+#define PORT_BASE_PMAP_LAN_PORT PORT0
+#define PORT_BASE_PMAP_WAN_PORT PORT1
+#define PORT_BASE_PMAP_EWC_PORT INVALID_PORT_BASE_PMAP_PORT
+
+#define MODEL "VIRGO"
+
+// OPEN_PORT include 2 actions
+// 1. enable mac port
+// 2. link up port
+#define OPEN_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[LAN_GID].vlan_mac, 6);\
+       		PRINT_INFO("open mac port 0\n");\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* enable port 0 */ \
+	        mac_port_config &= (~(0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+		PORT0_LINK_UP\
+	} \
+	if(dev == STAR_GSW_WAN_DEV) { \
+		memcpy(dev->dev_addr, star_gsw_info.vlan[WAN_GID].vlan_mac, 6);\
+       		PRINT_INFO("open mac port 1\n");\
+	        mac_port_config = GSW_MAC_PORT_1_CONFIG;\
+       		/* enable port 0 */ \
+	        mac_port_config &= (~(0x1 << 18));\
+       		GSW_MAC_PORT_1_CONFIG = mac_port_config;\
+		PORT1_LINK_UP\
+	} \
+}
+
+// CLOSE_PORT include 2 actions
+// 1. disable mac port
+// 2. link down port
+#define CLOSE_PORT(dev) \
+{ \
+        u32 mac_port_config; \
+ \
+	if (dev == STAR_GSW_LAN_DEV) { \
+       		PRINT_INFO("close mac port 0\n");\
+		PORT0_LINK_DOWN\
+	        mac_port_config = GSW_MAC_PORT_0_CONFIG;\
+       		/* disable port 0 */ \
+	        mac_port_config |= ((0x1 << 18));\
+       		GSW_MAC_PORT_0_CONFIG = mac_port_config;\
+	} \
+	if(dev == STAR_GSW_WAN_DEV) { \
+       		PRINT_INFO("close mac port 1\n");\
+		PORT1_LINK_DOWN\
+	        mac_port_config = GSW_MAC_PORT_1_CONFIG;\
+       		/* disable port 1 */ \
+	        mac_port_config |= ((0x1 << 18));\
+       		GSW_MAC_PORT_1_CONFIG = mac_port_config;\
+	} \
+}
+
+
+#define VLAN0_VID			(0x111)
+#define VLAN1_VID			(0x222)
+#define VLAN2_VID			(0x333)
+#define VLAN3_VID			(0x444)
+#define VLAN4_VID			(0x555)
+#define VLAN5_VID			(0x666)
+#define VLAN6_VID			(0x777)
+#define VLAN7_VID			(0x888)
+
+
+#define VLAN0_GROUP			(PORT0 | PORT1 | CPU_PORT)
+#define VLAN1_GROUP			(PORT0 | CPU_PORT)
+#define VLAN2_GROUP			(PORT1 | CPU_PORT)
+#define VLAN3_GROUP			(0)
+#define VLAN4_GROUP			(0)
+#define VLAN5_GROUP			(0)
+#define VLAN6_GROUP			(0)
+#define VLAN7_GROUP			(0)
+
+#define VLAN0_VLAN_TAG			(0)
+#define VLAN1_VLAN_TAG			(0)
+#define VLAN2_VLAN_TAG			(0)
+#define VLAN3_VLAN_TAG			(0)
+#define VLAN4_VLAN_TAG			(0)
+#define VLAN5_VLAN_TAG			(0)
+#define VLAN6_VLAN_TAG			(0)
+#define VLAN7_VLAN_TAG			(0)
+
+//#define PORT0_PVID			(VLAN0_GROUP_ID)
+//#define PORT1_PVID			(VLAN2_GROUP_ID)
+//#define CPU_PORT_PVID			(VLAN1_GROUP_ID)
+
+static u8 my_vlan0_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x11};
+static u8 my_vlan1_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x21};
+static u8 my_vlan2_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x31};
+static u8 my_vlan3_mac[6] = {0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x41};
+
+// this value is for hnat
+// GID is vlan group id
+#define LAN_GID 1
+#define WAN_GID 2
+
+
+
+#endif // VIRGO
+
+#endif
+
diff -Nur linux-2.6.35.11/drivers/pci/setup-bus.c linux-2.6.35.11-ts7500//drivers/pci/setup-bus.c
--- linux-2.6.35.11/drivers/pci/setup-bus.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/pci/setup-bus.c	2011-02-26 20:32:46.000000000 -0500
@@ -76,6 +76,21 @@
 {
 	u16 class = dev->class >> 8;
 
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+		{
+		u16 cmd;
+
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		cmd |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x8); //configure cache line size
+		pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x40); //configure latency timer
+		}
+
+		if (dev->vendor == 0xeeee)
+			return;
+#endif   
+   
 	/* Don't touch classless devices or host bridges or ioapics.  */
 	if (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)
 		return;
diff -Nur linux-2.6.35.11/drivers/serial/8250.c linux-2.6.35.11-ts7500//drivers/serial/8250.c
--- linux-2.6.35.11/drivers/serial/8250.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/serial/8250.c	2011-02-26 20:32:46.000000000 -0500
@@ -45,6 +45,16 @@
 
 #include "8250.h"
 
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+#include <asm/arch/star_gpio.h>
+extern int __init_or_module gpio_direction_input(unsigned int);
+extern int __init_or_module gpio_direction_output(unsigned int, unsigned int);
+extern void gpio_set_value(unsigned int, unsigned int);
+extern int gpio_get_value(unsigned int);
+unsigned int gpio_cts = 0;
+unsigned int gpio_rts;
+#endif
+
 #ifdef CONFIG_SPARC
 #include "suncore.h"
 #endif
@@ -622,6 +632,7 @@
 	serial_out(up, UART_ICR, value);
 }
 
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)
 static unsigned int serial_icr_read(struct uart_8250_port *up, int offset)
 {
 	unsigned int value;
@@ -633,6 +644,7 @@
 
 	return value;
 }
+#endif
 
 /*
  * FIFO support.
@@ -738,6 +750,13 @@
 }
 #endif /* CONFIG_SERIAL_8250_RSA */
 
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
+{
+	up->port.type = PORT_16550A;
+	return;
+}
+#else
 /*
  * This is a quickie test to see how big the FIFO is.
  * It doesn't work at all the time, more's the pity.
@@ -1253,6 +1272,7 @@
 	spin_unlock_irqrestore(&up->port.lock, flags);
 	DEBUG_AUTOCONF("type=%s\n", uart_config[up->port.type].name);
 }
+#endif
 
 static void autoconfig_irq(struct uart_8250_port *up)
 {
@@ -1447,6 +1467,15 @@
 ignore_char:
 		lsr = serial_inp(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));
+   
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+	if (gpio_rts)
+	{
+		gpio_set_value(CONFIG_GPIO_RTS,0);	/* assert RTS */
+		gpio_rts = 0;
+	}
+#endif   
+   
 	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(tty);
 	spin_lock(&up->port.lock);
@@ -1465,6 +1494,10 @@
 		return;
 	}
 	if (uart_tx_stopped(&up->port)) {
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+		if (gpio_cts)
+			return;
+#endif      
 		serial8250_stop_tx(&up->port);
 		return;
 	}
@@ -1495,6 +1528,22 @@
 {
 	unsigned int status = serial_in(up, UART_MSR);
 
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+	unsigned int gpio_new_cts = gpio_get_value(CONFIG_GPIO_CTS);
+
+	if (!gpio_new_cts)
+		status |= UART_MSR_CTS;		/* Assert CTS */
+	else
+		status &= ~UART_MSR_CTS;	/* Deassert CTS */
+
+	/* CTS pin has been changed */
+	if (gpio_new_cts != gpio_cts)
+	{
+		status |= UART_MSR_DCTS;
+		gpio_cts = gpio_new_cts;
+	}
+#endif
+
 	status |= up->msr_saved_flags;
 	up->msr_saved_flags = 0;
 	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
@@ -1521,10 +1570,24 @@
 {
 	unsigned int status;
 	unsigned long flags;
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+	unsigned int iir;
+#endif
 
 	spin_lock_irqsave(&up->port.lock, flags);
 
 	status = serial_inp(up, UART_LSR);
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+		iir = serial_in(up, UART_IIR);
+
+		if ((iir & 0x6) == 0x6)
+			printk("Overrun error!\n");
+		else if (iir & 0x4)
+		{
+			gpio_set_value(CONFIG_GPIO_RTS,1);		
+			gpio_rts = 1;
+		}
+#endif
 
 	DEBUG_INTR("status = %x...", status);
 
@@ -1819,7 +1882,19 @@
 	unsigned char mcr = 0;
 
 	if (mctrl & TIOCM_RTS)
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+	{
 		mcr |= UART_MCR_RTS;
+		gpio_set_value(CONFIG_GPIO_RTS,0);	/* assert RTS */
+	}
+	else
+	{
+		mcr &= ~UART_MCR_RTS;
+		gpio_set_value(CONFIG_GPIO_RTS,1);	/* deassert RTS */
+	}
+#else
+		mcr |= UART_MCR_RTS;
+#endif
 	if (mctrl & TIOCM_DTR)
 		mcr |= UART_MCR_DTR;
 	if (mctrl & TIOCM_OUT1)
@@ -1938,6 +2013,9 @@
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 	unsigned long flags;
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)
+	unsigned char lsr;
+#endif   
 	unsigned char lsr, iir;
 	int retval;
 
@@ -2107,6 +2185,7 @@
 	if (skip_txen_test || up->port.flags & UPF_NO_TXEN_TEST)
 		goto dont_test_tx_en;
 
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)   
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -2125,6 +2204,7 @@
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
+#endif
 
 dont_test_tx_en:
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2812,7 +2892,11 @@
 static int __init serial8250_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+	int baud = CONFIG_CONSOLE_BAUD_RATE;
+#else
 	int baud = 9600;
+#endif
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
@@ -3023,6 +3107,7 @@
 	return 0;
 }
 
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)
 static int serial8250_suspend(struct platform_device *dev, pm_message_t state)
 {
 	int i;
@@ -3050,12 +3135,15 @@
 
 	return 0;
 }
+#endif
 
 static struct platform_driver serial8250_isa_driver = {
 	.probe		= serial8250_probe,
 	.remove		= __devexit_p(serial8250_remove),
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)
 	.suspend	= serial8250_suspend,
 	.resume		= serial8250_resume,
+#endif
 	.driver		= {
 		.name	= "serial8250",
 		.owner	= THIS_MODULE,
@@ -3197,6 +3285,31 @@
 {
 	int ret;
 
+#ifdef CONFIG_SERIAL_8250_CTSRTS
+	/* enable GPIO pin function */
+	MISC_GPIOB_PIN_ENABLE_REG &= ~(1 << CONFIG_GPIO_CTS | 1 << CONFIG_GPIO_RTS | 1 << CONFIG_GPIO_DCD \
+						| 1<<CONFIG_GPIO_DTR | 1<<CONFIG_GPIO_DSR | 1<<CONFIG_GPIO_RI);
+
+	/* configure CTS pin (input) */
+	gpio_direction_input(CONFIG_GPIO_CTS);
+	gpio_cts = gpio_get_value(CONFIG_GPIO_CTS);
+
+	/* configure RTS pin (output) and set to high */
+	gpio_direction_output(CONFIG_GPIO_RTS,1);
+
+	/* configure DCD pin (input) */
+	gpio_direction_input(CONFIG_GPIO_DCD);
+
+	/* configure DTR pin (ouput) and set to low */
+	gpio_direction_output(CONFIG_GPIO_DTR,0);
+
+	/* configure DSR pin (input) */
+	gpio_direction_input(CONFIG_GPIO_DSR);
+
+	/* configure RI pin (input) */
+	gpio_direction_input(CONFIG_GPIO_RI);
+#endif
+
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
diff -Nur linux-2.6.35.11/drivers/serial/8250_early.c linux-2.6.35.11-ts7500//drivers/serial/8250_early.c
--- linux-2.6.35.11/drivers/serial/8250_early.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/serial/8250_early.c	2011-02-26 20:32:46.000000000 -0500
@@ -46,6 +46,24 @@
 
 static struct early_serial8250_device early_device;
 
+
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+static unsigned int __init serial_in(struct uart_port *port, int offset)
+{
+	if (port->iotype == UPIO_MEM)
+		return readb(port->membase + (offset << 2));
+	else
+		return inb(port->iobase + (offset << 2));
+}
+
+static void __init serial_out(struct uart_port *port, int offset, int value)
+{
+	if (port->iotype == UPIO_MEM)
+		writeb(value, port->membase + (offset << 2));
+	else
+		outb(value, port->iobase + (offset << 2));
+}
+#else
 static unsigned int __init serial_in(struct uart_port *port, int offset)
 {
 	if (port->iotype == UPIO_MEM)
@@ -62,6 +80,9 @@
 		outb(value, port->iobase + offset);
 }
 
+
+#endif
+
 #define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
 
 static void __init wait_for_xmitr(struct uart_port *port)
diff -Nur linux-2.6.35.11/drivers/serial/Kconfig linux-2.6.35.11-ts7500//drivers/serial/Kconfig
--- linux-2.6.35.11/drivers/serial/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/serial/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -163,6 +163,62 @@
 	  say N here to save some memory. You can also say Y if you have an
 	  "intelligent" multiport card such as Cyclades, Digiboards, etc.
 
+config SERIAL_8250_CTSRTS
+	bool "Support hardware flow-control"
+	depends on SERIAL_8250 && ARCH_STR8100
+	default N
+	help
+	  say Y here if you want Hardware Flow Control supoort. 
+	  GPIOs are used to implement CTS and RTS function.
+
+config GPIO_CTS
+	int	"GPIO pin number of CTS"
+	depends on SERIAL_8250_CTSRTS
+	default 0
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63
+
+config GPIO_RTS
+	int	"GPIO pin number of RTS"
+	depends on SERIAL_8250_CTSRTS
+	default 1
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63
+
+config GPIO_DCD
+	int	"GPIO pin number of DCD"
+	depends on SERIAL_8250_CTSRTS
+	default 2
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63
+
+config GPIO_DTR
+	int	"GPIO pin number of DTR"
+	depends on SERIAL_8250_CTSRTS
+	default 3
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63
+	
+config GPIO_DSR
+	int	"GPIO pin number of DSR"
+	depends on SERIAL_8250_CTSRTS
+	default 4
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63
+
+config GPIO_RI
+	int	"GPIO pin number of RI"
+	depends on SERIAL_8250_CTSRTS
+	default 5
+	help
+	  GPIOA[0:31]  0~31
+	  GPIOB[0:31] 32~63     
+     
 #
 # Multi-port serial cards
 #
diff -Nur linux-2.6.35.11/drivers/spi/Kconfig linux-2.6.35.11-ts7500//drivers/spi/Kconfig
--- linux-2.6.35.11/drivers/spi/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/spi/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -100,6 +100,15 @@
 	  inexpensive battery powered microcontroller evaluation board.
 	  This same cable can be used to flash new firmware.
 
+# Eileen , for linux kernel 2.6.24 , 20080413 
+config SPI_STR8100
+	tristate "STR8100 SPI master"
+	depends on SPI_MASTER && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  STR8100 SPI master support
+
+     
 config SPI_COLDFIRE_QSPI
 	tristate "Freescale Coldfire QSPI controller"
 	depends on (M520x || M523x || M5249 || M527x || M528x || M532x)
diff -Nur linux-2.6.35.11/drivers/spi/Makefile linux-2.6.35.11-ts7500//drivers/spi/Makefile
--- linux-2.6.35.11/drivers/spi/Makefile	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/spi/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -47,6 +47,7 @@
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+obj-$(CONFIG_SPI_STR8100)		+= spi_str8100.o
 
 # special build for s3c24xx spi driver with fiq support
 spi_s3c24xx_hw-y			:= spi_s3c24xx.o
diff -Nur linux-2.6.35.11/drivers/spi/spi_bitbang.c linux-2.6.35.11-ts7500//drivers/spi/spi_bitbang.c
--- linux-2.6.35.11/drivers/spi/spi_bitbang.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/spi/spi_bitbang.c	2011-02-26 20:32:46.000000000 -0500
@@ -335,6 +335,16 @@
 				 */
 				if (!m->is_dma_mapped)
 					t->rx_dma = t->tx_dma = 0;
+/* Eileen , for linux kernel 2.6.24 , 20080413 */
+#ifdef CONFIG_ARCH_STR8100
+
+				if (t->transfer_list.next == &m->transfers) {
+					t->last_in_message_list = 1;
+				} else {
+					t->last_in_message_list = 0;
+				}
+				
+#endif            
 				status = bitbang->txrx_bufs(spi, t);
 			}
 			if (status > 0)
diff -Nur linux-2.6.35.11/drivers/spi/spi.c linux-2.6.35.11-ts7500//drivers/spi/spi.c
--- linux-2.6.35.11/drivers/spi/spi.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/spi/spi.c	2011-02-26 20:38:39.000000000 -0500
@@ -22,12 +22,29 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
-#include <linux/mutex.h>
+//#include <linux/mutex.h>
+#include <linux/semaphore.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
 
+#include <mach/star_spi.h>
 
+static inline u8 str8131_spi_bus_idle(void)
+{
+       return ((SPI_SERVICE_STATUS_REG & 0x1) ? 0 : 1);
+}
+
+static inline u8 str8131_spi_tx_buffer_empty(void)
+{
+       return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 3)) ? 1 : 0);
+}
+
+static inline u8 str8131_spi_rx_buffer_full(void)
+{
+       return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 2)) ? 1 : 0);
+}
+		 
 /* SPI bustype and spi_master class are registered after board init code
  * provides the SPI device tables, ensuring that both are present by the
  * time controller driver registration causes spi_devices to "enumerate".
@@ -855,6 +872,82 @@
 }
 EXPORT_SYMBOL_GPL(spi_write_then_read);
 
+
+#ifdef CONFIG_ARCH_STR8100
+/**
+ * spi_write_read_sync - SPI synchronous write & read
+ * @spi: device with which data will be exchanged
+ * @txbuf: data to be written (need not be dma-safe)
+ * @n_tx: size of txbuf, in bytes
+ * @rxbuf: buffer into which data will be read
+ * @n_rx: size of rxbuf, in bytes (need not be dma-safe)
+ *
+ * This performs a half duplex MicroWire style transaction with the
+ * device, sending txbuf and then reading rxbuf.  The return value
+ * is zero for success, else a negative errno status code.
+ * This call may only be used from a context that may sleep.
+ *
+ * Parameters to this routine are always copied using a small buffer;
+ * performance-sensitive or bulk transfer code should instead use
+ * spi_{async,sync}() calls with dma-safe buffers.
+ */
+int spi_write_read_sync(struct spi_device *spi,
+		const u8 *txbuf, unsigned n_tx,
+		u8 *rxbuf, unsigned n_rx)
+{
+	static DECLARE_MUTEX(lock);
+
+	int			status;
+	struct spi_message	message;
+	struct spi_transfer	x;
+	u8			*local_buf;
+
+	/* Use preallocated DMA-safe buffer.  We can't avoid copying here,
+	 * (as a pure convenience thing), but we can keep heap costs
+	 * out of the hot path ...
+	 */
+	 while (!str8131_spi_bus_idle()){
+		printk("spi bus is not idle \n"); // do nothing
+	 	}
+	while (!str8131_spi_tx_buffer_empty()){
+		printk("spi tx buffer is not empty \n"); // do nothing
+		}
+	if ((n_tx + n_rx) > SPI_BUFSIZ)
+		return -EINVAL;
+	spi_message_init(&message);
+	memset(&x, 0, sizeof x);
+	x.len = n_tx;
+	spi_message_add_tail(&x, &message);
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	if (down_trylock(&lock)) {
+		local_buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
+		if (!local_buf)
+			return -ENOMEM;
+	} else
+		local_buf = buf;
+
+	memcpy(local_buf, txbuf, n_tx);
+	x.tx_buf = local_buf;
+	x.rx_buf = local_buf + n_tx;
+
+	/* do the i/o */
+	status = spi_sync(spi, &message);
+	if (status == 0) {
+		memcpy(rxbuf, x.rx_buf, n_rx);
+		status = message.status;
+	}
+
+	if (x.tx_buf == buf)
+		up(&lock);
+	else
+		kfree(local_buf);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_write_read_sync);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int __init spi_init(void)
diff -Nur linux-2.6.35.11/drivers/spi/spi_str8100.c linux-2.6.35.11-ts7500//drivers/spi/spi_str8100.c
--- linux-2.6.35.11/drivers/spi/spi_str8100.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/spi/spi_str8100.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,452 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/hardware.h>
+#include <asm/arch/star_intc.h>
+#include <asm/arch/star_spi.h>
+#include <asm/arch/star_misc.h>
+#include <asm/arch/star_powermgt.h>
+
+//#define STR8100_SPI_DEBUG
+
+struct str8100_spi {
+	/* bitbang has to be first */
+	struct spi_bitbang	 bitbang;
+	struct completion	 done;
+
+	int			 len;
+	int			 count;
+
+	/* data buffers */
+	const unsigned char	*tx;
+	unsigned char		*rx;
+
+	struct spi_master	*master;
+	struct device		*dev;
+	struct spi_device	*spi_dev[4];
+
+	int			board_count;
+	struct spi_board_info	board_info[4];
+};
+
+extern u32 APB_clock;
+
+static inline u8 str8100_spi_bus_idle(void)
+{
+	return ((SPI_SERVICE_STATUS_REG & 0x1) ? 0 : 1);
+}
+
+static inline u8 str8100_spi_tx_buffer_empty(void)
+{
+	return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 3)) ? 1 : 0);
+}
+
+static inline u8 str8100_spi_rx_buffer_full(void)
+{
+	return ((SPI_INTERRUPT_STATUS_REG & (0x1 << 2)) ? 1 : 0);
+}
+
+static u8 str8100_spi_tx_rx(u8 tx_channel, u8 tx_eof_flag, u32 tx_data, u32 *rx_data)
+{
+	u8 rx_channel;
+	u8 rx_eof_flag;
+
+	while (!str8100_spi_bus_idle())
+		; // do nothing
+
+	while (!str8100_spi_tx_buffer_empty())
+		; // do nothing
+
+	SPI_TRANSMIT_CONTROL_REG &= ~(0x7);
+	SPI_TRANSMIT_CONTROL_REG |= (tx_channel & 0x3) | ((tx_eof_flag & 0x1) << 2);
+
+	SPI_TRANSMIT_BUFFER_REG = tx_data;
+
+	while (!str8100_spi_rx_buffer_full())
+		; // do nothing
+
+	rx_channel = (SPI_RECEIVE_CONTROL_REG & 0x3);
+
+	rx_eof_flag = (SPI_RECEIVE_CONTROL_REG & (0x1 << 2)) ? 1 : 0;
+
+	*rx_data = SPI_RECEIVE_BUFFER_REG;
+
+	if ((tx_channel != rx_channel) || (tx_eof_flag != rx_eof_flag)) {
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+static inline struct str8100_spi *to_hw(struct spi_device *sdev)
+{
+	return spi_master_get_devdata(sdev->master);
+}
+
+static void str8100_spi_chipselect(struct spi_device *spi, int value)
+{
+	unsigned int spi_config;
+	int i;
+
+	switch (value) {
+	case BITBANG_CS_INACTIVE:
+		break;
+
+	case BITBANG_CS_ACTIVE:
+		spi_config = SPI_CONFIGURATION_REG;
+		if (spi->mode & SPI_CPHA)
+			spi_config |= (0x1 << 13);
+		else
+			spi_config &= ~(0x1 << 13);
+
+		if (spi->mode & SPI_CPOL)
+			spi_config |= (0x1 << 14);
+		else
+			spi_config &= ~(0x1 << 14);
+
+		/* write new configration */
+		SPI_CONFIGURATION_REG = spi_config;
+
+		SPI_TRANSMIT_CONTROL_REG &= ~(0x7);
+		SPI_TRANSMIT_CONTROL_REG |= (spi->chip_select & 0x3);
+
+		for (i = 0; i < 8; i++) {
+			if (spi->max_speed_hz > (APB_clock >> i))
+				break;
+		}
+#ifdef STR8100_SPI_DEBUG
+		printk("[STR8100_SPI_DEBUG] APB_clock:%u\n", APB_clock);
+		printk("[STR8100_SPI_DEBUG] spi->max_speed_hz:%u\n", spi->max_speed_hz);
+		printk("[STR8100_SPI_DEBUG] SPI bit rate control val:%d\n", i);
+#endif
+		SPI_BIT_RATE_CONTROL_REG = i;
+
+		break;
+	}
+}
+
+static int str8100_spi_setup(struct spi_device *spi)
+{
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	return 0;
+}
+
+static int str8100_spi_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct str8100_spi *hw = to_hw(spi);
+	int error = 0;
+
+	hw->tx = t->tx_buf;
+	hw->rx = t->rx_buf;
+	hw->len = t->len;
+	hw->count = 0;
+
+#ifdef STR8100_SPI_DEBUG
+	printk("[STR8100_SPI_DEBUG] txrx: tx %p, rx %p, len %d\n", t->tx_buf, t->rx_buf, t->len);
+	if (hw->tx) {
+		int i;
+		for (i = 0; i < t->len; i++) {
+			printk("[STR8100_SPI_DEBUG] t->tx_buf[%02d]: 0x%02x\n", i, hw->tx[i]);
+		}
+	}
+#endif
+	if (hw->tx) {
+		int i;
+		u32 rx_data;
+		for (i = 0; i < (hw->len - 1); i++) {
+			str8100_spi_tx_rx(spi->chip_select, 0, hw->tx[i], &rx_data);
+			if (hw->rx) {
+				hw->rx[i] = rx_data;
+#ifdef STR8100_SPI_DEBUG
+				printk("[STR8100_SPI_DEBUG] hw->rx[%02d]:0x%02x\n", i, hw->rx[i]);
+#endif
+			}
+		}
+		if (t->last_in_message_list) {
+			str8100_spi_tx_rx(spi->chip_select, 1, hw->tx[i], &rx_data);
+			if (hw->rx) {
+				hw->rx[i] = rx_data;
+#ifdef STR8100_SPI_DEBUG
+				printk("[STR8100_SPI_DEBUG] hw->rx[%02d]:0x%02x\n", i, hw->rx[i]);
+#endif
+			}
+		} else {
+			str8100_spi_tx_rx(spi->chip_select, 0, hw->tx[i], &rx_data);
+		}
+		goto done;
+	}
+
+	if (hw->rx) {
+		int i;
+		u32 rx_data;
+		for (i = 0; i < (hw->len - 1); i++) {
+			str8100_spi_tx_rx(spi->chip_select, 0, 0xff, &rx_data);
+			hw->rx[i] = rx_data;
+#ifdef STR8100_SPI_DEBUG
+			printk("[STR8100_SPI_DEBUG] hw->rx[%02d]:0x%02x\n", i, hw->rx[i]);
+#endif
+		}
+		if (t->last_in_message_list) {
+			str8100_spi_tx_rx(spi->chip_select, 1, 0xff, &rx_data);
+			hw->rx[i] = rx_data;
+#ifdef STR8100_SPI_DEBUG
+			printk("[STR8100_SPI_DEBUG] hw->rx[%02d]:0x%02x\n", i, hw->rx[i]);
+#endif
+		} else {
+			str8100_spi_tx_rx(spi->chip_select, 0, 0xff, &rx_data);
+			hw->rx[i] = rx_data;
+#ifdef STR8100_SPI_DEBUG
+			printk("[STR8100_SPI_DEBUG] hw->rx[%02d]:0x%02x\n", i, hw->rx[i]);
+#endif
+		}
+	}
+
+done:
+	return t->len;
+}
+
+static int __init str8100_spi_probe(struct platform_device *pdev)
+{
+	struct str8100_spi *hw;
+	struct spi_master *master;
+	unsigned int receive_data;
+	int err = 0;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct str8100_spi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "No memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_nomem;
+	}
+
+	master->bus_num = 1;
+	master->num_chipselect = 4;
+
+	hw = spi_master_get_devdata(master);
+	memset(hw, 0, sizeof(struct str8100_spi));
+
+	hw->master = spi_master_get(master);
+
+	hw->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, hw);
+	init_completion(&hw->done);
+
+	/* scott.patch.spi */
+	// Clear spurious interrupt sources
+	SPI_INTERRUPT_STATUS_REG = (0xF << 4);
+
+	// Disable SPI interrupt
+	SPI_INTERRUPT_ENABLE_REG = 0;
+
+	// Enable SPI
+	SPI_CONFIGURATION_REG |= (0x1 << 31);
+
+	/* setup the state for the bitbang driver */
+
+	hw->bitbang.master         = hw->master;
+	hw->bitbang.chipselect     = str8100_spi_chipselect;
+	hw->bitbang.txrx_bufs      = str8100_spi_txrx;
+	hw->bitbang.master->setup  = str8100_spi_setup;
+
+	dev_dbg(hw->dev, "bitbang at %p\n", &hw->bitbang);
+
+	/* register our spi controller */
+
+	err = spi_bitbang_start(&hw->bitbang);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register SPI master\n");
+		goto err_register;
+	}
+
+#ifdef STR8100_SPI_DEBUG
+{
+	int i;
+	u32 rx_data1, rx_data2, rx_data3;
+
+	str8100_spi_tx_rx(0, 0, 0x9f, &rx_data1);
+	str8100_spi_tx_rx(0, 0, 0xff, &rx_data1);
+	str8100_spi_tx_rx(0, 0, 0xff, &rx_data2);
+	str8100_spi_tx_rx(0, 1, 0xff, &rx_data3);
+	printk("[STR8100_SPI_DEBUG] manufacturer: %x\n", rx_data1);
+	printk("[STR8100_SPI_DEBUG] device:       %x\n", ((rx_data2 & 0xff) << 8) | (u16) (rx_data3 & 0xff));
+
+	str8100_spi_tx_rx(0, 0, 0x03, &rx_data1);
+	str8100_spi_tx_rx(0, 0, 0x00, &rx_data1);
+	str8100_spi_tx_rx(0, 0, 0x00, &rx_data1);
+	str8100_spi_tx_rx(0, 0, 0x00, &rx_data1);
+	for (i = 0; i < 15; i++) {
+		str8100_spi_tx_rx(0, 0, 0xff, &rx_data1);
+		printk("[STR8100_SPI_DEBUG] flash[%02d]:0x%02x\n", i, rx_data1 & 0xff);
+	}
+	str8100_spi_tx_rx(0, 1, 0xff, &rx_data1);
+	printk("[STR8100_SPI_DEBUG] flash[%02d]:0x%02x\n", i, rx_data1 & 0xff);
+}
+#endif
+
+	return 0;
+
+err_register:
+	spi_master_put(hw->master);;
+
+err_nomem:
+	return err;
+}
+
+static int str8100_spi_remove(struct platform_device *dev)
+{
+	struct str8100_spi *hw = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	spi_unregister_master(hw->master);
+
+	//str8100_spi_clk_disable();
+
+	spi_master_put(hw->master);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+static int str8100_spi_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct str8100_spi *hw = platform_get_drvdata(pdev);
+
+	//str8100_spi_clk_disable();
+	return 0;
+}
+
+static int str8100_spi_resume(struct platform_device *pdev)
+{
+	struct str8100_spi *hw = platform_get_drvdata(pdev);
+
+	//str8100_spi_clk_enable()
+	return 0;
+}
+
+#else
+#define str8100_spi_suspend	NULL
+#define str8100_spi_resume	NULL
+#endif
+
+static void __init str8100_spi_hw_init(void)
+{
+	u32 receive_data;
+
+	// Enable SPI pins
+	HAL_MISC_ENABLE_SPI_PINS();
+
+	// Enable SPI clock
+	HAL_PWRMGT_ENABLE_SPI_CLOCK();
+
+	// Disable SPI serial flash access through 0x30000000 region
+	HAL_MISC_DISABLE_SPI_SERIAL_FLASH_BANK_ACCESS();
+
+	/*
+	 * Note SPI is NOT enabled after this function is invoked!!
+	 */
+	SPI_CONFIGURATION_REG =
+		(((0x0 & 0x3) << 0) | /* 8bits shift length */
+		 (0x0 << 9) | /* general SPI mode */
+		 (0x0 << 10) | /* disable FIFO */
+		 (0x1 << 11) | /* SPI master mode */
+		 (0x0 << 12) | /* disable SPI loopback mode */
+		 (0x0 << 13) | /* clock phase */
+		 (0x0 << 14) | /* clock polarity */
+		 (0x0 << 24) | /* disable SPI Data Swap */
+		 (0x0 << 30) | /* disable SPI High Speed Read for BootUp */
+		 (0x0 << 31)); /* disable SPI */
+
+	SPI_BIT_RATE_CONTROL_REG = 0x1; // PCLK/2
+
+	// Configure SPI's Tx channel
+	SPI_TRANSMIT_CONTROL_REG = 0;
+
+	// Configure Tx FIFO Threshold
+	SPI_FIFO_TRANSMIT_CONFIG_REG &= ~(0x03 << 4);
+	SPI_FIFO_TRANSMIT_CONFIG_REG |= ((0x0 & 0x03) << 4);
+
+	// Configure Rx FIFO Threshold
+	SPI_FIFO_RECEIVE_CONFIG_REG &= ~(0x03 << 4);
+	SPI_FIFO_RECEIVE_CONFIG_REG |= ((0x0 & 0x03) << 4);
+
+	SPI_INTERRUPT_ENABLE_REG = 0;
+
+	// Clear spurious interrupt sources
+	SPI_INTERRUPT_STATUS_REG = (0xF << 4);
+
+	receive_data = SPI_RECEIVE_BUFFER_REG;
+
+	return;
+}
+
+static struct platform_driver str8100_spidrv = {
+	.remove		= __devexit_p(str8100_spi_remove),
+	.suspend	= str8100_spi_suspend,
+	.resume		= str8100_spi_resume,
+	.driver		= {
+		.name	= "str8100_spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init str8100_spi_init(void)
+{
+	printk("STR8100 SPI: init\n");
+	str8100_spi_hw_init();
+
+	return platform_driver_probe(&str8100_spidrv, str8100_spi_probe);
+}
+
+static void __exit str8100_spi_exit(void)
+{
+	platform_driver_unregister(&str8100_spidrv);
+}
+
+module_init(str8100_spi_init);
+module_exit(str8100_spi_exit);
+
+MODULE_DESCRIPTION("STR8100 SPI Driver");
+MODULE_AUTHOR("STAR Semi Corp.");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.11/drivers/star/Makefile linux-2.6.35.11-ts7500//drivers/star/Makefile
--- linux-2.6.35.11/drivers/star/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,30 @@
+################################################################################
+#
+# 
+# Copyright(c) 2005 -  Star semiconduction. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+obj-$(CONFIG_ARCH_STR9100) += str9100/
+obj-$(CONFIG_ARCH_STR8100) += str8100/
+
diff -Nur linux-2.6.35.11/drivers/star/str8100/crash.c linux-2.6.35.11-ts7500//drivers/star/str8100/crash.c
--- linux-2.6.35.11/drivers/star/str8100/crash.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/crash.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,85 @@
+/*======================================================================
+
+   Copyright (C) 2006 STAR Semiconductor Limited
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+ 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+
+#include <asm/arch/star_gpio.h>
+#include <asm/arch/star_intc.h>
+#include <asm/arch/star_misc.h>
+#include <asm/arch/star_powermgt.h>
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+static int mode=0;
+module_param(mode, int, 0);
+MODULE_PARM_DESC(mode, "");
+static irqreturn_t str8100_ext_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	void (*fnptr)(void)=NULL;
+	printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+
+	if(mode==1) while(1);
+	else fnptr();
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+static int __init str8100_inthandler_init(void)
+{
+	int ret;
+printk("%s: \n",__FUNCTION__);
+	if(mode==0) panic("%s: panic for testing...\n",__FUNCTION__);
+
+#define register_ext_int(_i){\
+			printk("%s: registering int handler for external int%d\n",__FUNCTION__,_i);\
+			HAL_MISC_ENABLE_EXT_INT##_i##_PINS();\
+			str8100_set_interrupt_trigger (INTC_EXT_INT##_i##_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);\
+			if ((ret=request_irq(INTC_EXT_INT##_i##_BIT_INDEX, str8100_ext_irq_handler, 0, "testing", NULL))){\
+				printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_EXT_INT##_i##_BIT_INDEX,ret,-EBUSY);\
+				return -EBUSY;\
+			}\
+		}
+	register_ext_int(29);
+	register_ext_int(30);
+	return 0;
+}
+
+static void __exit str8100_inthandler_exit(void) 
+{ 
+//#ifdef DEBUG
+		printk("%s: \n",__FUNCTION__);
+//#endif
+    lock_kernel();
+    free_irq(INTC_EXT_INT29_BIT_INDEX, NULL);
+    free_irq(INTC_EXT_INT30_BIT_INDEX, NULL);
+    unlock_kernel();
+}
+
+module_init(str8100_inthandler_init);
+module_exit(str8100_inthandler_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str8100/int28handler.c linux-2.6.35.11-ts7500//drivers/star/str8100/int28handler.c
--- linux-2.6.35.11/drivers/star/str8100/int28handler.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/int28handler.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,80 @@
+/*======================================================================
+
+   Copyright (C) 2006 STAR Semiconductor Limited
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+ 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+
+#include <asm/arch/star_gpio.h>
+#include <asm/arch/star_intc.h>
+#include <asm/arch/star_misc.h>
+#include <asm/arch/star_powermgt.h>
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+static struct work_struct reboot_work;
+void do_reboot(){
+	char* argv[2];
+	char* env[1];
+	argv[0]="/sbin/reboot";
+	argv[1]=NULL;
+	env[0]=NULL;
+	call_usermodehelper(argv[0],argv,env,0);
+
+}
+static irqreturn_t str8100_int28vbus_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+printk("%s: registering work\n",__FUNCTION__);
+	INIT_WORK(&reboot_work,do_reboot,NULL);
+	if(PWRMGT_USB_DEVICE_POWERMGT_REG&0x1)
+		schedule_work(&reboot_work);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	return IRQ_HANDLED;
+}
+
+static int __init str8100_int28vbus_inthandler_init(void)
+{
+	int ret;
+printk("%s: \n",__FUNCTION__);
+	if(PWRMGT_USB_DEVICE_POWERMGT_REG&0x1)
+		HAL_PWRMGT_GLOBAL_SOFTWARE_RESET();
+	//	schedule_work(&reboot_work);
+
+	//str8100_set_interrupt_trigger (INTC_GPIO_EXTERNAL_INT_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_USB_DEVICE_VBUS_BIT_INDEX, str8100_int28vbus_irq_handler, 0, "vbus", NULL))){
+		printk("%s: request_irq failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,ret,-EBUSY);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static void __exit str8100_int28vbus_inthandler_exit(void) 
+{ 
+	printk("%s: \n",__FUNCTION__);
+	lock_kernel();
+	free_irq(INTC_USB_DEVICE_VBUS_BIT_INDEX, NULL);
+	unlock_kernel();
+}
+
+module_init(str8100_int28vbus_inthandler_init);
+module_exit(str8100_int28vbus_inthandler_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str8100/inthandler.c linux-2.6.35.11-ts7500//drivers/star/str8100/inthandler.c
--- linux-2.6.35.11/drivers/star/str8100/inthandler.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/inthandler.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,178 @@
+/*======================================================================
+
+   Copyright (C) 2006 STAR Semiconductor Limited
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+ 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+
+#include <asm/arch/star_gpio.h>
+#include <asm/arch/star_intc.h>
+#include <asm/arch/star_misc.h>
+#include <asm/arch/star_powermgt.h>
+
+static int gpio=0;
+module_param(gpio, int, 0);
+MODULE_PARM_DESC(gpio, "GPIO int switch(0: disable, 1:enable default=0)");
+
+static int ext29=0;
+module_param(ext29, int, 0);
+MODULE_PARM_DESC(ext29, "Ext int 29 switch(0: disable, 1:enable default=0)");
+
+static int ext30=0;
+module_param(ext30, int, 0);
+MODULE_PARM_DESC(ext30, "Ext int 30 switch(0: disable, 1:enable default=0)");
+
+static int debug=1;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "debug mode (1=on, 0=off, default=1");
+
+static irqreturn_t (*gpioA_irq_handler)(int, void*, struct pt_regs*)=NULL;
+static irqreturn_t (*gpioB_irq_handler)(int, void*, struct pt_regs*)=NULL;
+static irqreturn_t (*ext_irq_handler)(int, void*, struct pt_regs*)=NULL;
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int);
+
+static irqreturn_t str8100_ext_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	if(debug) printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(this_irq);
+	if(ext_irq_handler){
+		ext_irq_handler(this_irq,dev_id,regs);
+	}
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(this_irq);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(this_irq);
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t str8100_gpio_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int volatile    statusA,statusB;
+	int i;
+
+	if(debug) printk("%s: this_irq=%d\n",__FUNCTION__,this_irq);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	HAL_GPIOA_READ_INTERRUPT_MASKED_STATUS(statusA);
+	HAL_GPIOB_READ_INTERRUPT_MASKED_STATUS(statusB);
+//printk("%s: %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x \n",__FUNCTION__,GPIOA_DATA_OUTPUT_REG,GPIOA_DATA_INPUT_REG,GPIOA_DIRECTION_REG,GPIOA_INTERRUPT_ENABLE_REG,GPIOA_INTERRUPT_RAW_STATUS_REG,GPIOA_INTERRUPT_MASKED_STATUS_REG,GPIOA_INTERRUPT_MASKED_STATUS_REG,GPIOA_INTERRUPT_MASK_REG,GPIOA_INTERRUPT_TRIGGER_METHOD_REG,GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG,GPIOA_INTERRUPT_TRIGGER_TYPE_REG,GPIOA_BOUNCE_ENABLE_REG,GPIOA_BOUNCE_CLOCK_PRESCALE_REG);
+	for (i = 0; i < 32; i++)
+	{
+		if (statusA & (1 << i)){
+       			if(debug) printk("%s: GPIOA Int %d\n",__FUNCTION__,i);
+       			if(gpioA_irq_handler){
+       				gpioA_irq_handler(i,dev_id,regs);
+       			}
+		}	 
+		if (statusB & (1 << i)){
+       			if(debug) printk("%s: GPIOB Int %d\n",__FUNCTION__,i);
+       			if(gpioB_irq_handler){
+       				gpioB_irq_handler(i,dev_id,regs);
+       			}
+		}	 
+	}
+	HAL_GPIOA_CLEAR_INTERRUPT(statusA);
+	HAL_GPIOB_CLEAR_INTERRUPT(statusB);
+
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+    return IRQ_HANDLED;
+}
+
+static int __init str8100_inthandler_init(void)
+{
+	int ret;
+if(debug) printk("%s: \n",__FUNCTION__);
+
+#if 0
+    /*
+     * Configure system Xtal clock to be output to CLKOUT pin
+     */
+    HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(0, 0);
+#endif
+
+//	HAL_MISC_ENABLE_ALL_SHARED_GPIO_PINS();	
+	if(gpio){
+		if(debug) printk("%s: registering int handler for gpio int\n",__FUNCTION__);\
+//gpio initialization depend on application
+#if 0
+		HAL_MISC_DISABLE_EXT_INT29_PINS();
+		HAL_MISC_DISABLE_EXT_INT30_PINS();
+
+		HAL_PWRMGT_ENABLE_GPIO_CLOCK();
+
+		PWRMGT_SOFTWARE_RESET_CONTROL_REG |=  (0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);
+		PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);
+		PWRMGT_SOFTWARE_RESET_CONTROL_REG |=  (0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);	
+
+		HAL_GPIOA_SET_DIRECTION_INPUT(3);
+		HAL_GPIOA_ENABLE_INTERRUPT(3);
+		HAL_GPIOA_DISABLE_INTERRUPT_MASK(3);
+		HAL_GPIOA_SET_INTERRUPT_EDGE_TRIGGER_MODE(3);
+#endif
+
+		str8100_set_interrupt_trigger (INTC_GPIO_EXTERNAL_INT_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+		if ((ret=request_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, str8100_gpio_irq_handler, 0, "testing", NULL))){
+			if(debug) printk("%s: request_irq failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,ret,-EBUSY);
+			return -EBUSY;
+		}
+	}
+#define register_ext_int(_i){\
+			if(debug) printk("%s: registering int handler for external int%d\n",__FUNCTION__,_i);\
+			HAL_MISC_ENABLE_EXT_INT##_i##_PINS();\
+			str8100_set_interrupt_trigger (INTC_EXT_INT##_i##_BIT_INDEX,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);\
+			if ((ret=request_irq(INTC_EXT_INT##_i##_BIT_INDEX, str8100_ext_irq_handler, 0, "testing", NULL))){\
+				if(debug) printk("%s: request_irq %d failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,INTC_EXT_INT##_i##_BIT_INDEX,ret,-EBUSY);\
+				return -EBUSY;\
+			}\
+		}
+	if(ext29) register_ext_int(29);
+	if(ext30) register_ext_int(30);
+
+/*	HAL_MISC_ENABLE_EXT_INT30_PINS();
+	str8100_set_interrupt_trigger (INTC_EXT_INT30_BIT_INDEX,INTC_IRQ_INTERRUPT,INTC_LEVEL_TRIGGER,INTC_ACTIVE_LOW);
+	if ((ret=request_irq(INTC_EXT_INT30_BIT_INDEX, str8100_pm_irq_handler, 0, "testing", NULL))){
+		printk("%s: request_irq failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,ret,-EBUSY);
+		return -EBUSY;
+	}
+*/
+	return 0;
+}
+
+static void __exit str8100_inthandler_exit(void) 
+{ 
+//#ifdef DEBUG
+		if(debug) printk("%s: \n",__FUNCTION__);
+//#endif
+    lock_kernel();
+    if(gpio) free_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, NULL);
+    if(ext29) free_irq(INTC_EXT_INT29_BIT_INDEX, NULL);
+    if(ext30) free_irq(INTC_EXT_INT30_BIT_INDEX, NULL);
+    unlock_kernel();
+}
+
+module_init(str8100_inthandler_init);
+module_exit(str8100_inthandler_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str8100/Makefile linux-2.6.35.11-ts7500//drivers/star/str8100/Makefile
--- linux-2.6.35.11/drivers/star/str8100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,33 @@
+################################################################################
+#
+# 
+# Copyright(c) 2005 -  Star semiconduction. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+#obj-y += str8100_tool.o
+#obj-$(CONFIG_STR8100_INFO) += str8100_info.o
+
+obj-$(CONFIG_STR8100_USBD_REBOOT_INTHANDLER) += int28handler.o
+obj-m += inthandler.o
+obj-m += crash.o
diff -Nur linux-2.6.35.11/drivers/star/str8100/str8100_gpio_test.c linux-2.6.35.11-ts7500//drivers/star/str8100/str8100_gpio_test.c
--- linux-2.6.35.11/drivers/star/str8100/str8100_gpio_test.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/str8100_gpio_test.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,140 @@
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/arch/star_powermgt.h>
+#include <asm/arch/star_intc.h>
+#include <asm/arch/star_misc.h>
+#include <asm/arch/star_gpio.h>
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+extern void str8100_led_all_on(void);
+extern void str8100_led_all_off(void);
+extern void str8100_led_on(unsigned int led_index);
+extern void str8100_led_off(unsigned int led_index);
+extern void str8100_led_toggle(unsigned int led_index);
+extern void str8100_led_init(void);
+
+extern void str8100_set_interrupt_trigger(unsigned int, unsigned int, unsigned int, unsigned int);
+
+static irqreturn_t str8100_gpio_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int volatile    status;
+	int i;
+
+	printk("%s: \n",__FUNCTION__);
+
+	HAL_INTC_DISABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	HAL_GPIOA_READ_INTERRUPT_MASKED_STATUS(status);
+
+//printk("%s: %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x \n", \
+//	__FUNCTION__, \
+//	GPIOA_DATA_OUTPUT_REG, \
+//	GPIOA_DATA_INPUT_REG, \
+//	GPIOA_DIRECTION_REG, \
+//	GPIOA_INTERRUPT_ENABLE_REG, \
+//	GPIOA_INTERRUPT_RAW_STATUS_REG, \
+//	GPIOA_INTERRUPT_MASKED_STATUS_REG, \
+//	GPIOA_INTERRUPT_MASKED_STATUS_REG, \
+//	GPIOA_INTERRUPT_MASK_REG, \
+//	GPIOA_INTERRUPT_TRIGGER_METHOD_REG, \
+//	GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG, \
+//	GPIOA_INTERRUPT_TRIGGER_TYPE_REG, \
+//	GPIOA_BOUNCE_ENABLE_REG, \
+//	GPIOA_BOUNCE_CLOCK_PRESCALE_REG);
+
+	for (i = 0; i < 32; i++) {
+		if (status & (1 << i)) {
+			printk(" str8100 gpio: Interrupt Happen (status: 0x%x, GPIO %.2d)\n",status,i);
+			//GPIOA[0] will toggle GPIOB[2]
+			//GPIOA[1] will toggle GPIOB[3]
+			str8100_led_toggle(1<<(i+2));
+		}	 
+	}
+
+	HAL_GPIOA_CLEAR_INTERRUPT(status);
+	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+	HAL_INTC_ENABLE_INTERRUPT_SOURCE(INTC_GPIO_EXTERNAL_INT_BIT_INDEX);
+
+	return IRQ_HANDLED;
+}
+
+static int __init test_init(void){
+	int ret;
+//	__u32 data,cnt=0;
+
+	printk("%s: Output led test...\n",__FUNCTION__);
+
+	
+	HAL_MISC_ENABLE_ALL_SHARED_GPIO_PINS();	
+	HAL_PWRMGT_ENABLE_GPIO_CLOCK();
+
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |=  (0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |=  (0x1 << PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX);	
+
+	str8100_led_init();
+
+/*
+	printk("%s: Input button test...\n",__FUNCTION__);
+	HAL_GPIOA_SET_DIRECTION_INPUT(3);
+	while(cnt<20){
+		HAL_GPIOA_READ_DATA_IN_STATUS(data);
+		printk("%d-%s: read data=0x%x\n",cnt,__FUNCTION__,data);
+		msleep(500);
+		cnt++;
+	}
+*/
+
+	printk("%s: IRQ test...\n",__FUNCTION__);
+	//Configure GPIOA[0:1] as interrupts
+	HAL_GPIOA_SET_DIRECTION_INPUT(3);
+	HAL_GPIOA_ENABLE_INTERRUPT(3);
+	HAL_GPIOA_DISABLE_INTERRUPT_MASK(3);
+
+	//GPIOA[0] will toggle GPIOB[2] (in interrupt handler)
+	//set GPIOA[0] to level trigger
+	//==> GPIOB[2] will keep blinking while button pressed
+	HAL_GPIOA_SET_INTERRUPT_LEVEL_TRIGGER_MODE(1);
+	HAL_GPIOA_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(1);
+//	HAL_GPIOA_SET_INTERRUPT_SINGLE_EDGE_TRIGGER_MODE(1);
+//	HAL_GPIOA_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(1);
+//	HAL_GPIOA_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(1);
+
+	//GPIOA[1] will toggle GPIOB[3] (in interrupt handler)
+	//set GPIOA[1] to edge trigger
+	//==> GPIOB[3] will turn on while pressed
+	HAL_GPIOA_SET_INTERRUPT_EDGE_TRIGGER_MODE(2);
+	HAL_GPIOA_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(2);
+
+	str8100_set_interrupt_trigger (INTC_GPIO_EXTERNAL_INT_BIT_INDEX,INTC_IRQ_INTERRUPT,INTC_LEVEL_TRIGGER,INTC_ACTIVE_HIGH);
+	if ((ret=request_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX, str8100_gpio_irq_handler, 0, "testing", NULL))){
+		printk("%s: request_irq failed(ret=0x%x)(-EBUSY=0x%x)\n",__FUNCTION__,ret,-EBUSY);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static void __exit test_exit(void){
+	printk("%s: \n",__FUNCTION__);
+	free_irq(INTC_GPIO_EXTERNAL_INT_BIT_INDEX,NULL);
+}
+
+module_init(test_init);
+module_exit(test_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str8100/str8100_led.c linux-2.6.35.11-ts7500//drivers/star/str8100/str8100_led.c
--- linux-2.6.35.11/drivers/star/str8100/str8100_led.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str8100/str8100_led.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,158 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <asm/arch/star_gpio.h>
+
+#define LED_MASK_A 			0xfe3fe07f
+#define LED_MASK_B 			0xffe0dfff
+
+#if 0
+#define LED_MASK 					LED_MASK_A
+#define GPIO_DIRECTION_REG			GPIOA_DIRECTION_REG
+#define GPIO_DATA_OUTPUT_REG 		GPIOA_DATA_OUTPUT_REG
+#define GPIO_DATA_BIT_SET_REG 		GPIOA_DATA_BIT_SET_REG
+#define GPIO_DATA_BIT_CLEAR_REG 	GPIOA_DATA_BIT_CLEAR_REG
+#else
+#define LED_MASK 					LED_MASK_B
+#define GPIO_DIRECTION_REG			GPIOB_DIRECTION_REG
+#define GPIO_DATA_OUTPUT_REG 		GPIOB_DATA_OUTPUT_REG
+#define GPIO_DATA_BIT_SET_REG 		GPIOB_DATA_BIT_SET_REG
+#define GPIO_DATA_BIT_CLEAR_REG 	GPIOB_DATA_BIT_CLEAR_REG
+#endif
+
+
+#define LED_DELAY_MS		50
+
+/*
+ * Configure all LEDs on
+ */
+void str8100_led_all_on(void)
+{
+    /*
+     * perform Write Low to GPIO Pin
+     */    
+    GPIO_DATA_BIT_CLEAR_REG |= LED_MASK;
+}
+
+
+
+/*
+ * Configure all LEDs off
+ */
+void str8100_led_all_off(void)
+{
+    /*
+     * perform Write High to GPIO Pin
+     */
+    GPIO_DATA_BIT_SET_REG |= LED_MASK;
+}
+
+
+/*
+ * Configure one LED on
+ */
+void str8100_led_on(unsigned int led_index)
+{
+    /*
+     * perform Write Low to GPIO Pin
+     */
+    GPIO_DATA_BIT_CLEAR_REG |= (led_index & LED_MASK);
+}
+
+
+/*
+ * Configure one LED off
+ */
+void str8100_led_off(unsigned int led_index)
+{
+    /*
+     * perform Write High to GPIO Pin
+     */
+    GPIO_DATA_BIT_SET_REG |= (led_index & LED_MASK);
+}
+
+
+
+/*
+ * Toggle one LED on/off
+ */
+void str8100_led_toggle(unsigned int led_index)
+{     
+    volatile unsigned int    data_out_state;
+
+
+    /*
+     * 1. read GPIO Data Out State
+     * 2. if GPIO High, turn LED on, otherwise, turn LED off
+     */
+    data_out_state = GPIO_DATA_OUTPUT_REG;
+    
+    if (data_out_state & led_index& LED_MASK)
+    {
+        // GPIO High, i.e., LED is off. Now, turn it on
+        str8100_led_on(led_index & LED_MASK);
+    }
+    else
+    {
+        // GPIO Low, i.e., LED is on. Now turn it off
+        str8100_led_off(led_index & LED_MASK);
+    }
+}
+
+
+/*
+ * Initilaize LED settings
+ */
+void str8100_led_init(void)
+{
+    volatile unsigned int    ii;
+
+
+    /*
+     * Configure all GPIO pins as follows:
+     * 1. output pins
+     * 2. turn all leds off
+     * 3. sequentially turn all leds on and all leds off     
+     *    then, we can set GPIO Low to turn LED On, and GPIO High to turn LED Off 
+     */
+	printk("%s: \n",__FUNCTION__);
+
+	GPIO_DIRECTION_REG |= LED_MASK;
+    
+    str8100_led_all_off();
+    
+    for (ii = 0; ii < 32; ii++)
+    {
+    	if(1<<ii&LED_MASK){
+//printk("%s: ii=%d\n",__FUNCTION__,ii);
+        	str8100_led_on(1 << ii);
+        	msleep(LED_DELAY_MS);
+        	str8100_led_off(1 << ii);
+//        	msleep(LED_DELAY_MS);
+
+        }
+    }
+}
+
diff -Nur linux-2.6.35.11/drivers/star/str9100/Makefile linux-2.6.35.11-ts7500//drivers/star/str9100/Makefile
--- linux-2.6.35.11/drivers/star/str9100/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/Makefile	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,32 @@
+################################################################################
+#
+# 
+# Copyright(c) 2005 -  Star semiconduction. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Star semiconduction Linux Support <support@starsemi.com>
+#
+################################################################################
+
+obj-y += str9100_tool.o
+
+obj-$(CONFIG_STR9100_INFO) += str9100_info.o
+obj-$(CONFIG_STR9100_SHNAT) += str9100_shnat_hook.o
+
diff -Nur linux-2.6.35.11/drivers/star/str9100/str9100_info.c linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_info.c
--- linux-2.6.35.11/drivers/star/str9100/str9100_info.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_info.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,755 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,32)
+#define LINUX24 1
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26 1
+#endif
+
+#include <linux/stddef.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+#include <asm/arch/hardware.h>
+#include <linux/kdev_t.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include "../../net/str9100/star_gsw.h"
+
+#ifdef LINUX24
+#include <asm/arch/str9100_info.h>
+#include <asm/arch/str9100/star_tool.h>
+#include <asm/arch/str9100/star_gsw.h>
+#endif
+
+#ifdef LINUX26
+#include <linux/str9100/str9100_tool.h>
+#include <linux/str9100/str9100_info.h>
+#endif
+
+
+
+
+
+
+
+
+static const char *cpu_str[]={
+"175",
+"200",
+"225",
+"250"};
+
+static const char *v18_str[] = {
+"1.537",
+"1.594",
+"1.655",
+"1.721",
+"1.793",
+"1.871",
+"1.956",
+"2.049"};
+
+static const char *pciclk_str[] = {
+"33",
+"66",
+"-"};
+
+static const char *dram_str[] = {
+"16",
+"32",
+"64",
+"-"};
+
+#ifdef LINUX24
+struct proc_dir_entry *str9100_info_proc;
+#endif
+
+
+typedef struct STR9100_INFO_{
+	u32 cpu;
+	u32 v18regular;
+	u32 pciclk;
+	u32 dram;
+}STR9100_INFO;
+
+static STR9100_INFO str9100_info;
+
+#ifdef LINUX26
+static struct proc_dir_entry *str9100_info_proc_entry;
+#endif
+
+
+#ifdef LINUX24
+int get_system_info(void){
+	u32 volatile temp;
+	temp = (((*(u32 volatile *)(IO_ADDRESS(0x77000014))) >> 6) & 0x3);
+	str9100_info.cpu = temp;
+
+	temp = (*(u32 volatile *)(IO_ADDRESS(0x77000018)));
+	temp = ((temp >> 11)&0x7);
+	str9100_info.v18regular = temp;
+
+#if defined(CONFIG_STAR9100_PCI66M)
+	str9100_info.pciclk = 1;
+#elif defined(CONFIG_STAR9100_PCI33M)
+	str9100_info.pciclk = 0;
+#elif 
+	str9100_info.pciclk = 2;
+#endif
+
+#if defined(CONFIG_STR9100_DRAM_64M)
+	str9100_info.dram = 2;
+#elif defined(CONFIG_STR9100_DRAM_32M)
+	str9100_info.dram = 1;
+#elif defined(CONFIG_STR9100_DRAM_16M)
+	str9100_info.dram = 0;
+#else
+	str9100_info.dram = 3;
+#endif
+
+
+	return 0;
+}
+#endif
+
+#ifdef LINUX26
+static int get_system_info(void)
+{
+	u32 temp;
+	temp = (PWRMGT_RESET_LATCH_CONFIGURATION_REG >> 6) & 0x3;
+	str9100_info.cpu = temp;
+
+	temp = (PWRMGT_REGULATOR_CONTROL_REG >> 11) & 0x7;
+	temp = ((temp >> 11)&0x7);
+	str9100_info.v18regular = temp;
+
+#if defined(CONFIG_STR9100_PCI66M)
+	str9100_info.pciclk = 1;
+#elif defined(CONFIG_STR9100_PCI33M)
+	str9100_info.pciclk = 0;
+#else
+	str9100_info.pciclk = 2;
+#endif
+
+#if defined(CONFIG_STR9100_DRAM_64M)
+	str9100_info.dram = 2;
+#elif defined(CONFIG_STR9100_DRAM_32M)
+	str9100_info.dram = 1;
+#elif defined(CONFIG_STR9100_DRAM_16M)
+	str9100_info.dram = 0;
+#else
+	str9100_info.dram = 3;
+#endif
+
+	return 0;
+}
+#endif
+
+
+#ifdef LINUX24
+static int str9100_info_read_proc(char *page, char **start,  off_t off, int count, int *eof, void *data){
+	int num = 0;
+
+        volatile unsigned long remap = (unsigned long)ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+        volatile u16 *addr = (u16 *)(remap + 0);
+
+	// for human readable
+	num += sprintf(page+num, "--- CPU \n");
+	num += sprintf(page+num, "CPU Clock: Str9100 %sMhz\n",cpu_str[str9100_info.cpu]);
+	num += sprintf(page+num, "1.8V Regulator Regulated vdd Output : %sv \n",v18_str[str9100_info.v18regular]);
+	num += sprintf(page+num, "--- Device \n");
+	num += sprintf(page+num, "PCI Clock: %sMhz\n",pciclk_str[str9100_info.pciclk]);
+	num += sprintf(page+num, "--- Memory \n");
+	num += sprintf(page+num, "DRAM Size: %sMBytes\n",dram_str[str9100_info.dram]);
+#ifdef CONFIG_CPU_ISCRATCHPAD_ENABLE
+	num += sprintf(page+num, "enable I-Scratchpad\n");
+#else
+	num += sprintf(page+num, "disable I-Scratchpad\n");
+#endif
+	num += sprintf(page+num, "flash type: %s\n", get_flash_type(addr) );
+
+
+        iounmap(remap);
+		
+	return num;
+}
+#endif
+
+#ifdef LINUX26
+static int str9100_info_read_proc(char *page, char **start,  off_t off, int count, int *eof, void *data)
+{
+	int num = 0;
+
+	// for human readable
+	num += sprintf(page+num, "--- CPU \n");
+	num += sprintf(page+num, "CPU Clock: STR9100 %sMhz\n", cpu_str[str9100_info.cpu]);
+	num += sprintf(page+num, "1.8V Regulator Regulated vdd Output : %sv \n", v18_str[str9100_info.v18regular]);
+	num += sprintf(page+num, "--- Device \n");
+	num += sprintf(page+num, "PCI Clock: %sMhz\n", pciclk_str[str9100_info.pciclk]);
+	num += sprintf(page+num, "--- Memory \n");
+	num += sprintf(page+num, "DRAM Size: %sMBytes\n", dram_str[str9100_info.dram]);
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+	num += sprintf(page+num, "I-Scratchpad enable\n");
+#else
+	num += sprintf(page+num, "I-Scratchpad disable\n");
+#endif
+	num += sprintf(page+num, "flash type: %s\n", get_flash_type());
+
+	return num;
+}
+#endif
+
+int str9100_info_write_proc(struct file *file, const char *buffer, unsigned long count, void *data){
+
+	return 0;
+}
+
+// copy form drivers/net/str9100/star_gsw_phy.h
+#ifdef LINUX26
+#define GSW_VLAN_VID_0_1 GSW_VLAN_VID_0_1_REG
+#define GSW_VLAN_VID_2_3 GSW_VLAN_VID_2_3_REG
+#define GSW_VLAN_VID_4_5 GSW_VLAN_VID_4_5_REG
+#define GSW_VLAN_VID_6_7 GSW_VLAN_VID_6_7_REG
+#define GSW_HNAT_CONFIG GSW_HNAT_CONFIG_REG
+#endif
+
+
+//#define CONFIG_SWITCH_IOCTL
+#ifdef CONFIG_SWITCH_IOCTL
+
+#define GSW_SET_VLAN_0_VID(vid) \
+{ \
+	((GSW_VLAN_VID_0_1) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_0_1) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_1_VID(vid) \
+{ \
+	((GSW_VLAN_VID_0_1) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_0_1) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_2_VID(vid) \
+{ \
+	((GSW_VLAN_VID_2_3) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_2_3) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_3_VID(vid) \
+{ \
+	((GSW_VLAN_VID_2_3) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_2_3) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_4_VID(vid) \
+{ \
+	((GSW_VLAN_VID_4_5) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_4_5) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_5_VID(vid) \
+{ \
+	((GSW_VLAN_VID_4_5) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_4_5) |= (((vid) & 0xFFF) << 12)); \
+}
+
+#define GSW_SET_VLAN_6_VID(vid) \
+{ \
+	((GSW_VLAN_VID_6_7) &= (~(0xFFF << 0))); \
+	((GSW_VLAN_VID_6_7) |= (((vid) & 0xFFF) << 0)); \
+}
+
+#define GSW_SET_VLAN_7_VID(vid) \
+{ \
+	((GSW_VLAN_VID_6_7) &= (~(0xFFF << 12))); \
+	((GSW_VLAN_VID_6_7) |= (((vid) & 0xFFF) << 12)); \
+}
+
+void change_vid(u8 gid, u16 vid)
+{
+		switch (gid) 
+		{
+		    case 0:
+		    {
+			GSW_SET_VLAN_0_VID(vid);
+			break;
+		    }
+		    case 1:
+		    {
+			GSW_SET_VLAN_1_VID(vid); 
+			break;
+		    }
+		    case 2:
+		    {
+			GSW_SET_VLAN_2_VID(vid);
+			break;
+		    }
+		    case 3:
+		    {
+			GSW_SET_VLAN_3_VID(vid); 
+			break;
+		    }
+		    case 4:
+		    {
+			GSW_SET_VLAN_4_VID(vid);
+			break;
+		    }
+		    case 5:
+		    {
+			GSW_SET_VLAN_5_VID(vid); 
+			break;
+		    }
+		    case 6:
+		    {
+			GSW_SET_VLAN_6_VID(vid);
+			break;
+		    }
+		    case 7:
+		    {
+			GSW_SET_VLAN_7_VID(vid); 
+			break;
+		    }
+		}
+
+}
+
+int get_vid(u8 gid)
+{
+	switch (gid) 
+	{
+	    case 0:
+	    {
+		return (GSW_VLAN_VID_0_1 & 0x0fff);
+	    }
+	    case 1:
+	    {
+		return ((GSW_VLAN_VID_0_1 >> 12) & 0x0fff);
+	    }
+	    case 2:
+	    {
+		return (GSW_VLAN_VID_2_3 & 0x0fff);
+	    }
+	    case 3:
+	    {
+		return ((GSW_VLAN_VID_2_3 >> 12) & 0x0fff);
+	    }
+	    case 4:
+	    {
+		return (GSW_VLAN_VID_4_5 & 0x0fff);
+	    }
+	    case 5:
+	    {
+		return ((GSW_VLAN_VID_4_5 >> 12) & 0x0fff);
+	    }
+	    case 6:
+	    {
+		return (GSW_VLAN_VID_6_7 & 0x0fff);
+	    }
+	    case 7:
+	    {
+		return ((GSW_VLAN_VID_6_7 >> 12) & 0x0fff);
+	    }
+	}
+
+	return -1;
+}
+#endif
+
+static int str9100_info_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg){
+
+#if 1
+     int count,len;
+     char temp[STR9100_INFO_SIZE];
+#ifdef CONFIG_SWITCH_IOCTL
+	int merge_int;
+	u16 vvid_num;
+	VVIDContent vvid_content;
+	VGIDPair vgid_pair;
+	VGIDMAC vgid_mac;
+	u8 gid;
+	u32 shnat_wangid;
+	u32 hnat_cfg;
+
+	extern gsw_info_t star_gsw_info;
+
+#endif
+
+
+     switch (cmd) {
+
+#ifdef CONFIG_SWITCH_IOCTL
+        case STR9100_GSW_GET_SHNAT_WANGID:
+		copy_from_user(&shnat_wangid, (u32*)arg, sizeof(u32));
+                GSW_READ_HNAT_CONFIGURATION(hnat_cfg);
+		shnat_wangid = hnat_cfg >> 16;
+
+  		copy_to_user((u32*)arg, &shnat_wangid, sizeof(u32));
+
+		return 0;
+
+        case STR9100_GSW_SET_SHNAT_WANGID:
+		copy_from_user(&shnat_wangid, (u32 *)arg, sizeof(u32));
+
+
+                GSW_READ_HNAT_CONFIGURATION(hnat_cfg);
+                hnat_cfg &= (~(0xff << 16));
+                //gid_bitmap=simple_strtol(buf_param1, NULL, 16);
+                printk("[kernel mode] shnat_wangid : %x\n", shnat_wangid);
+                hnat_cfg |= (shnat_wangid << 16);
+                GSW_WRITE_HNAT_CONFIGURATION(hnat_cfg);
+		return 0;
+#if 1
+        case STR9100_GSW_LOOKUP_ARL:
+		copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+		#if 0
+		printk("[kernel mode] STR9100_GSW_LOOKUP_ARL\n");
+		printk("[kernel mode] gid : %d\n", vgid_mac.gid_);
+		printk("[kernel mode] mac # %x:%x:%x:%x:%x:%x\n", vgid_mac.mac_[0], vgid_mac.mac_[1],vgid_mac.mac_[2],vgid_mac.mac_[3],vgid_mac.mac_[4],vgid_mac.mac_[5]);
+		#endif
+
+		//memcpy(vgid_mac.mac_, star_gsw_info.vlan[vgid_mac.gid_].vlan_mac, 6);
+
+	        vgid_mac.vid_ = star_gsw_info.vlan[vgid_mac.gid_].vlan_vid;
+
+		printk("[kernel mode] gid : %d\n", vgid_mac.gid_);
+		printk("[kernel mode] vid : %d\n", vgid_mac.vid_);
+		//printk("[kernel mode] mac # %x:%x:%x:%x:%x:%x\n", vgid_mac.mac_[0], vgid_mac.mac_[1],vgid_mac.mac_[2],vgid_mac.mac_[3],vgid_mac.mac_[4],vgid_mac.mac_[5]);
+
+		if (star_gsw_search_arl_table(vgid_mac.mac_, vgid_mac.gid_)) {
+			return 1; // found
+		}
+		else {
+			return 0; // found
+		}
+		return 0;
+
+        //  unrelated variable star_gsw_info
+        case STR9100_GSW_ADD_VID_MAC:
+                // add a mac into arl table
+                #if 0
+                printk("[kernel mode] STR9100_GSW_ADD_VID_MAC\n");
+                #endif
+                copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+                add_mac_into_arl(vgid_mac.gid_, vgid_mac.mac_);
+                return 0;
+
+        //  unrelated variable star_gsw_info
+        //  unrelated hnat
+        case STR9100_GSW_PURE_DEL_VID_MAC:
+                copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+		//star_gsw_del_arl_table(vgid_mac.mac_, vgid_mac.gid_);
+		del_mac_from_arl(vgid_mac.gid_, vgid_mac.mac_);
+                return 0;
+
+
+	// related hnat
+        case STR9100_GSW_DEL_VID_MAC:
+		#if 0
+		printk("[kernel mode] STR9100_GSW_DEL_VID_MAC\n");
+		#endif
+		copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+
+		del_my_vlan_mac(vgid_mac.gid_);
+		return 0;
+#endif
+        case STR9100_GSW_SET_VID_MAC:
+		copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+		#if 0
+		printk("[kernel mode] STR9100_GSW_SET_VID_MAC\n");
+		//printk("[kernel mode] net_device_index_ : %d\n", vgid_mac.net_device_index_);
+		printk("[kernel mode] gid : %d\n", vgid_mac.gid_);
+		printk("[kernel mode] vid : %d\n", vgid_mac.vid_);
+		printk("[kernel mode] mac # %x:%x:%x:%x:%x:%x\n", vgid_mac.mac_[0], vgid_mac.mac_[1],vgid_mac.mac_[2],vgid_mac.mac_[3],vgid_mac.mac_[4],vgid_mac.mac_[5]);
+		#endif
+
+		change_vid(vgid_mac.gid_, vgid_mac.vid_);
+		del_my_vlan_mac(vgid_mac.gid_);
+		config_my_vlan_mac(vgid_mac.gid_, vgid_mac.vid_, vgid_mac.mac_);
+		star_gsw_hnat_write_vlan_src_mac(vgid_mac.gid_, vgid_mac.mac_);
+		//gid_map_ary[vgid_mac.net_device_index_]=vgid_mac.gid_;
+		return 0;
+
+
+        case STR9100_GSW_GET_VID_MAC:
+		copy_from_user(&vgid_mac, (VGIDMAC *)arg, sizeof(VGIDMAC));
+        	star_gsw_info.vlan[vgid_mac.gid_].vlan_gid;
+	        vgid_mac.vid_ = star_gsw_info.vlan[vgid_mac.gid_].vlan_vid;
+	        //vgid_mac.net_device_index_ = 
+		memcpy(vgid_mac.mac_, star_gsw_info.vlan[vgid_mac.gid_].vlan_mac, 6);
+
+		#if 0
+		printk("[kernel mode] STR9100_GSW_GET_VID_MAC\n");
+		printk("[kernel mode] gid : %d\n", vgid_mac.gid_);
+		printk("[kernel mode] vid : %d\n", vgid_mac.vid_);
+		printk("[kernel mode] mac # %x:%x:%x:%x:%x:%x\n", vgid_mac.mac_[0], vgid_mac.mac_[1],vgid_mac.mac_[2],vgid_mac.mac_[3],vgid_mac.mac_[4],vgid_mac.mac_[5]);
+		#endif
+	  	copy_to_user((VGIDMAC*)arg, &vgid_mac, sizeof(VGIDMAC));
+
+
+		return 0;
+
+
+        case STR9100_GSW_SET_VID:
+		copy_from_user(&vgid_pair, (VGIDPair*)arg, sizeof(VGIDPair));
+
+		//printk("SET_VID\n");
+		//printk("vgid_pair.vid_", vgid_pair.vid_);
+		//printk("vgid_pair.gid_", vgid_pair.gid_);
+		if (0 <= vgid_pair.gid_ && vgid_pair.gid_ <=7)
+		{
+			change_vid(vgid_pair.gid_, vgid_pair.vid_);
+			return 0;
+		}
+		else
+		{
+			printk("not valid gid: %d\n", vgid_pair.gid_);
+           		return -ENOTTY;
+		}
+
+        case STR9100_GSW_GET_VID:
+		copy_from_user(&vgid_pair, (VGIDPair*)arg, sizeof(VGIDPair));
+		
+		//printk("GET_VID\n");
+		//printk("vgid_pair.vid_", vgid_pair.vid_);
+		//printk("vgid_pair.gid_", vgid_pair.gid_);
+		if (0 <= vgid_pair.gid_ && vgid_pair.gid_ <=7)
+		{
+			u16 vid=get_vid(vgid_pair.gid_);
+			vgid_pair.vid_=vid;
+			//printk("vid : %d\n", vid);
+	  		copy_to_user((VGIDPair*)arg, &vgid_pair, sizeof (VGIDPair));
+			return 0;
+		}
+		else
+		{
+			printk("not valid gid: %d\n", vgid_pair.gid_);
+           		return -ENOTTY;
+		}
+
+#ifdef CONFIG_VVID
+        case STR9100_GSW_SET_VVID:
+		//copy_from_user(&vvid_data, (VVID *)arg, sizeof(VVID));
+		copy_from_user(&vvid_content, (VVIDContent *)arg, sizeof(VVIDContent));
+		//printk("vvid.pri_: %d\n", vvid_data.pri_);
+		//printk("vvid.vid_: %d\n", vvid_data.vid_);
+         	merge_int = (vvid_content.pri_ << 12 | vvid_content.vid_);
+		if (vvid[merge_int]==0)
+		{ // insert a vvid number (vvid_szie)
+			++vvid_size;
+			vvid[merge_int]=vvid_content.vvid_num_;
+			vvid_ary[vvid_content.vvid_num_].pri_=vvid_content.pri_;
+			vvid_ary[vvid_content.vvid_num_].vid_=vvid_content.vid_;
+			//printk("in kernel vvid_ary[%d] => (%d, %d)\n", vvid_content.vvid_num_, vvid_ary[vvid_content.vvid_num_].pri_, vvid_ary[vvid_content.vvid_num_].vid_);
+		}
+		else
+		{
+			printk("vvid[%d] already exist\n", merge_int);
+		}
+		return vvid_size;
+
+
+        case STR9100_GSW_GET_VVID:
+		copy_from_user(&vvid_content, (VVIDContent *)arg, sizeof(VVIDContent));
+		//printk("in kernel vvid_content.vvid_num_: %d\n", vvid_content.vvid_num_);
+		vvid_content.pri_ = vvid_ary[vvid_content.vvid_num_].pri_;
+		vvid_content.vid_ = vvid_ary[vvid_content.vvid_num_].vid_;
+		printk("in get kernel vvid_ary[%d] => (%d, %d)\n", vvid_content.vvid_num_, vvid_content.pri_, vvid_content.vid_);
+	  	copy_to_user((VVIDContent*)arg, &vvid_content, sizeof (VVIDContent));
+		return 0;
+	   	break;
+
+#endif // CONFIG_VVID
+#endif // end CONFIG_SWITCH_IOCTL
+
+
+        case STR9100_INFO_IOCGETD:    
+	   printk("STR9100_INFO_IOCGETD \n");
+           copy_to_user((unsigned char *)arg, (unsigned char *)&str9100_info, sizeof(str9100_info));
+	   goto ioctlexit;
+
+        case STR9100_INFO_IOCSETD:
+	   printk("STR9100_INFO_IOCSETD \n");
+           //if (copy_from_user(temp, (unsigned char *)arg, count))     
+           //    return -EFAULT;    
+	   goto ioctlexit;
+
+	case STR9100_INFO_IOCPUCLK:
+	   len = strlen(cpu_str[str9100_info.cpu]);
+	   strcpy(temp,cpu_str[str9100_info.cpu]);
+	   break;
+
+	case STR9100_INFO_IOV18:
+	   len = strlen(v18_str[str9100_info.v18regular]);
+	   strcpy(temp,v18_str[str9100_info.v18regular]);
+	   break;
+
+	case STR9100_INFO_IOPCICLK:
+	   len = strlen(pciclk_str[str9100_info.pciclk]);
+	   strcpy(temp,pciclk_str[str9100_info.pciclk]);
+	   break;
+
+	case STR9100_INFO_IODRAMSZ:
+	   len = strlen(dram_str[str9100_info.dram]);
+	   strcpy(temp,dram_str[str9100_info.dram]);
+	   break;
+
+
+
+        default:
+           return -ENOTTY;
+  /*         return -EINVAL; another return option */                      
+     }
+
+
+	  copy_to_user((unsigned char *)arg,temp,len+1);
+
+
+
+ioctlexit:
+#endif
+	return 0;
+}
+
+static int str9100_info_open(struct inode *inode, struct file *file)
+{
+        unsigned int minor = MINOR(inode->i_rdev);
+        if (minor != STR9100_INFO_MINOR)
+                return -ENODEV;
+
+#ifdef MODULE
+        MOD_INC_USE_COUNT;
+#endif
+
+        return 0;
+}
+
+
+static int str9100_info_release(struct inode *inode, struct file *file)
+{
+
+#ifdef MODULE
+        MOD_DEC_USE_COUNT;
+#endif
+
+        return 0;
+}
+
+
+/*
+ * ioctl interface
+ */
+static struct file_operations str9100_info_fops =
+{
+        owner:          THIS_MODULE,
+        ioctl:          str9100_info_ioctl,
+        open:           str9100_info_open,
+        release:        str9100_info_release,
+};
+
+/* STR9100_MINOR in include/linux/miscdevice.h */
+static struct miscdevice str9100_info_miscdev =
+{
+        STR9100_INFO_MINOR,
+        "str9100_info",
+        &str9100_info_fops
+};
+
+
+#ifdef LINUX24
+static int __init str9100_info_init(void){
+	struct proc_dir_entry *procdir=0;
+
+
+	get_system_info();
+
+	misc_register(&str9100_info_miscdev);
+
+	//proc_mkdir("str9100",0);
+	procdir= create_proc_str9100(PROC_STR);
+	if (procdir)
+	{
+		str9100_info_proc = create_proc_entry("info", S_IFREG | S_IRUGO, procdir);
+                if (str9100_info_proc) {
+                        str9100_info_proc->read_proc = str9100_info_read_proc;
+                        str9100_info_proc->write_proc = str9100_info_write_proc;
+                }
+		printk("Str9100 Information inited \n");
+                return 0;
+        }
+        else
+                return -1;
+	
+	//str9100_info_proc=create_proc_read_entry( "str9100/info", 0, NULL, str9100_info_read_proc,NULL) ;
+        //str9100_info_proc->write_proc=star9100_info_write_proc;
+
+
+}
+#endif
+
+#ifdef LINUX26
+static int __init str9100_info_init(void)
+{
+	get_system_info();
+
+	str9100_info_proc_entry = create_proc_entry("str9100/info", S_IFREG | S_IRUGO, NULL);
+	if (str9100_info_proc_entry) {
+		str9100_info_proc_entry->read_proc = str9100_info_read_proc;
+		str9100_info_proc_entry->write_proc = str9100_info_write_proc;
+	}
+
+	misc_register(&str9100_info_miscdev);
+
+	return 1;
+}
+#endif
+
+
+static void __exit str9100_info_exit(void){
+
+	misc_deregister(&str9100_info_miscdev);
+
+	remove_proc_entry("str9100/info",NULL);
+
+	printk("Str9100 Information exit \n");
+}
+
+module_init(str9100_info_init);
+module_exit(str9100_info_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str9100/str9100_info.c.26 linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_info.c.26
--- linux-2.6.35.11/drivers/star/str9100/str9100_info.c.26	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_info.c.26	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,262 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/stddef.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+#include <asm/arch/hardware.h>
+#include <linux/kdev_t.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <linux/str9100/str9100_tool.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+static const char *cpu_str[] = {
+"175",
+"200",
+"225",
+"250"
+};
+
+static const char *v18_str[] = {
+"1.537",
+"1.594",
+"1.655",
+"1.721",
+"1.793",
+"1.871",
+"1.956",
+"2.049"
+};
+
+static const char *pciclk_str[] = {
+"33",
+"66",
+"-"
+};
+
+static const char *dram_str[] = {
+"16",
+"32",
+"64",
+"-"
+};
+
+typedef struct STR9100_INFO {
+	u32 cpu;
+	u32 v18regular;
+	u32 pciclk;
+	u32 dram;
+} STR9100_INFO;
+
+static STR9100_INFO str9100_info;
+static struct proc_dir_entry *str9100_info_proc_entry;
+
+static int get_system_info(void)
+{
+	u32 temp;
+	temp = (PWRMGT_RESET_LATCH_CONFIGURATION_REG >> 6) & 0x3;
+	str9100_info.cpu = temp;
+
+	temp = (PWRMGT_REGULATOR_CONTROL_REG >> 11) & 0x7;
+	temp = ((temp >> 11)&0x7);
+	str9100_info.v18regular = temp;
+
+#if defined(CONFIG_STR9100_PCI66M)
+	str9100_info.pciclk = 1;
+#elif defined(CONFIG_STR9100_PCI33M)
+	str9100_info.pciclk = 0;
+#else
+	str9100_info.pciclk = 2;
+#endif
+
+#if defined(CONFIG_STR9100_DRAM_64M)
+	str9100_info.dram = 2;
+#elif defined(CONFIG_STR9100_DRAM_32M)
+	str9100_info.dram = 1;
+#elif defined(CONFIG_STR9100_DRAM_16M)
+	str9100_info.dram = 0;
+#else
+	str9100_info.dram = 3;
+#endif
+
+	return 0;
+}
+
+static int str9100_info_read_proc(char *page, char **start,  off_t off, int count, int *eof, void *data)
+{
+	int num = 0;
+
+	// for human readable
+	num += sprintf(page+num, "--- CPU \n");
+	num += sprintf(page+num, "CPU Clock: STR9100 %sMhz\n", cpu_str[str9100_info.cpu]);
+	num += sprintf(page+num, "1.8V Regulator Regulated vdd Output : %sv \n", v18_str[str9100_info.v18regular]);
+	num += sprintf(page+num, "--- Device \n");
+	num += sprintf(page+num, "PCI Clock: %sMhz\n", pciclk_str[str9100_info.pciclk]);
+	num += sprintf(page+num, "--- Memory \n");
+	num += sprintf(page+num, "DRAM Size: %sMBytes\n", dram_str[str9100_info.dram]);
+#ifdef CONFIG_CPU_ISPAD_ENABLE
+	num += sprintf(page+num, "I-Scratchpad enable\n");
+#else
+	num += sprintf(page+num, "I-Scratchpad disable\n");
+#endif
+	num += sprintf(page+num, "flash type: %s\n", get_flash_type());
+
+	return num;
+}
+
+static int str9100_info_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	return 0;
+}
+
+static int str9100_info_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	int count,len;
+	char temp[STR9100_INFO_SIZE];
+
+	switch (cmd) {
+	case STR9100_INFO_IOCGETD:    
+		printk("STR9100_INFO_IOCGETD \n");
+		copy_to_user((unsigned char *)arg, (unsigned char *)&str9100_info, sizeof(str9100_info));
+		break;
+
+	case STR9100_INFO_IOCSETD:
+		printk("STR9100_INFO_IOCSETD \n");
+		//if (copy_from_user(temp, (unsigned char *)arg, count))     
+			//return -EFAULT;
+		break;
+
+	case STR9100_INFO_IOCPUCLK:
+		len = strlen(cpu_str[str9100_info.cpu]);
+		strcpy(temp,cpu_str[str9100_info.cpu]);
+		copy_to_user((unsigned char *)arg, temp, len + 1);
+		break;
+
+	case STR9100_INFO_IOV18:
+		len = strlen(v18_str[str9100_info.v18regular]);
+		strcpy(temp,v18_str[str9100_info.v18regular]);
+		copy_to_user((unsigned char *)arg, temp, len + 1);
+		break;
+
+	case STR9100_INFO_IOPCICLK:
+		len = strlen(pciclk_str[str9100_info.pciclk]);
+		strcpy(temp,pciclk_str[str9100_info.pciclk]);
+		copy_to_user((unsigned char *)arg, temp, len + 1);
+		break;
+
+	case STR9100_INFO_IODRAMSZ:
+		len = strlen(dram_str[str9100_info.dram]);
+		strcpy(temp,dram_str[str9100_info.dram]);
+		copy_to_user((unsigned char *)arg, temp, len + 1);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int str9100_info_open(struct inode *inode, struct file *file)
+{
+	unsigned int minor = MINOR(inode->i_rdev);
+	if (minor != STR9100_INFO_MINOR)
+		return -ENODEV;
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return 0;
+}
+
+
+static int str9100_info_release(struct inode *inode, struct file *file)
+{
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return 0;
+}
+
+
+/*
+ * ioctl interface
+ */
+static struct file_operations str9100_info_fops =
+{
+	owner:		THIS_MODULE,
+	ioctl:		str9100_info_ioctl,
+	open:		str9100_info_open,
+	release:	str9100_info_release,
+};
+
+/* STR9100_MINOR in include/linux/miscdevice.h */
+static struct miscdevice str9100_info_miscdev =
+{
+	STR9100_INFO_MINOR,
+	"str9100_info",
+	&str9100_info_fops
+};
+
+static int __init str9100_info_init(void)
+{
+	get_system_info();
+
+	str9100_info_proc_entry = create_proc_entry("str9100/info", S_IFREG | S_IRUGO, NULL);
+	if (str9100_info_proc_entry) {
+		str9100_info_proc_entry->read_proc = str9100_info_read_proc;
+		str9100_info_proc_entry->write_proc = str9100_info_write_proc;
+	}
+
+	misc_register(&str9100_info_miscdev);
+
+	return 1;
+}
+
+static void __exit str9100_info_exit(void)
+{
+	misc_deregister(&str9100_info_miscdev);
+	remove_proc_entry("str9100/info", NULL);
+}
+
+module_init(str9100_info_init);
+module_exit(str9100_info_exit);
+
diff -Nur linux-2.6.35.11/drivers/star/str9100/str9100_shnat_hook.c linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_shnat_hook.c
--- linux-2.6.35.11/drivers/star/str9100/str9100_shnat_hook.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_shnat_hook.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,78 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/config.h>
+
+#ifdef CONFIG_NETFILTER
+#include <linux/types.h>
+#include <linux/inetdevice.h>
+#include <linux/ip.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <net/protocol.h>
+#include <net/ip.h>
+#include <net/checksum.h>
+#include <net/route.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+#include <linux/str9100/star9100_shnat.h>
+#include <linux/str9100/str9100_shnat_hook.h>
+
+//#ifdef CONFIG_STAR9100_SHNAT_PCI_FASTPATH
+struct net_device *pci_netdev[MAX_FP_PCIDEV];
+EXPORT_SYMBOL(pci_netdev);
+int (*star9100_shnat_pci_fp_forward_skb_ptr)(struct sk_buff *skb);
+//#endif
+
+int star9100_shnat_hook_ready;
+int (*star9100_shnat_preadd_hnatable_hook)(u32 sip,u16 sport,u16 dport, u32 proto);
+int (*star9100_shnat_check_shnat_enable_hook)(void);
+int (*star9100_shnat_nf_nat_preadd_hnatable_hook)(const struct ip_conntrack *ct, int dir, const u16 port);
+int (*star9100_shnat_nf_remove_hnatable_hook)(struct ip_conntrack *);
+int (*star9100_shnat_nf_add_hnatable_hook)(const struct ip_conntrack *ct,const struct iphdr *iph, u16 proto);
+int (*star9100_shnat_add_arptable_hook)(u32 myip, u32 targetip);
+int (*star9100_shnat_fix_arptable_hook)(u32 myip, u32 targetip);
+int (*star9100_shnat_nf_preadd_hnatable_hook)(const struct sk_buff **pskb);
+int (*star9100_shnat_check_ftponly_enable_hook)(void);
+int (*star9100_shnat_pci_fp_getdev_hook)(struct sk_buff *skb_ptr);
+star9100_arp_table *(*star9100_shnat_getarptable_hook)( u32 ip_addr);
+
+
+EXPORT_SYMBOL(star9100_shnat_hook_ready);
+EXPORT_SYMBOL(star9100_shnat_preadd_hnatable_hook);
+EXPORT_SYMBOL(star9100_shnat_check_shnat_enable_hook);
+EXPORT_SYMBOL(star9100_shnat_nf_nat_preadd_hnatable_hook);
+EXPORT_SYMBOL(star9100_shnat_nf_remove_hnatable_hook);
+EXPORT_SYMBOL(star9100_shnat_nf_add_hnatable_hook);
+EXPORT_SYMBOL(star9100_shnat_add_arptable_hook);
+EXPORT_SYMBOL(star9100_shnat_fix_arptable_hook);
+EXPORT_SYMBOL(star9100_shnat_nf_preadd_hnatable_hook);
+EXPORT_SYMBOL(star9100_shnat_check_ftponly_enable_hook);
+EXPORT_SYMBOL(star9100_shnat_getarptable_hook);
+EXPORT_SYMBOL(star9100_shnat_pci_fp_getdev_hook);
+EXPORT_SYMBOL(star9100_shnat_pci_fp_forward_skb_ptr);
+
+#endif
diff -Nur linux-2.6.35.11/drivers/star/str9100/str9100_tool.c linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_tool.c
--- linux-2.6.35.11/drivers/star/str9100/str9100_tool.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_tool.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,287 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,32)
+#define LINUX24 1
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26 1
+#endif
+
+#ifdef LINUX24
+#include <asm/arch/str9100/star_tool.h>
+#endif
+
+#ifdef LINUX26
+#include <linux/str9100/str9100_tool.h>
+#endif
+
+#include <linux/proc_fs.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+
+
+
+#ifdef LINUX24
+// for star_tool.h create_proc_str9100()
+//int create_proc_dir=0;
+
+
+struct proc_dir_entry *create_proc_str9100(const char* proc_str)
+{
+	struct proc_dir_entry *de;
+	struct proc_dir_entry *str9100_gsw_procdir=0;
+
+
+        de = &proc_root;
+        for (de = de->subdir; de ; de = de->next) {
+		if (strcmp(de->name, "str9100")==0) // find it
+		{
+			return de;
+		}
+        }
+
+	// not found /proc/str9100, so create it.
+
+	
+       	str9100_gsw_procdir=proc_mkdir(proc_str, NULL);
+       	if (str9100_gsw_procdir==0)
+		return 0;
+
+
+	return str9100_gsw_procdir;
+}
+#endif
+
+
+
+#define CONFIG_GET_FLASH_VAR
+#ifdef CONFIG_GET_FLASH_VAR
+// add by descent 2006/07/20
+
+/* Add for read MAC from FLASH. */
+#ifndef __ARM_BE__
+#define B0(h)   ((h) & 0xFF)
+#define B1(h)   (((h) >> 8) & 0xFF)
+#else
+#define B0(h)   (((h) >> 8) & 0xFF)
+#define B1(h)   ((h) & 0xFF) 
+#endif
+
+void copy_from_flash(unsigned long from, void *to,ssize_t len)
+{   
+        int i;  
+        u8 *dest = (u8*)to;
+        u16 data;
+        unsigned long remap = (unsigned long)ioremap(FLASH_BASE_ADDR,FLASH_SIZE);
+        u16 *src = (u16 *)(remap + from);
+
+        for(i = 0; i < (len / 2);i++){
+                data = src[i];
+                dest[i * 2] = B0(data);
+                dest[i * 2 + 1] = B1(data);
+
+        }
+        if(len & 1)
+                dest[len - 1] = B0(src[i]);
+	iounmap(remap);
+}
+
+#if 0
+char *get_flash_env(const char *env_name)
+{
+	const int ENV_SIZE=0x8000;
+	//const char *ENV_BEGIN=FLASH_ADDRESS(0x10000000)+0x20000;
+	//const char *ENV_BEGIN=FLASH_ADDRESS(0x10020000);
+	unsigned long from=0x20000;
+
+        volatile unsigned long remap = (unsigned long)ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+        volatile u8 *src = (u16 *)(remap + from);
+
+	int i=0;
+	char *str_p=env_name;
+	char *beg_p=src;
+	char *p;
+	 
+
+	while(1) {
+		p=strstr(beg_p, env_name);
+		if (p) { // found
+			char *asign_p=strchr(p, '=');
+			if (asign_p)
+			{
+        			iounmap(remap);
+				return asign_p+1;
+			}
+			else
+				break; // should not this case
+		}
+		else
+		{
+			++beg_p;
+		}
+
+		if (p > src+ENV_SIZE) {
+			break;
+		}
+	}
+        iounmap(remap);
+	return 0; // not found
+}
+#else
+// copy from 2.6.16
+char *get_flash_env(const char *env_name)
+{
+	const int ENV_SIZE = 0x8000;
+	unsigned long from = 0x20000;
+
+	u8 *remap = ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+	volatile u8 *src = (volatile u8 *)(remap + from);
+
+	char *str_p = env_name;
+	char *beg_p = src;
+	char *p;
+
+	while (1) {
+		p = strstr(beg_p, str_p);
+		if (p) { // found
+			char *asign_p = strchr(p, '=');
+			if (asign_p) {
+				iounmap(remap);
+				return asign_p + 1;
+			} else
+				break; // should not this case
+		} else {
+			++beg_p;
+		}
+		if (p > (src + ENV_SIZE)) {
+			break;
+		}
+	}
+        iounmap(remap);
+	return 0; // not found
+}
+
+#endif
+#endif // ifdef CONFIG_GET_FLASH_VAR
+
+
+/*
+ *  * MXIC's flash manufacture ID
+ *   */
+#define MX_MANUFACT     0x00C200C2      /* MXIC    manuf. ID in D23..D16, D7..D0 */
+
+
+#define MXIC_MANUFACTURE_ID             0x00C20000
+
+/*
+ *  * MXIC's flash device ID
+ *   */
+#define MXIC_DEVICE_ID_MX29LV320B       0x000000A8
+#define MX_ID_LV640BB       0x22CB22CB      /* 29LV640BB by Macronix, AMD compatible */
+#define MX_ID_LV640BT       0x22C922C9      /* 29LV640BT by Macronix, AMD compatible */
+
+#ifdef LINUX24
+const char *get_flash_type(volatile u16 *saddr)
+{
+	short i;
+	u16 mid;
+	u16 did;
+	int name_index=0;
+	const char *flash_name[]={
+	                           0,
+	                           "EON_EN29LV640HL(8MB)",
+	                           "MXIC_MX29LV640BT(8MB)"
+	                         };
+	//u32  base = (u32)addr;
+
+        //volatile unsigned long remap = (unsigned long)ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+        //volatile u16 *saddr = (u16 *)(remap + 0);
+
+        //volatile u8 *src = (u16 *)(remap + 0);
+	//volatile u8 *saddr = src;
+
+	/* Write auto select command: read Manufacturer ID */
+	saddr[0x555] = 0xAA;
+	saddr[0x2AA] = 0x55;
+	saddr[0x555] = 0x90;
+
+	mid = saddr[0];
+	did = saddr[1];
+
+	if ( ((mid & 0xffff) == 0x007f) && ((did & 0xFFFF) == 0x227e) ) // "EON_EN29LV640HL(8MB)"
+		name_index=1;
+	if ( ((mid & 0xffff) == 0x00c2) && ((did & 0xFFFF) == 0x22c9) ) // "MXIC_MX29LV640BT(8MB)"
+		name_index=2;
+
+
+
+	/* reset to read mode */
+	saddr[0] = 0xF0; /* reset the bank */
+	udelay(10000);
+
+	return flash_name[name_index];
+}
+#endif
+
+#ifdef LINUX26
+const char *get_flash_type(void)
+{
+	u8 *remap = ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+	volatile u16 *saddr = (volatile u16 *)remap;
+	u16 mid;
+	u16 did;
+	int name_index = 0;
+	const char *flash_name[] = {
+		0,
+		"EON_EN29LV640HL(8MB)",
+		"MXIC_MX29LV640BT(8MB)"
+	};
+
+	/* Write auto select command: read Manufacturer ID */
+	saddr[0x555] = 0xAA;
+	saddr[0x2AA] = 0x55;
+	saddr[0x555] = 0x90;
+
+	mid = saddr[0];
+	did = saddr[1];
+
+	if (((mid & 0xffff) == 0x007f) && ((did & 0xFFFF) == 0x227e) ) // "EON_EN29LV640HL(8MB)"
+		name_index=1;
+	if (((mid & 0xffff) == 0x00c2) && ((did & 0xFFFF) == 0x22c9) ) // "MXIC_MX29LV640BT(8MB)"
+		name_index=2;
+
+	/* reset to read mode */
+	saddr[0] = 0xF0; /* reset the bank */
+	udelay(1000);
+
+	iounmap(remap);
+
+	return flash_name[name_index];
+}
+#endif
+
diff -Nur linux-2.6.35.11/drivers/star/str9100/str9100_tool.c.26 linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_tool.c.26
--- linux-2.6.35.11/drivers/star/str9100/str9100_tool.c.26	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/star/str9100/str9100_tool.c.26	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+
+//#include <asm/arch/star_tool.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+#define CONFIG_GET_FLASH_VAR
+
+#ifdef CONFIG_GET_FLASH_VAR
+// add by descent 2006/07/20
+/* Add for read MAC from FLASH. */
+#ifndef __ARM_BE__
+#define B0(h)	((h) & 0xFF)
+#define B1(h)	(((h) >> 8) & 0xFF)
+#else
+#define B0(h)	(((h) >> 8) & 0xFF)
+#define B1(h)	((h) & 0xFF) 
+#endif
+
+void copy_from_flash(unsigned long from, void *to, ssize_t len)
+{
+	int i;
+	u8 *dest = (u8*)to;
+	u16 data;
+	u8 *remap = ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+	volatile u16 *src = (volatile u16 *)(remap + from);
+
+	for (i = 0; i < (len / 2); i++) {
+		data = src[i];
+		dest[i * 2] = B0(data);
+		dest[i * 2 + 1] = B1(data);
+	}
+
+	if (len & 1)
+		dest[len - 1] = B0(src[i]);
+
+	iounmap(remap);
+}
+
+char *get_flash_env(const char *env_name)
+{
+	const int ENV_SIZE = 0x8000;
+	unsigned long from = 0x20000;
+
+	u8 *remap = ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+	volatile u8 *src = (volatile u8 *)(remap + from);
+
+	char *str_p = env_name;
+	char *beg_p = src;
+	char *p;
+
+	while (1) {
+		p = strstr(beg_p, str_p);
+		if (p) { // found
+			char *asign_p = strchr(p, '=');
+			if (asign_p) {
+				iounmap(remap);
+				return asign_p + 1;
+			} else
+				break; // should not this case
+		} else {
+			++beg_p;
+		}
+		if (p > (src + ENV_SIZE)) {
+			break;
+		}
+	}
+        iounmap(remap);
+	return 0; // not found
+}
+#endif
+
+/*
+ * MXIC's flash manufacture ID
+ */
+#define MX_MANUFACT			0x00C200C2 /* MXIC manuf. ID in D23..D16, D7..D0 */
+#define MXIC_MANUFACTURE_ID		0x00C20000
+
+/*
+ * MXIC's flash device ID
+ */
+#define MXIC_DEVICE_ID_MX29LV320B	0x000000A8
+#define MX_ID_LV640BB			0x22CB22CB /* 29LV640BB by Macronix, AMD compatible */
+#define MX_ID_LV640BT			0x22C922C9 /* 29LV640BT by Macronix, AMD compatible */
+
+const char *get_flash_type(void)
+{
+	u8 *remap = ioremap(FLASH_BASE_ADDR, FLASH_SIZE);
+	volatile u16 *saddr = (volatile u16 *)remap;
+	u16 mid;
+	u16 did;
+	int name_index = 0;
+	const char *flash_name[] = {
+		0,
+		"EON_EN29LV640HL(8MB)",
+		"MXIC_MX29LV640BT(8MB)"
+	};
+
+	/* Write auto select command: read Manufacturer ID */
+	saddr[0x555] = 0xAA;
+	saddr[0x2AA] = 0x55;
+	saddr[0x555] = 0x90;
+
+	mid = saddr[0];
+	did = saddr[1];
+
+	if (((mid & 0xffff) == 0x007f) && ((did & 0xFFFF) == 0x227e) ) // "EON_EN29LV640HL(8MB)"
+		name_index=1;
+	if (((mid & 0xffff) == 0x00c2) && ((did & 0xFFFF) == 0x22c9) ) // "MXIC_MX29LV640BT(8MB)"
+		name_index=2;
+
+	/* reset to read mode */
+	saddr[0] = 0xF0; /* reset the bank */
+	udelay(1000);
+
+	iounmap(remap);
+
+	return flash_name[name_index];
+}
+
diff -Nur linux-2.6.35.11/drivers/usb/core/buffer.c linux-2.6.35.11-ts7500//drivers/usb/core/buffer.c
--- linux-2.6.35.11/drivers/usb/core/buffer.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/usb/core/buffer.c	2011-02-26 20:32:46.000000000 -0500
@@ -53,9 +53,11 @@
 	char		name[16];
 	int 		i, size;
 
+#if !defined(CONFIG_ARCH_STR9100) && !defined(CONFIG_ARCH_STR8100)
 	if (!hcd->self.controller->dma_mask &&
 	    !(hcd->driver->flags & HCD_LOCAL_MEM))
 		return 0;
+#endif
 
 	for (i = 0; i < HCD_BUFFER_POOLS; i++) {
 		size = pool_max[i];
diff -Nur linux-2.6.35.11/drivers/usb/host/ehci-hcd.c linux-2.6.35.11-ts7500//drivers/usb/host/ehci-hcd.c
--- linux-2.6.35.11/drivers/usb/host/ehci-hcd.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/usb/host/ehci-hcd.c	2011-02-26 20:32:46.000000000 -0500
@@ -722,7 +722,12 @@
 	masked_status = status & INTR_MASK;
 	if (!masked_status) {		/* irq sharing? */
 		spin_unlock(&ehci->lock);
-		return IRQ_NONE;
+#ifdef CONFIG_VIC_INTERRUPT
+                return IRQ_HANDLED;
+#else
+                return IRQ_NONE;
+#endif
+		
 	}
 
 	/* clear (just) interrupts */
@@ -1143,6 +1148,11 @@
 #define	PLATFORM_DRIVER		ehci_orion_driver
 #endif
 
+#ifdef CONFIG_ARCH_STR8100
+#include "ehci-str8100.c"
+#define PLATFORM_DRIVER         str8100_ehci_hcd_driver
+#endif
+
 #ifdef CONFIG_ARCH_IXP4XX
 #include "ehci-ixp4xx.c"
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
diff -Nur linux-2.6.35.11/drivers/usb/host/ehci-str8100.c linux-2.6.35.11-ts7500//drivers/usb/host/ehci-str8100.c
--- linux-2.6.35.11/drivers/usb/host/ehci-str8100.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//drivers/usb/host/ehci-str8100.c	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,190 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#include <linux/platform_device.h>
+#include <asm/arch/hardware.h>
+
+static int str8100_ehci_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	int			retval;
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	return ehci_init(hcd);
+}
+#ifdef	CONFIG_PM
+//mkl070226: the functionality of suspend/resume is not complete
+static int ehci_suspend (struct usb_hcd *hcd)
+{
+	printk("%s: not implemented, just pass it\n",__FUNCTION__);
+	return 0;
+}
+static int ehci_resume (struct usb_hcd *hcd)
+{
+	printk("%s: not implemented, just pass it\n",__FUNCTION__);
+	return 0;
+}
+#endif
+
+static const struct hc_driver str8100_ehci_driver = {
+	.description =		hcd_name,
+        .product_desc =		"str8100-ehci",
+        .hcd_priv_size =	sizeof(struct ehci_hcd),
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		str8100_ehci_setup, 
+	.start =		ehci_run,
+#ifdef	CONFIG_PM
+//mkl070226: the functionality of suspend/resume is not complete
+	.suspend =		ehci_suspend,
+	.resume =		ehci_resume,
+
+	.bus_suspend =		ehci_suspend,
+	.bus_resume =		ehci_resume,
+#endif
+	.stop =			ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+};
+
+static void  str8100_usb20_config_reg_init(void)
+{
+#if 0
+	__asm__ __volatile__(
+		"mov	r1, #0			\n"
+		"mcr	p15, 0, r1, c7, c5, 0	\n"
+		"mov	r1, #0			\n"
+		"mcr	p15, 0, r1, c7, c14, 0	\n"
+	);
+#endif
+	__raw_writel(0x106, SYSVA_USB20_CONFIG_BASE_ADDR + 0x04);
+	__raw_writel((3 << 5) | 0x20000, SYSVA_USB20_OPERATION_BASE_ADDR + 0x40);
+	mdelay(100);
+}
+
+int str8100_ehci_usb_hcd_probe(const struct hc_driver *driver, 
+	struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	char *name = "str8100-ehci";
+	int retval = 0;
+
+	str8100_usb20_config_reg_init();
+	hcd = usb_create_hcd(driver, &pdev->dev, name);
+	if (!hcd) { 
+		retval = -ENOMEM;
+		return retval;
+	}
+	hcd->regs = (unsigned int *)SYSVA_USB20_OPERATION_BASE_ADDR;
+	hcd->rsrc_start = SYSPA_USB20_OPERATION_BASE_ADDR;
+	hcd->rsrc_len = 4096;
+	hcd->driver = driver;
+	/* scott.usb
+	retval = usb_add_hcd(hcd, INTC_USB20_BIT_INDEX, SA_INTERRUPT);
+	*/
+	retval = usb_add_hcd(hcd, INTC_USB20_BIT_INDEX, IRQF_SHARED);
+	if (retval == 0) {
+		return retval;
+	}
+	printk("str8100 ehci init fail, %d\n", retval);
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+int str8100_ehci_usb_hcd_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+static int str8100_ehci_hcd_drv_probe(struct platform_device *pdev)
+{
+	return str8100_ehci_usb_hcd_probe(&str8100_ehci_driver, pdev);
+}
+
+static struct platform_driver str8100_ehci_hcd_driver = {
+	.probe		= str8100_ehci_hcd_drv_probe,
+	.remove		= str8100_ehci_usb_hcd_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "str8100-ehci",
+	},
+};
+
+/*
+static int __init str8100_ehci_hcd_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+		hcd_name,
+		sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
+		sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
+
+	return platform_driver_register(&str8100_ehci_hcd_driver);
+}
+module_init(str8100_ehci_hcd_init);
+
+static void __exit str8100_ehci_hcd_cleanup(void)
+{
+	platform_driver_unregister(&str8100_ehci_hcd_driver);
+}
+module_exit(str8100_ehci_hcd_cleanup);
+*/
diff -Nur linux-2.6.35.11/files.txt linux-2.6.35.11-ts7500//files.txt
--- linux-2.6.35.11/files.txt	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//files.txt	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,97 @@
+../linux-2.6.24-cavium/arch/arm/mm/Kconfig
+../linux-2.6.24-cavium/arch/arm/boot/compressed/Makefile
+../linux-2.6.24-cavium/arch/arm/boot/compressed/head.S
+../linux-2.6.24-cavium/arch/arm/boot/compressed/misc.c
+../linux-2.6.24-cavium/arch/arm/boot/compressed/head-str8100.S
+../linux-2.6.24-cavium/arch/arm/boot/initrd
+../linux-2.6.24-cavium/arch/arm/mach-str8100/Makefile
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_pm.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_hsdma.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_gpio.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_intc.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_misc.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/Kconfig
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_demo_i2s_wm8772_config.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_setup.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_demo_i2s_config.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_demo_pcm_legerity_config_2phone.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_timer.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_i2s.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_dma.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_demo_dma.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_pci.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_counter.c
+../linux-2.6.24-cavium/arch/arm/mach-str8100/str8100_rtc.c
+../linux-2.6.24-cavium/arch/arm/configs/str8133_defconfig
+../linux-2.6.24-cavium/arch/arm/configs/str9100_defconfig
+../linux-2.6.24-cavium/arch/arm/configs/ts7500_defconfig
+../linux-2.6.24-cavium/arch/arm/Makefile
+../linux-2.6.24-cavium/arch/arm/tools/mach-types
+../linux-2.6.24-cavium/arch/arm/Kconfig
+../linux-2.6.24-cavium/arch/arm/kernel/setup.c
+../linux-2.6.24-cavium/arch/arm/kernel/head.S
+../linux-2.6.24-cavium/drivers/i2c/busses/Makefile
+../linux-2.6.24-cavium/drivers/i2c/busses/Kconfig
+../linux-2.6.24-cavium/drivers/i2c/busses/i2c-str8100.c
+../linux-2.6.24-cavium/drivers/i2c/busses/i2c-str8100.h
+../linux-2.6.24-cavium/drivers/ide/arm/Makefile
+../linux-2.6.24-cavium/drivers/ide/arm/str8100-ide.c
+../linux-2.6.24-cavium/drivers/ide/ide-lib.c
+../linux-2.6.24-cavium/drivers/ide/ide.c
+../linux-2.6.24-cavium/drivers/ide/ide-io.c
+../linux-2.6.24-cavium/drivers/ide/Kconfig
+../linux-2.6.24-cavium/drivers/ide/setup-pci.c
+../linux-2.6.24-cavium/drivers/ide/ide-probe.c
+../linux-2.6.24-cavium/drivers/ide/ide-dma.c
+../linux-2.6.24-cavium/drivers/net/Makefile
+../linux-2.6.24-cavium/drivers/net/e1000/e1000_main.c
+../linux-2.6.24-cavium/drivers/net/Kconfig
+../linux-2.6.24-cavium/drivers/net/str8100/star_nic.c
+../linux-2.6.24-cavium/drivers/net/str8100/Kconfig
+../linux-2.6.24-cavium/drivers/mtd/maps/Makefile
+../linux-2.6.24-cavium/drivers/mtd/maps/Kconfig
+../linux-2.6.24-cavium/drivers/mtd/maps/str8100.c
+../linux-2.6.24-cavium/drivers/pci/setup-bus.c
+../linux-2.6.24-cavium/drivers/spi/Makefile
+../linux-2.6.24-cavium/drivers/spi/spi.c
+../linux-2.6.24-cavium/drivers/spi/spi_bitbang.c
+../linux-2.6.24-cavium/drivers/spi/Kconfig
+../linux-2.6.24-cavium/drivers/spi/spi_str8100.c
+../linux-2.6.24-cavium/drivers/usb/core/buffer.c
+../linux-2.6.24-cavium/drivers/usb/host/ehci-hcd.c
+../linux-2.6.24-cavium/drivers/usb/host/ehci-str8100.c
+../linux-2.6.24-cavium/drivers/usb/host/ohci-hcd.c
+../linux-2.6.24-cavium/drivers/usb/host/ohci-str8100.c
+../linux-2.6.24-cavium/drivers/usb/gadget/Makefile
+../linux-2.6.24-cavium/drivers/usb/gadget/gadget_chips.h
+../linux-2.6.24-cavium/drivers/usb/gadget/file_storage.c
+../linux-2.6.24-cavium/drivers/usb/gadget/Kconfig
+../linux-2.6.24-cavium/drivers/usb/gadget/str8100_udc.c
+../linux-2.6.24-cavium/drivers/usb/gadget/str8100_udc.h
+../linux-2.6.24-cavium/drivers/star/Makefile
+../linux-2.6.24-cavium/drivers/star/str8100/int28handler.c
+../linux-2.6.24-cavium/drivers/star/str8100/Makefile
+../linux-2.6.24-cavium/drivers/star/str8100/crash.c
+../linux-2.6.24-cavium/drivers/star/str8100/str8100_gpio_test.c
+../linux-2.6.24-cavium/drivers/star/str8100/str8100_led.c
+../linux-2.6.24-cavium/drivers/star/str8100/inthandler.c
+../linux-2.6.24-cavium/drivers/watchdog/Makefile
+../linux-2.6.24-cavium/drivers/watchdog/Kconfig
+../linux-2.6.24-cavium/drivers/watchdog/str8100_ebwdt.c
+../linux-2.6.24-cavium/drivers/watchdog/str8100_wdt.c
+../linux-2.6.24-cavium/drivers/serial/Kconfig
+../linux-2.6.24-cavium/drivers/serial/8250_early.c
+../linux-2.6.24-cavium/drivers/serial/8250.c
+../linux-2.6.24-cavium/include/linux/spi/spi.h
+../linux-2.6.24-cavium/include/linux/i2c.h
+../linux-2.6.24-cavium/include/linux/ide.h
+../linux-2.6.24-cavium/include/linux/skbuff.h
+../linux-2.6.24-cavium/include/linux/sysctl.h
+../linux-2.6.24-cavium/include/asm-arm/arch-str8100/star_spi.h
+../linux-2.6.24-cavium/include/asm-arm/arch-str8100/system.h
+../linux-2.6.24-cavium/include/asm-arm/arch-str8100/star_demo_dma.h
+../linux-2.6.24-cavium/include/asm-arm/arch-str8100/memory.h
+../linux-2.6.24-cavium/include/asm-arm/pci.h
+../linux-2.6.24-cavium/kernel/sysctl_check.c
+../linux-2.6.24-cavium/net/core/skbuff.c
+../linux-2.6.24-cavium/sound/drivers/star-i2s-wm8759.c
diff -Nur linux-2.6.35.11/fs/char_dev.c linux-2.6.35.11-ts7500//fs/char_dev.c
--- linux-2.6.35.11/fs/char_dev.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//fs/char_dev.c	2011-02-26 20:32:46.000000000 -0500
@@ -568,6 +568,8 @@
 
 void __init chrdev_init(void)
 {
+   //printk("chrdev_init(), calling kobj_map_init()\n");
+   
 	cdev_map = kobj_map_init(base_probe, &chrdevs_lock);
 	bdi_init(&directly_mappable_cdev_bdi);
 }
diff -Nur linux-2.6.35.11/include/asm/arch/hardware.h linux-2.6.35.11-ts7500//include/asm/arch/hardware.h
--- linux-2.6.35.11/include/asm/arch/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/hardware.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#endif
diff -Nur linux-2.6.35.11/include/asm/arch/star_demo_dma.h linux-2.6.35.11-ts7500//include/asm/arch/star_demo_dma.h
--- linux-2.6.35.11/include/asm/arch/star_demo_dma.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_demo_dma.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,189 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef __DEMO_DMA_H__
+#define __DEMO_DMA_H__
+#include <linux/types.h>	/* size_t */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <mach/star_dmac.h>
+
+/*
+ * defines for each channel
+ */
+#define DMAC_CH_DISABLE                0
+#define DMAC_CH_ENABLE                 1
+
+#define DMAC_CH_DST_SEL_M0             0
+#define DMAC_CH_DST_SEL_M1             1
+
+#define DMAC_CH_SRC_SEL_M0             0
+#define DMAC_CH_SRC_SEL_M1             1
+
+#define DMAC_CH_DSTAD_CTL_INC          0
+#define DMAC_CH_DSTAD_CTL_DEC          1
+#define DMAC_CH_DSTAD_CTL_FIX          2
+
+#define DMAC_CH_SRCAD_CTL_INC          0
+#define DMAC_CH_SRCAD_CTL_DEC          1
+#define DMAC_CH_SRCAD_CTL_FIX          2
+
+#define DMAC_CH_MODE_HW_HANDSHAKE      1
+
+#define DMAC_CH_SRC_WIDTH_8_BITS       0
+#define DMAC_CH_SRC_WIDTH_16_BITS      1
+#define DMAC_CH_SRC_WIDTH_32_BITS      2
+
+#define DMAC_CH_DST_WIDTH_8_BITS       0
+#define DMAC_CH_DST_WIDTH_16_BITS      1
+#define DMAC_CH_DST_WIDTH_32_BITS      2
+
+#define DMAC_CH_ABT_TRANSFER           1
+
+#define DMAC_CH_PROT1_PRIVILEGED_MODE  1
+#define DMAC_CH_PROT1_USER_MODE        0
+
+#define DMAC_CH_PROT2_BUFFERABLE       1
+#define DMAC_CH_PROT2_NON_BUFFERABLE   0
+
+#define DMAC_CH_PROT3_CACHEABLE        1
+#define DMAC_CH_PROT3_NON_CACHEABLE    0
+
+#define DMAC_CH_PRI_LEVEL_0            0
+#define DMAC_CH_PRI_LEVEL_1            1
+#define DMAC_CH_PRI_LEVEL_2            2
+#define DMAC_CH_PRI_LEVEL_3            3
+
+#define DMAC_CH_TC_MASK_DISABLE        0
+#define DMAC_CH_TC_MASK_ENABLE         1
+
+#define DMAC_MAX_CHANNEL_NUM           (8)
+
+
+#define DMAC_CH0_ID                    (1 << 0)
+#define DMAC_CH1_ID                    (1 << 1)
+#define DMAC_CH2_ID                    (1 << 2)
+#define DMAC_CH3_ID                    (1 << 3)
+#define DMAC_CH4_ID                    (1 << 4)
+#define DMAC_CH5_ID                    (1 << 5)
+#define DMAC_CH6_ID                    (1 << 6)
+#define DMAC_CH7_ID                    (1 << 7)
+#define DMAC_CH_ID(idx)                (1 << idx) 
+
+#define DMAC_LITTLE_ENDIAN             (0)
+#define DMAC_BIG_ENDIAN                (1)
+
+/* 
+ * DMAC LLP Descriptor
+ */
+typedef struct _DMAC_LLP_CONTROL_    DMAC_LLP_CONTROL_T;
+
+struct _DMAC_LLP_CONTROL_
+{
+//#if (ENDIAN_MODE == LITTLE_ENDIAN)
+#if 1
+    unsigned int    tot_size              : 12;//b11-0
+    unsigned int    reserved_1            : 4; //b15-12    
+    unsigned int    dst_sel               : 1; //b16
+    unsigned int    src_sel               : 1; //b17    
+    unsigned int    dstad_ctl             : 2; //b19-18        
+    unsigned int    srcad_ctl             : 2; //b21-20        
+    unsigned int    dst_width             : 3; //b24-22
+    unsigned int    src_width             : 3; //b27-25
+    unsigned int    tc_status_mask        : 1; //b28
+    unsigned int    reserved_0            : 3; //b31-29
+
+#else
+
+
+    unsigned int    reserved_0            : 3; //b31-29
+    unsigned int    tc_status_mask        : 1; //b28
+    unsigned int    src_width             : 3; //b27-25
+    unsigned int    dst_width             : 3; //b24-22
+    unsigned int    srcad_ctl             : 2; //b21-20
+    unsigned int    dstad_ctl             : 2; //b19-18    
+    unsigned int    src_sel               : 1; //b17
+    unsigned int    dst_sel               : 1; //b16
+    unsigned int    reserved_1            : 4; //b15-12
+    unsigned int    tot_size              : 12;//b11-0
+
+
+#endif
+}; 
+
+
+/* 
+ * DMAC LLP Descriptor object
+ */
+typedef struct _DMAC_LLP_    DMAC_LLP_T;
+struct _DMAC_LLP_
+{
+    unsigned int    SrcAddr;
+    
+    unsigned int    DstAddr;
+    
+    DMAC_LLP_T     *LLP;
+
+    DMAC_LLP_CONTROL_T    Ctrl_TotSize;    
+};
+
+typedef struct _DMAC_HARDWARE_HANDSHAKE_OBJ_    DMAC_HARDWARE_HANDSHAKE_OBJ_T;
+struct _DMAC_HARDWARE_HANDSHAKE_OBJ_
+{
+    unsigned int    src_addr;                     //Src address
+    unsigned int    dst_addr;                     //Dst address
+    unsigned int    src_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dst_master;                   //0:AHB0, 1:AHB1
+    unsigned int    dstad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    srcad_ctl;                    //0:Incr, 1:Decr, 2:Fix
+    unsigned int    src_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    dst_width;                    //0:8bits, 1:16bits, 2:32bits
+    unsigned int    transfer_bytes;               //Byte Count to be transferred
+    unsigned int    channel_id;                   //0~7 for Channel0-7 selection
+    unsigned int    channel_num;                   //0~7
+    unsigned int    target_select;                //target ID
+    unsigned int    src_burst_size;               //number of transfer 
+    unsigned int    llp_addr;                     //LLP address
+
+    void * private_data;
+    DMAC_LLP_T* llp_head;
+}; 
+
+
+extern void Hal_Dmac_Configure_DMA_Handshake(DMAC_HARDWARE_HANDSHAKE_OBJ_T *dmac_obj);
+extern irqreturn_t str8100_dma_err_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs);
+//extern int str8100_i2s_init(int sampling_rate);
+extern int str8100_i2s_init(int sampling_rate,u32 i2s_sdata_width, u32 i2s_mode,
+			u32 i2s_tranfer_timing_ctrl, u32 i2s_sclk_mode);
+extern u32 Hal_Dmac_Get_Channel_Transfer_Unit_Number(u32 byte_size, u32 src_width);
+
+extern u32 I2s_Gpio_SSP_Initialise(void);
+extern void I2s_Gpio_SSP_Write(u16);
+extern void I2s_Gpio_SSP_Switch_To_Record_Data(void);
+extern void I2s_Gpio_SSP_Switcg_To_Playback_Data(void);
+
+
+#endif //#ifndef __DEMO_DMA_H__
+
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_dmac.h linux-2.6.35.11-ts7500//include/asm/arch/star_dmac.h
--- linux-2.6.35.11/include/asm/arch/star_dmac.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_dmac.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,409 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_DMAC_H_
+#define	_STAR_DMAC_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	DMAC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_GDMAC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	DMAC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_GDMAC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	DMAC_INT_STATUS_REG			DMAC_MEM_MAP_VALUE(0x000)
+
+#define	DMAC_INT_TC_STATUS_REG			DMAC_MEM_MAP_VALUE(0x004)
+#define	DMAC_INT_TC_STATUS_CLR_REG		DMAC_MEM_MAP_VALUE(0x008)
+
+#define	DMAC_INT_ERR_STATUS_REG			DMAC_MEM_MAP_VALUE(0x00C)
+#define	DMAC_INT_ERR_STATUS_CLR_REG		DMAC_MEM_MAP_VALUE(0x010)
+
+#define	DMAC_TC_STATUS_REG			DMAC_MEM_MAP_VALUE(0x014)
+#define	DMAC_ERR_STATUS_REG			DMAC_MEM_MAP_VALUE(0x018)
+
+#define	DMAC_CH_ENABLE_STATUS_REG		DMAC_MEM_MAP_VALUE(0x01C)
+#define	DMAC_CH_BUSY_STATUS_REG			DMAC_MEM_MAP_VALUE(0x020)
+
+#define	DMAC_CSR_REG				DMAC_MEM_MAP_VALUE(0x024)
+#define	DMAC_SYNC_REG				DMAC_MEM_MAP_VALUE(0x028)
+
+#define	DMAC_CH0_CSR_REG			DMAC_MEM_MAP_VALUE(0x100)
+#define	DMAC_CH0_CFG_REG			DMAC_MEM_MAP_VALUE(0x104)
+#define	DMAC_CH0_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x108)
+#define	DMAC_CH0_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x10C)
+#define	DMAC_CH0_LLP_REG			DMAC_MEM_MAP_VALUE(0x110)
+#define	DMAC_CH0_SIZE_REG			DMAC_MEM_MAP_VALUE(0x114)
+
+#define	DMAC_CH1_CSR_REG			DMAC_MEM_MAP_VALUE(0x120)
+#define	DMAC_CH1_CFG_REG			DMAC_MEM_MAP_VALUE(0x124)
+#define	DMAC_CH1_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x128)
+#define	DMAC_CH1_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x12C)
+#define	DMAC_CH1_LLP_REG			DMAC_MEM_MAP_VALUE(0x130)
+#define	DMAC_CH1_SIZE_REG			DMAC_MEM_MAP_VALUE(0x134)
+
+#define	DMAC_CH2_CSR_REG			DMAC_MEM_MAP_VALUE(0x140)
+#define	DMAC_CH2_CFG_REG			DMAC_MEM_MAP_VALUE(0x144)
+#define	DMAC_CH2_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x148)
+#define	DMAC_CH2_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x14C)
+#define	DMAC_CH2_LLP_REG			DMAC_MEM_MAP_VALUE(0x150)
+#define	DMAC_CH2_SIZE_REG			DMAC_MEM_MAP_VALUE(0x154)
+
+#define	DMAC_CH3_CSR_REG			DMAC_MEM_MAP_VALUE(0x160)
+#define	DMAC_CH3_CFG_REG			DMAC_MEM_MAP_VALUE(0x164)
+#define	DMAC_CH3_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x168)
+#define	DMAC_CH3_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x16C)
+#define	DMAC_CH3_LLP_REG			DMAC_MEM_MAP_VALUE(0x170)
+#define	DMAC_CH3_SIZE_REG			DMAC_MEM_MAP_VALUE(0x174)
+
+#define	DMAC_CH4_CSR_REG			DMAC_MEM_MAP_VALUE(0x180)
+#define	DMAC_CH4_CFG_REG			DMAC_MEM_MAP_VALUE(0x184)
+#define	DMAC_CH4_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x188)
+#define	DMAC_CH4_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x18C)
+#define	DMAC_CH4_LLP_REG			DMAC_MEM_MAP_VALUE(0x190)
+#define	DMAC_CH4_SIZE_REG			DMAC_MEM_MAP_VALUE(0x194)
+
+#define	DMAC_CH5_CSR_REG			DMAC_MEM_MAP_VALUE(0x1A0)
+#define	DMAC_CH5_CFG_REG			DMAC_MEM_MAP_VALUE(0x1A4)
+#define	DMAC_CH5_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1A8)
+#define	DMAC_CH5_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1AC)
+#define	DMAC_CH5_LLP_REG			DMAC_MEM_MAP_VALUE(0x1B0)
+#define	DMAC_CH5_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1B4)
+
+#define	DMAC_CH6_CSR_REG			DMAC_MEM_MAP_VALUE(0x1C0)
+#define	DMAC_CH6_CFG_REG			DMAC_MEM_MAP_VALUE(0x1C4)
+#define	DMAC_CH6_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1C8)
+#define	DMAC_CH6_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1CC)
+#define	DMAC_CH6_LLP_REG			DMAC_MEM_MAP_VALUE(0x1D0)
+#define	DMAC_CH6_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1D4)
+
+#define	DMAC_CH7_CSR_REG			DMAC_MEM_MAP_VALUE(0x1E0)
+#define	DMAC_CH7_CFG_REG			DMAC_MEM_MAP_VALUE(0x1E4)
+#define	DMAC_CH7_SRC_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1E8)
+#define	DMAC_CH7_DST_ADDR_REG			DMAC_MEM_MAP_VALUE(0x1EC)
+#define	DMAC_CH7_LLP_REG			DMAC_MEM_MAP_VALUE(0x1F0)
+#define	DMAC_CH7_SIZE_REG			DMAC_MEM_MAP_VALUE(0x1F4)
+
+
+#define DMAC_CH0_INT_BIT_INDEX			0
+#define DMAC_CH1_INT_BIT_INDEX			1
+#define DMAC_CH2_INT_BIT_INDEX			2
+#define DMAC_CH3_INT_BIT_INDEX			3
+#define DMAC_CH4_INT_BIT_INDEX			4
+#define DMAC_CH5_INT_BIT_INDEX			5
+#define DMAC_CH6_INT_BIT_INDEX			6
+#define DMAC_CH7_INT_BIT_INDEX			7
+
+#define DMAC_CH0_INT_TC_BIT_INDEX		0
+#define DMAC_CH1_INT_TC_BIT_INDEX		1
+#define DMAC_CH2_INT_TC_BIT_INDEX		2
+#define DMAC_CH3_INT_TC_BIT_INDEX		3
+#define DMAC_CH4_INT_TC_BIT_INDEX		4
+#define DMAC_CH5_INT_TC_BIT_INDEX		5
+#define DMAC_CH6_INT_TC_BIT_INDEX		6
+#define DMAC_CH7_INT_TC_BIT_INDEX		7
+
+#define DMAC_CH0_INT_TC_CLR_BIT_INDEX		0
+#define DMAC_CH1_INT_TC_CLR_BIT_INDEX		1
+#define DMAC_CH2_INT_TC_CLR_BIT_INDEX		2
+#define DMAC_CH3_INT_TC_CLR_BIT_INDEX		3
+#define DMAC_CH4_INT_TC_CLR_BIT_INDEX		4
+#define DMAC_CH5_INT_TC_CLR_BIT_INDEX		5
+#define DMAC_CH6_INT_TC_CLR_BIT_INDEX		6
+#define DMAC_CH7_INT_TC_CLR_BIT_INDEX		7
+
+#define DMAC_CH0_INT_ERR_BIT_INDEX		0
+#define DMAC_CH1_INT_ERR_BIT_INDEX		1
+#define DMAC_CH2_INT_ERR_BIT_INDEX		2
+#define DMAC_CH3_INT_ERR_BIT_INDEX		3
+#define DMAC_CH4_INT_ERR_BIT_INDEX		4
+#define DMAC_CH5_INT_ERR_BIT_INDEX		5
+#define DMAC_CH6_INT_ERR_BIT_INDEX		6
+#define DMAC_CH7_INT_ERR_BIT_INDEX		7
+
+#define DMAC_CH0_INT_ERR_CLR_BIT_INDEX		0
+#define DMAC_CH1_INT_ERR_CLR_BIT_INDEX		1
+#define DMAC_CH2_INT_ERR_CLR_BIT_INDEX		2
+#define DMAC_CH3_INT_ERR_CLR_BIT_INDEX		3
+#define DMAC_CH4_INT_ERR_CLR_BIT_INDEX		4
+#define DMAC_CH5_INT_ERR_CLR_BIT_INDEX		5
+#define DMAC_CH6_INT_ERR_CLR_BIT_INDEX		6
+#define DMAC_CH7_INT_ERR_CLR_BIT_INDEX		7
+
+#define DMAC_CH0_TC_STATUS_BIT_INDEX		0
+#define DMAC_CH1_TC_STATUS_BIT_INDEX		1
+#define DMAC_CH2_TC_STATUS_BIT_INDEX		2
+#define DMAC_CH3_TC_STATUS_BIT_INDEX		3
+#define DMAC_CH4_TC_STATUS_BIT_INDEX		4
+#define DMAC_CH5_TC_STATUS_BIT_INDEX		5
+#define DMAC_CH6_TC_STATUS_BIT_INDEX		6
+#define DMAC_CH7_TC_STATUS_BIT_INDEX		7
+
+#define DMAC_CH0_ERR_STATUS_BIT_INDEX		0
+#define DMAC_CH1_ERR_STATUS_BIT_INDEX		1
+#define DMAC_CH2_ERR_STATUS_BIT_INDEX		2
+#define DMAC_CH3_ERR_STATUS_BIT_INDEX		3
+#define DMAC_CH4_ERR_STATUS_BIT_INDEX		4
+#define DMAC_CH5_ERR_STATUS_BIT_INDEX		5
+#define DMAC_CH6_ERR_STATUS_BIT_INDEX		6
+#define DMAC_CH7_ERR_STATUS_BIT_INDEX		7
+
+#define DMAC_CH0_ENABLE_STATUS_BIT_INDEX	0
+#define DMAC_CH1_ENABLE_STATUS_BIT_INDEX	1
+#define DMAC_CH2_ENABLE_STATUS_BIT_INDEX	2
+#define DMAC_CH3_ENABLE_STATUS_BIT_INDEX	3
+#define DMAC_CH4_ENABLE_STATUS_BIT_INDEX	4
+#define DMAC_CH5_ENABLE_STATUS_BIT_INDEX	5
+#define DMAC_CH6_ENABLE_STATUS_BIT_INDEX	6
+#define DMAC_CH7_ENABLE_STATUS_BIT_INDEX	7
+
+#define DMAC_CH0_BUSY_STATUS_BIT_INDEX		0
+#define DMAC_CH1_BUSY_STATUS_BIT_INDEX		1
+#define DMAC_CH2_BUSY_STATUS_BIT_INDEX		2
+#define DMAC_CH3_BUSY_STATUS_BIT_INDEX		3
+#define DMAC_CH4_BUSY_STATUS_BIT_INDEX		4
+#define DMAC_CH5_BUSY_STATUS_BIT_INDEX		5
+#define DMAC_CH6_BUSY_STATUS_BIT_INDEX		6
+#define DMAC_CH7_BUSY_STATUS_BIT_INDEX		7
+
+#define DMAC_ENABLE_BIT_INDEX			0
+#define DMAC_MASTER0_ENDIAN_BIT_INDEX		1
+#define DMAC_MASTER1_ENDIAN_BIT_INDEX		2
+
+#define DMAC_CH0_SYNC_ENABLE_BIT_INDEX		0
+#define DMAC_CH1_SYNC_ENABLE_BIT_INDEX		1
+#define DMAC_CH2_SYNC_ENABLE_BIT_INDEX		2
+#define DMAC_CH3_SYNC_ENABLE_BIT_INDEX		3
+#define DMAC_CH4_SYNC_ENABLE_BIT_INDEX		4
+#define DMAC_CH5_SYNC_ENABLE_BIT_INDEX		5
+#define DMAC_CH6_SYNC_ENABLE_BIT_INDEX		6
+#define DMAC_CH7_SYNC_ENABLE_BIT_INDEX		7
+
+#define DMAC_CH_INT_TC_MASK_BIT_INDEX		0
+#define DMAC_CH_INT_ERR_MASK_BIT_INDEX		1
+#define DMAC_CH_INT_ABT_MASK_BIT_INDEX		2
+#define DMAC_CH_BUSY_BIT_INDEX			8
+
+#define DMAC_CH_ENABLE_BIT_INDEX		0
+#define DMAC_CH_DST_SEL_BIT_INDEX		1
+#define DMAC_CH_SRC_SEL_BIT_INDEX		2
+#define DMAC_CH_DST_ADDR_CTL_BIT_INDEX		3
+#define DMAC_CH_SRC_ADDR_CTL_BIT_INDEX		5
+#define DMAC_CH_MODE_BIT_INDEX			7
+#define DMAC_CH_DST_WIDTH_BIT_INDEX		8
+#define DMAC_CH_SRC_WIDTH_BIT_INDEX		11
+#define DMAC_CH_ABT_BIT_INDEX			15
+#define DMAC_CH_SRC_BURST_SIZE_BIT_INDEX	16
+#define DMAC_CH_PROTECT_MODE_BIT_INDEX		19
+#define DMAC_CH_PROTECT_BUFFERABLE_BIT_INDEX	20
+#define DMAC_CH_PROTECT_CACHEABLE_BIT_INDEX	21
+#define DMAC_CH_PRIORITY_BIT_INDEX		22
+#define DMAC_CH_HHST_SEL_BIT_INDEX		25
+
+#define DMAC_CH_DST_ADDR_CTL_MASK		0x3
+#define DMAC_CH_DST_ADDR_CTL_INC		0x0
+#define DMAC_CH_DST_ADDR_CTL_DEC		0x1
+#define DMAC_CH_DST_ADDR_CTL_FIXED		0x2
+
+#define DMAC_CH_SRC_ADDR_CTL_MASK		0x3
+#define DMAC_CH_SRC_ADDR_CTL_INC		0x0
+#define DMAC_CH_SRC_ADDR_CTL_DEC		0x1
+#define DMAC_CH_SRC_ADDR_CTL_FIXED		0x2
+
+#define DMAC_CH_MODE_NORMAL			0x0
+#define DMAC_CH_MODE_HANDSHAKE			0x1
+
+#define DMAC_CH_DST_WIDTH_MASK			0x3
+#define DMAC_CH_DST_WIDTH_8BIT			0x0
+#define DMAC_CH_DST_WIDTH_16BIT			0x1
+#define DMAC_CH_DST_WIDTH_32BIT			0x2
+
+#define DMAC_CH_SRC_WIDTH_MASK			0x3
+#define DMAC_CH_SRC_WIDTH_8BIT			0x0
+#define DMAC_CH_SRC_WIDTH_16BIT			0x1
+#define DMAC_CH_SRC_WIDTH_32BIT			0x2
+
+#define DMAC_CH_SRC_BURST_SIZE_MASK		0x8
+#define DMAC_CH_SRC_BURST_SIZE_1		0x0
+#define DMAC_CH_SRC_BURST_SIZE_4		0x1
+#define DMAC_CH_SRC_BURST_SIZE_8		0x2
+#define DMAC_CH_SRC_BURST_SIZE_16		0x3
+#define DMAC_CH_SRC_BURST_SIZE_32		0x4
+#define DMAC_CH_SRC_BURST_SIZE_64		0x5
+#define DMAC_CH_SRC_BURST_SIZE_128		0x6
+#define DMAC_CH_SRC_BURST_SIZE_256		0x7
+
+#define DMAC_CH_PRIORITY_MASK			0x4
+#define DMAC_CH_PRIORITY_0			0x0	/* lowest priority */
+#define DMAC_CH_PRIORITY_1			0x1
+#define DMAC_CH_PRIORITY_2			0x2
+#define DMAC_CH_PRIORITY_3			0x3	/* highest priority */
+
+
+#define	DMAC_CH_CSR_REG(idx)			DMAC_MEM_MAP_VALUE(0x100+0x20*(idx))
+#define	DMAC_CH_CFG_REG(idx)			DMAC_MEM_MAP_VALUE(0x104+0x20*(idx))
+#define	DMAC_CH_SRC_ADDR_REG(idx)		DMAC_MEM_MAP_VALUE(0x108+0x20*(idx))
+#define	DMAC_CH_DST_ADDR_REG(idx)		DMAC_MEM_MAP_VALUE(0x10C+0x20*(idx))
+#define	DMAC_CH_LLP_REG(idx)			DMAC_MEM_MAP_VALUE(0x110+0x20*(idx))
+#define	DMAC_CH_SIZE_REG(idx)			DMAC_MEM_MAP_VALUE(0x114+0x20*(idx))
+
+
+#define	HAL_DMAC_ENABLE_CHANNEL(idx)		((DMAC_CH_CSR_REG(idx)) |= (0x1))
+
+#define	HAL_DMAC_DISABLE_CHANNEL(idx)		((DMAC_CH_CSR_REG(idx)) &= ~(0x1))
+
+#define	HAL_GET_DMAC_CHANNEL_LLP_COUNTER(ch)	((DMAC_CH_CFG_REG(ch) >> 16) & 0xF)
+
+
+/*DMAC HW Hand-shake target ID*/
+#define	DMAC_HW_HAND_SHAKE_PCM_TX0_ID		0x0
+#define	DMAC_HW_HAND_SHAKE_PCM_RX0_ID		0x1
+
+#define	DMAC_HW_HAND_SHAKE_SPI_TX_ID		0x2
+#define	DMAC_HW_HAND_SHAKE_SPI_RX_ID		0x3
+
+#define	DMAC_HW_HAND_SHAKE_I2S_TX_LEFT_ID	0x4
+#define	DMAC_HW_HAND_SHAKE_I2S_TX_RIGHT_ID	0x5
+
+#define	DMAC_HW_HAND_SHAKE_UART0_TX_ID		0x6
+#define	DMAC_HW_HAND_SHAKE_UART0_RX_ID		0x7
+
+#define	DMAC_HW_HAND_SHAKE_UART1_TX_ID		0x8
+#define	DMAC_HW_HAND_SHAKE_UART1_RX_ID		0x9
+
+#define	DMAC_HW_HAND_SHAKE_USBDEV_ID		0xA
+
+#define	DMAC_HW_HAND_SHAKE_I2S_RX_LEFT_ID	0xB
+#define	DMAC_HW_HAND_SHAKE_I2S_RX_RIGHT_ID	0xC
+
+#define	DMAC_HW_HAND_SHAKE_PCM_TX1_ID		0xD
+#define	DMAC_HW_HAND_SHAKE_PCM_RX1_ID		0xE
+
+
+#define MAX_DMA_VEC				32
+
+#define DMAC_DST_SEL_MASTER0			0
+#define DMAC_DST_SEL_MASTER1			1
+#define DMAC_SRC_SEL_MASTER0			0
+#define DMAC_SRC_SEL_MASTER1			1
+
+#define DMAC_RESPONSE_OK			0
+#define DMAC_RESPONSE_ERR			-1
+
+struct dma_xfer;
+typedef struct dma_xfer dma_xfer_t;
+typedef void (*dma_end_io_t)(dma_xfer_t *dma_xfer, int err);
+typedef struct
+{
+	u32	src_addr;	// virtual addr
+	u32	dst_addr;	// virtual addr
+	u32	size;		// bytes
+	u8	dst_sel;
+	u8	src_sel;
+	u8	dst_addr_ctl;
+	u8	src_addr_ctl;
+	u8	dst_width;
+	u8	src_width;
+} dma_vec_t;
+
+struct dma_xfer
+{
+	u8		nr_vec;
+	dma_vec_t	vec[MAX_DMA_VEC];
+	dma_end_io_t	dma_end_io;
+	void		*private;
+};
+
+/*
+ * DMAC	LLP Descriptor
+ */
+typedef struct
+{
+	u32	src_addr;			// physical addr
+	u32	dst_addr;			// physical addr
+	u32	llp;
+	u32	tot_size	: 12;
+	u32	reserved0	: 4;
+	u32	dst_sel		: 1;
+	u32	src_sel		: 1;
+	u32	dst_addr_ctl	: 2;
+	u32	src_addr_ctl	: 2;
+	u32	dst_width	: 3;
+	u32	src_width	: 3;
+	u32	tc_mask		: 1;
+	u32	reserved1	: 3;
+} __attribute__((packed)) dma_llp_descr_t;
+
+#define HAL_DMAC_ENABLE() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_ENABLE_BIT_INDEX))
+
+
+#define HAL_DMAC_DISABLE() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_ENABLE_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER0_BIG_ENDIAN() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_MASTER0_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER0_LITTLE_ENDIAN() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_MASTER0_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER1_BIG_ENDIAN() \
+	    ((DMAC_CSR_REG) |= (1<<DMAC_MASTER1_ENDIAN_BIT_INDEX))
+
+
+#define HAL_DMAC_SET_MASTER1_LITTLE_ENDIAN() \
+	    ((DMAC_CSR_REG) &= ~(1<<DMAC_MASTER1_ENDIAN_BIT_INDEX))
+
+#define HAL_DMAC_READ_ERROR_ABORT_INTERRUPT_STATUS(err_abt_status) \
+	    ((err_abt_status) = (DMAC_INT_ERR_STATUS_REG))
+
+
+#define HAL_DMAC_CLEAR_ERROR_ABORT_INTERRUPT_STATUS(err_abt_status) \
+	    ((DMAC_INT_ERR_STATUS_CLR_REG) = (err_abt_status))
+
+
+#define HAL_DMAC_READ_TERMINAL_COUNT_INTERRUPT_STATUS(tc_status) \
+	    ((tc_status) = (DMAC_INT_TC_STATUS_REG) & 0xFF)
+
+
+#define HAL_DMAC_CLEAR_TERMINAL_COUNT_INTERRUPT_STATUS(tc_status) \
+	    ((DMAC_INT_TC_STATUS_CLR_REG) = (tc_status) & 0xFF)
+
+
+
+
+
+
+#endif	// end of #ifndef _STAR_DMAC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_gpio.h linux-2.6.35.11-ts7500//include/asm/arch/star_gpio.h
--- linux-2.6.35.11/include/asm/arch/star_gpio.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_gpio.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,327 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_GPIO_H_
+#define	_STAR_GPIO_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	GPIOA_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_GPIOA_BASE_ADDR + reg_offset)))
+#define	GPIOB_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_GPIOB_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	GPIOA_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_GPIOA_BASE_ADDR + reg_offset)))
+#define	GPIOB_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_GPIOB_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * For GPIO Set	A
+ */
+#define	GPIOA_DATA_OUTPUT_REG			GPIOA_MEM_MAP_VALUE(0x00)
+#define	GPIOA_DATA_INPUT_REG			GPIOA_MEM_MAP_VALUE(0x04)
+#define	GPIOA_DIRECTION_REG			GPIOA_MEM_MAP_VALUE(0x08)
+
+#define	GPIOA_DATA_BIT_SET_REG			GPIOA_MEM_MAP_VALUE(0x10)
+#define	GPIOA_DATA_BIT_CLEAR_REG		GPIOA_MEM_MAP_VALUE(0x14)
+
+#define	GPIOA_INTERRUPT_ENABLE_REG		GPIOA_MEM_MAP_VALUE(0x20)
+#define	GPIOA_INTERRUPT_RAW_STATUS_REG		GPIOA_MEM_MAP_VALUE(0x24)
+#define	GPIOA_INTERRUPT_MASKED_STATUS_REG	GPIOA_MEM_MAP_VALUE(0x28)
+#define	GPIOA_INTERRUPT_MASK_REG		GPIOA_MEM_MAP_VALUE(0x2C)
+#define	GPIOA_INTERRUPT_CLEAR_REG		GPIOA_MEM_MAP_VALUE(0x30)
+#define	GPIOA_INTERRUPT_TRIGGER_METHOD_REG	GPIOA_MEM_MAP_VALUE(0x34)
+#define	GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG	GPIOA_MEM_MAP_VALUE(0x38)
+#define	GPIOA_INTERRUPT_TRIGGER_TYPE_REG	GPIOA_MEM_MAP_VALUE(0x3C)
+
+#define	GPIOA_BOUNCE_ENABLE_REG			GPIOA_MEM_MAP_VALUE(0x40)
+#define	GPIOA_BOUNCE_CLOCK_PRESCALE_REG		GPIOA_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * For GPIO Set	B
+ */
+#define	GPIOB_DATA_OUTPUT_REG			GPIOB_MEM_MAP_VALUE(0x00)
+#define	GPIOB_DATA_INPUT_REG			GPIOB_MEM_MAP_VALUE(0x04)
+#define	GPIOB_DIRECTION_REG			GPIOB_MEM_MAP_VALUE(0x08)
+
+#define	GPIOB_DATA_BIT_SET_REG			GPIOB_MEM_MAP_VALUE(0x10)
+#define	GPIOB_DATA_BIT_CLEAR_REG		GPIOB_MEM_MAP_VALUE(0x14)
+
+#define	GPIOB_INTERRUPT_ENABLE_REG		GPIOB_MEM_MAP_VALUE(0x20)
+#define	GPIOB_INTERRUPT_RAW_STATUS_REG		GPIOB_MEM_MAP_VALUE(0x24)
+#define	GPIOB_INTERRUPT_MASKED_STATUS_REG	GPIOB_MEM_MAP_VALUE(0x28)
+#define	GPIOB_INTERRUPT_MASK_REG		GPIOB_MEM_MAP_VALUE(0x2C)
+#define	GPIOB_INTERRUPT_CLEAR_REG		GPIOB_MEM_MAP_VALUE(0x30)
+#define	GPIOB_INTERRUPT_TRIGGER_METHOD_REG	GPIOB_MEM_MAP_VALUE(0x34)
+#define	GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG	GPIOB_MEM_MAP_VALUE(0x38)
+#define	GPIOB_INTERRUPT_TRIGGER_TYPE_REG	GPIOB_MEM_MAP_VALUE(0x3C)
+
+#define	GPIOB_BOUNCE_ENABLE_REG			GPIOB_MEM_MAP_VALUE(0x40)
+#define	GPIOB_BOUNCE_CLOCK_PRESCALE_REG		GPIOB_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * define constant macros
+ */
+
+#define	MAX_GPIO_PINS		(32)
+
+#define	GPIO_0_MASK		(1 << 0)
+#define	GPIO_1_MASK		(1 << 1)
+#define	GPIO_2_MASK		(1 << 2)
+#define	GPIO_3_MASK		(1 << 3)
+#define	GPIO_4_MASK		(1 << 4)
+#define	GPIO_5_MASK		(1 << 5)
+#define	GPIO_6_MASK		(1 << 6)
+#define	GPIO_7_MASK		(1 << 7)
+#define	GPIO_8_MASK		(1 << 8)
+#define	GPIO_9_MASK		(1 << 9)
+#define	GPIO_10_MASK		(1 << 10)
+#define	GPIO_11_MASK		(1 << 11)
+#define	GPIO_12_MASK		(1 << 12)
+#define	GPIO_13_MASK		(1 << 13)
+#define	GPIO_14_MASK		(1 << 14)
+#define	GPIO_15_MASK		(1 << 15)
+#define	GPIO_16_MASK		(1 << 16)
+#define	GPIO_17_MASK		(1 << 17)
+#define	GPIO_18_MASK		(1 << 18)
+#define	GPIO_19_MASK		(1 << 19)
+#define	GPIO_20_MASK		(1 << 20)
+#define	GPIO_21_MASK		(1 << 21)
+#define	GPIO_22_MASK		(1 << 22)
+#define	GPIO_23_MASK		(1 << 23)
+#define	GPIO_24_MASK		(1 << 24)
+#define	GPIO_25_MASK		(1 << 25)
+#define	GPIO_26_MASK		(1 << 26)
+#define	GPIO_27_MASK		(1 << 27)
+#define	GPIO_28_MASK		(1 << 28)
+#define	GPIO_29_MASK		(1 << 29)
+#define	GPIO_30_MASK		(1 << 30)
+#define	GPIO_31_MASK		(1 << 31)
+
+
+/*
+ * macro declarations for GPIO Set A
+ */
+#define	HAL_GPIOA_READ_DATA_OUT_STATUS(data_out_state) \
+    ((data_out_state) =	(GPIOA_DATA_OUTPUT_REG))
+
+#define	HAL_GPIOA_READ_DATA_IN_STATUS(data_in_state) \
+    ((data_in_state) = (GPIOA_DATA_INPUT_REG))
+
+#define	HAL_GPIOA_SET_DIRECTION_OUTPUT(gpio_index) \
+    ((GPIOA_DIRECTION_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_SET_DIRECTION_INPUT(gpio_index) \
+    ((GPIOA_DIRECTION_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_SET_DATA_OUT_HIGH(gpio_index)	\
+    ((GPIOA_DATA_BIT_SET_REG) =	(gpio_index))
+
+#define	HAL_GPIOA_SET_DATA_OUT_LOW(gpio_index) \
+    ((GPIOA_DATA_BIT_CLEAR_REG)	= (gpio_index))
+
+#define	HAL_GPIOA_ENABLE_INTERRUPT(gpio_index) \
+    ((GPIOA_INTERRUPT_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_DISABLE_INTERRUPT(gpio_index)	\
+    ((GPIOA_INTERRUPT_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_READ_INTERRUPT_RAW_STATUS(raw_state) \
+    ((raw_state) = (GPIOA_INTERRUPT_RAW_STATUS_REG))
+
+#define	HAL_GPIOA_READ_INTERRUPT_MASKED_STATUS(masked_raw_state) \
+    ((masked_raw_state)	= (GPIOA_INTERRUPT_MASKED_STATUS_REG))
+
+#define	HAL_GPIOA_DISABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOA_INTERRUPT_MASK_REG)	&= ~(gpio_index))
+
+#define	HAL_GPIOA_ENABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOA_INTERRUPT_MASK_REG)	|= (gpio_index))
+
+#define	HAL_GPIOA_CLEAR_INTERRUPT(gpio_index) \
+    ((GPIOA_INTERRUPT_CLEAR_REG) = (gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_EDGE_TRIGGER_MODE(gpio_index) \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_LEVEL_TRIGGER_MODE(gpio_index) \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) |= (gpio_index));	\
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOA_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOA_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOA_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOA_ENABLE_BOUNCE(gpio_index) \
+    ((GPIOA_BOUNCE_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOA_DISABLE_BOUNCE(gpio_index) \
+    ((GPIOA_BOUNCE_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOA_READ_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((prescale_ratio) =	((GPIOA_BOUNCE_CLOCK_PRESCALE_REG) & 0x0000FFFF))
+
+#define	HAL_GPIOA_WRITE_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((GPIOA_BOUNCE_CLOCK_PRESCALE_REG) = (prescale_ratio & 0x0000FFFF))
+
+
+
+/*
+ * macro declarations for GPIO Set B
+ */
+#define	HAL_GPIOB_READ_DATA_OUT_STATUS(data_out_state) \
+    ((data_out_state) =	(GPIOB_DATA_OUTPUT_REG))
+
+#define	HAL_GPIOB_READ_DATA_IN_STATUS(data_in_state) \
+    ((data_in_state) = (GPIOB_DATA_INPUT_REG))
+
+#define	HAL_GPIOB_SET_DIRECTION_OUTPUT(gpio_index) \
+    ((GPIOB_DIRECTION_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_SET_DIRECTION_INPUT(gpio_index) \
+    ((GPIOB_DIRECTION_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_SET_DATA_OUT_HIGH(gpio_index)	\
+    ((GPIOB_DATA_BIT_SET_REG) =	(gpio_index))
+
+#define	HAL_GPIOB_SET_DATA_OUT_LOW(gpio_index) \
+    ((GPIOB_DATA_BIT_CLEAR_REG)	= (gpio_index))
+
+#define	HAL_GPIOB_ENABLE_INTERRUPT(gpio_index) \
+    ((GPIOB_INTERRUPT_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_DISABLE_INTERRUPT(gpio_index)	\
+    ((GPIOB_INTERRUPT_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_READ_INTERRUPT_RAW_STATUS(raw_state) \
+    ((raw_state) = (GPIOB_INTERRUPT_RAW_STATUS_REG))
+
+#define	HAL_GPIOB_READ_INTERRUPT_MASKED_STATUS(masked_raw_state) \
+    ((masked_raw_state)	= (GPIOB_INTERRUPT_MASKED_STATUS_REG))
+
+#define	HAL_GPIOB_DISABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOB_INTERRUPT_MASK_REG)	&= ~(gpio_index))
+
+#define	HAL_GPIOB_ENABLE_INTERRUPT_MASK(gpio_index) \
+    ((GPIOB_INTERRUPT_MASK_REG)	|= (gpio_index))
+
+#define	HAL_GPIOB_CLEAR_INTERRUPT(gpio_index) \
+    ((GPIOB_INTERRUPT_CLEAR_REG) = (gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_EDGE_TRIGGER_MODE(gpio_index) \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_LEVEL_TRIGGER_MODE(gpio_index) \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_BOTH_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) |= (gpio_index));	\
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_RISING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_SINGLE_FALLING_EDGE_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_BOTH_EDGES_REG) &= ~(gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_HIGH_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	&= ~(gpio_index)); \
+}
+
+#define	HAL_GPIOB_SET_INTERRUPT_LOW_LEVEL_TRIGGER_MODE(gpio_index) \
+{ \
+    ((GPIOB_INTERRUPT_TRIGGER_METHOD_REG) |= (gpio_index)); \
+    ((GPIOB_INTERRUPT_TRIGGER_TYPE_REG)	|= (gpio_index)); \
+}
+
+#define	HAL_GPIOB_ENABLE_BOUNCE(gpio_index) \
+    ((GPIOB_BOUNCE_ENABLE_REG) |= (gpio_index))
+
+#define	HAL_GPIOB_DISABLE_BOUNCE(gpio_index) \
+    ((GPIOB_BOUNCE_ENABLE_REG) &= ~(gpio_index))
+
+#define	HAL_GPIOB_READ_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((prescale_ratio) =	((GPIOB_BOUNCE_CLOCK_PRESCALE_REG) & 0x0000FFFF))
+
+#define	HAL_GPIOB_WRITE_BOUNCE_PRESCALE_RATIO(prescale_ratio) \
+    ((GPIOB_BOUNCE_CLOCK_PRESCALE_REG) = (prescale_ratio & 0x0000FFFF))
+
+
+#endif	// end of _STAR_GPIO_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_hsdmac.h linux-2.6.35.11-ts7500//include/asm/arch/star_hsdmac.h
--- linux-2.6.35.11/include/asm/arch/star_hsdmac.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_hsdmac.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,106 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_HSDMAC_H_
+#define	_STAR_HSDMAC_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	HSDMAC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_MISC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	HSDMAC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_MISC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	HSDMAC_CONTROL_STATUS_REG		HSDMAC_MEM_MAP_VALUE(0x040)
+
+#define	HSDMAC_MASTER0_ADDR_REG			HSDMAC_MEM_MAP_VALUE(0x050)
+
+#define	HSDMAC_MASTER1_ADDR_REG			HSDMAC_MEM_MAP_VALUE(0x054)
+
+#define	HSDMAC_LLP_REG				HSDMAC_MEM_MAP_VALUE(0x058)
+
+#define	HSDMAC_TOT_SIZE_REG			HSDMAC_MEM_MAP_VALUE(0x05C)
+
+
+#define	HAL_GET_HSDMAC_LLP_COUNTER		((HSDMAC_CONTROL_STATUS_REG >> 8) & 0xF)
+
+#define	HAL_HSDMAC_ENABLE()			((HSDMAC_CONTROL_STATUS_REG) |= (0x1))
+
+#define	HAL_HSDMAC_DISABLE()			((HSDMAC_CONTROL_STATUS_REG) &= ~(0x1))
+
+
+#define HSDMAC_MASTER0_TO_MASTER1		0
+#define HSDMAC_MASTER1_TO_MASTER0		1
+
+#define HSDMAC_RESPONSE_OK			0
+#define HSDMAC_RESPONSE_ERR			-1
+
+#define MAX_HSDMA_VEC 				32
+
+#define MAX_HSDMA_XFER_SIZE			(0xFFF << 2)
+
+struct hsdma_xfer;
+typedef struct hsdma_xfer hsdma_xfer_t;
+typedef void (*hsdma_end_io_t)(hsdma_xfer_t *hsdma_xfer, int err);
+typedef struct
+{
+	u8	data_direction;
+	u32	src_addr; // virtual
+	u32	dst_addr; // virtual
+	u32	size; // bytes
+} __attribute__((packed)) hsdma_vec_t;
+
+struct hsdma_xfer
+{
+	u8			nr_vec;
+	hsdma_vec_t		vec[MAX_HSDMA_VEC];
+	hsdma_end_io_t		hsdma_end_io;
+	void			*private;
+};
+
+/*
+ * HSDMAC LLP Descriptor object
+ */
+typedef struct
+{
+	u32	src_addr; // physical
+	u32	dst_addr; // physical
+	u32	llp;
+	u32	tot_size	: 16;//b15-b0
+	u32	reserved0	: 12;//b27-b16
+	u32	tc_mask		: 1; //b28
+	u32	data_direction	: 1; //b29
+	u32	reserved1	: 2; //b31-30
+} __attribute__((packed)) hsdma_llp_descr_t;
+
+
+#endif	// end of #ifndef _STAR_HSDMAC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_i2c.h linux-2.6.35.11-ts7500//include/asm/arch/star_i2c.h
--- linux-2.6.35.11/include/asm/arch/star_i2c.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_i2c.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_I2C_H_
+#define _STAR_I2C_H_
+
+#include <mach/star_sys_memory_map.h>
+
+#define I2C_MEM_MAP_ADDR(reg_offset)          (SYSVA_I2C_BASE_ADDR + reg_offset) 
+#define I2C_MEM_MAP_VALUE(reg_offset)         (*((unsigned int volatile *)I2C_MEM_MAP_ADDR(reg_offset)))
+
+#define I2C_CONTROLLER_REG_ADDR               I2C_MEM_MAP_ADDR(0x20)
+#define I2C_TIME_OUT_REG_ADDR                 I2C_MEM_MAP_ADDR(0x24)
+#define I2C_SLAVE_ADDRESS_REG_ADDR            I2C_MEM_MAP_ADDR(0x28)
+#define I2C_WRITE_DATA_REG_ADDR               I2C_MEM_MAP_ADDR(0x2C)
+#define I2C_READ_DATA_REG_ADDR                I2C_MEM_MAP_ADDR(0x30)
+#define I2C_INTERRUPT_STATUS_REG_ADDR         I2C_MEM_MAP_ADDR(0x34)
+#define I2C_INTERRUPT_ENABLE_REG_ADDR         I2C_MEM_MAP_ADDR(0x38)
+
+#define I2C_CONTROLLER_REG                    I2C_MEM_MAP_VALUE(0x20)
+#define I2C_TIME_OUT_REG                      I2C_MEM_MAP_VALUE(0x24)
+#define I2C_SLAVE_ADDRESS_REG                 I2C_MEM_MAP_VALUE(0x28)
+#define I2C_WRITE_DATA_REG                    I2C_MEM_MAP_VALUE(0x2C)
+#define I2C_READ_DATA_REG                     I2C_MEM_MAP_VALUE(0x30)
+#define I2C_INTERRUPT_STATUS_REG              I2C_MEM_MAP_VALUE(0x34)
+#define I2C_INTERRUPT_ENABLE_REG              I2C_MEM_MAP_VALUE(0x38)
+
+#define I2C_READ_ONLY_CMD      (0)
+#define I2C_WRITE_ONLY_CMD     (1)
+#define I2C_WRITE_READ_CMD     (2)
+#define I2C_READ_WRITE_CMD     (3)
+
+#define I2C_DATA_LEN_1_BYTE    (0)
+#define I2C_DATA_LEN_2_BYTE    (1)
+#define I2C_DATA_LEN_3_BYTE    (2)
+#define I2C_DATA_LEN_4_BYTE    (3)
+
+#define I2C_BUS_ERROR_FLAG     (0x1)
+#define I2C_ACTION_DONE_FLAG   (0x2)
+
+#define HAL_I2C_ENABLE_I2C()          (I2C_CONTROLLER_REG) |= ((unsigned int)0x1 << 31); 
+#define HAL_I2C_DISABLE_I2C()         (I2C_CONTROLLER_REG) &= ~((unsigned int)0x1 << 31);
+#define HAL_I2C_ENABLE_DATA_SWAP()    (I2C_CONTROLLER_REG) |= (0x1 << 24); 
+#define HAL_I2C_DISABLE_DATA_SWAP()   (I2C_CONTROLLER_REG) &= ~(0x1 << 24); 
+#define HAL_I2C_START_TRANSFER()      (I2C_CONTROLLER_REG) |= (0x1 << 6); 
+#define HAL_I2C_STOP_TRANSFER()       (I2C_CONTROLLER_REG) &= ~(0x1 << 6); 
+
+#endif
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_i2s.h linux-2.6.35.11-ts7500//include/asm/arch/star_i2s.h
--- linux-2.6.35.11/include/asm/arch/star_i2s.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_i2s.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,176 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_I2S_H_
+#define _STAR_I2S_H_
+
+/******************************************************************************
+ * MODULE NAME:    star_i2s.h
+ * PROJECT CODE:   Orion
+ * DESCRIPTION:    
+ * MAINTAINER:     MJLIU
+ * DATE:           15 September 2005
+ *
+ * SOURCE CONTROL: 
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  MJLIU	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include <mach/star_sys_memory_map.h>
+
+#define I2S_MEM_MAP_ADDR(reg_offset)          (SYSVA_I2S_BASE_ADDR + reg_offset) 
+#define I2S_MEM_MAP_VALUE(reg_offset)         (*((unsigned int volatile *)I2S_MEM_MAP_ADDR(reg_offset)))
+
+//#define I2S_BASE_ADDR                         (SYS_I2S_BASE_ADDR)
+
+
+/*
+ * define access macros
+ */
+#define I2S_CONFIGURATION_REG_ADDR            I2S_MEM_MAP_ADDR(0xC0)
+#define I2S_RIGHT_TRANSMIT_DATA_REG_ADDR      I2S_MEM_MAP_ADDR(0xC4)
+#define I2S_LEFT_TRANSMIT_DATA_REG_ADDR       I2S_MEM_MAP_ADDR(0xC8)
+#define I2S_RIGHT_RECEIVE_DATA_REG_ADDR       I2S_MEM_MAP_ADDR(0xCC)
+#define I2S_LEFT_RECEIVE_DATA_REG_ADDR        I2S_MEM_MAP_ADDR(0xD0)
+#define I2S_INTERRUPT_STATUS_REG_ADDR         I2S_MEM_MAP_ADDR(0xD4)
+#define I2S_INTERRUPT_ENABLE_REG_ADDR         I2S_MEM_MAP_ADDR(0xD8)
+
+#define I2S_CONFIGURATION_REG                 I2S_MEM_MAP_VALUE(0xC0)
+#define I2S_RIGHT_TRANSMIT_DATA_REG           I2S_MEM_MAP_VALUE(0xC4)
+#define I2S_LEFT_TRANSMIT_DATA_REG            I2S_MEM_MAP_VALUE(0xC8)
+#define I2S_RIGHT_RECEIVE_DATA_REG            I2S_MEM_MAP_VALUE(0xCC)
+#define I2S_LEFT_RECEIVE_DATA_REG             I2S_MEM_MAP_VALUE(0xD0)
+#define I2S_INTERRUPT_STATUS_REG              I2S_MEM_MAP_VALUE(0xD4)
+#define I2S_INTERRUPT_ENABLE_REG              I2S_MEM_MAP_VALUE(0xD8)
+
+
+/*
+ * define constants macros
+ */
+#define I2S_DATA_16_BIT             (0)
+#define I2S_DATA_32_BIT             (1)
+
+#define I2S_RXBF_R_FULL_FLAG        (0x01)
+#define I2S_TXBF_R_EMPTY_FLAG       (0x02)
+#define I2S_RXBF_L_FULL_FLAG        (0x04)
+#define I2S_TXBF_L_EMPTY_FLAG       (0x08)
+
+#define I2S_RXBF_R_OR_FLAG          (0x10)
+#define I2S_TXBF_R_UR_FLAG          (0x20)
+#define I2S_RXBF_L_OR_FLAG          (0x40)
+#define I2S_TXBF_L_UR_FLAG          (0x80)
+
+
+#define I2S_MASTER_MODE             (1)
+#define I2S_SLAVE_MODE              (0)
+
+#define I2S_I2S_MODE                (1)
+#define I2S_RJF_MODE                (2)
+#define I2S_LJF_MODE                (3)
+
+#define I2S_CLOCK_CONTINUOUS_MODE   (0)
+#define I2S_CLOCK_256S_MODE         (1)
+
+
+#define I2S_WS_RATE_32KHZ           (1)    /* 8.192 MHz */
+#define I2S_WS_RATE_44_1KHZ         (2)    /* 11.2896 MHz */
+#define I2S_WS_RATE_48KHZ           (3)    /* 12.288 MHz */
+
+
+/*
+ * define data structure
+ */
+#if 0
+typedef struct _I2S_OBJECT_    I2S_OBJECT_T;
+
+struct _I2S_OBJECT_
+{
+    u_int32          config;
+    u_int32          interrupt_config;
+
+
+    /* 
+     * For interrupt setting
+     */
+    INTC_OBJECT_T    intc_obj;
+};
+
+
+/*
+ * function declarations
+ */
+void    Hal_I2s_Initialize(I2S_OBJECT_T *);
+#endif
+
+
+/*
+ * macro declarations
+ */
+#define HAL_I2S_ENABLE_I2S() \
+{ \
+    (I2S_CONFIGURATION_REG) |= ((u32)0x1 << 31); \
+}
+
+#define HAL_I2S_DISABLE_I2S() \
+{ \
+    (I2S_CONFIGURATION_REG) &= ~((u32)0x1 << 31); \
+}
+
+#define HAL_I2S_ENABLE_DATA_SWAP() \
+{ \
+    (I2S_CONFIGURATION_REG) |= (0x1 << 24); \
+}
+
+#define HAL_I2S_DISABLE_DATA_SWAP() \
+{ \
+    (I2S_CONFIGURATION_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_I2S_DISABLE_LEFT_CHANNEL_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_TXBF_L_UR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_RIGHT_CHANNEL_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_TXBF_R_UR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_LEFT_CHANNEL_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_RXBF_L_OR_FLAG); \
+}
+
+#define HAL_I2S_DISABLE_RIGHT_CHANNEL_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (I2S_INTERRUPT_ENABLE_REG) &= ~(I2S_RXBF_R_OR_FLAG); \
+}
+
+
+#endif  // end of #ifndef _STAR_I2S_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_ide.h linux-2.6.35.11-ts7500//include/asm/arch/star_ide.h
--- linux-2.6.35.11/include/asm/arch/star_ide.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_ide.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,245 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_IDE_H_
+#define	_STAR_IDE_H_
+
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	IDE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_IDE_CONTROLLER_BASE_ADDR + reg_offset)))
+#define	IDE_BUS_MEM_MAP_VALUE(reg_offset)	(*((u8 volatile *)(SYSPA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#define IDE_DATA_MEM_MAP_VALUE(reg_offset)	(*((u16 volatile *)(SYSPA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	IDE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_IDE_CONTROLLER_BASE_ADDR + reg_offset)))
+#define	IDE_BUS_MEM_MAP_VALUE(reg_offset)	(*((u8 volatile *)(SYSVA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#define IDE_DATA_MEM_MAP_VALUE(reg_offset)	(*((u16 volatile *)(SYSVA_IDE_DEVICE_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * IDE Controller Registers
+ */
+#define IDE_PIO_CONTROL_REG			IDE_MEM_MAP_VALUE(0x00)
+#define IDE_DRIVE0_PIO_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x04)
+#define IDE_DRIVE1_PIO_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x08)
+#define IDE_DRIVE0_DMA_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x0C)
+#define IDE_DRIVE1_DMA_TIMING_CONFIG_REG	IDE_MEM_MAP_VALUE(0x10)
+#define IDE_UDMA_TIMING_CONFIG_REG		IDE_MEM_MAP_VALUE(0x14)
+#define IDE_DMA_UDMA_CONTROL_REG		IDE_MEM_MAP_VALUE(0x18)
+#define IDE_STATUS_CONTROL_REG			IDE_MEM_MAP_VALUE(0x1C)
+#define IDE_BUS_MASTER_DTP_REG			IDE_MEM_MAP_VALUE(0x20)
+#define IDE_FAST_PATH_ACCESS_WINDOW_REG		IDE_MEM_MAP_VALUE(0x24)
+#define IDE_FAST_PATH_DMA_BURST_SIZE_REG	IDE_MEM_MAP_VALUE(0x28)
+
+
+/*
+ * IDE Command Block Registers
+ */
+#define _IDE_DATA_REG				IDE_DATA_MEM_MAP_VALUE(0x20)
+#define _IDE_ERROR_REG				IDE_BUS_MEM_MAP_VALUE(0x24)
+#define _IDE_FEATURES_REG			IDE_BUS_MEM_MAP_VALUE(0x24)
+#define _IDE_SECTOR_COUNT_REG			IDE_BUS_MEM_MAP_VALUE(0x28)
+#define _IDE_LBA_LOW_REG			IDE_BUS_MEM_MAP_VALUE(0x2C)
+#define _IDE_LBA_MID_REG			IDE_BUS_MEM_MAP_VALUE(0x30)
+#define _IDE_LBA_HIGH_REG			IDE_BUS_MEM_MAP_VALUE(0x34)
+#define _IDE_DEVICE_REG				IDE_BUS_MEM_MAP_VALUE(0x38)
+#define _IDE_COMMAND_REG			IDE_BUS_MEM_MAP_VALUE(0x3C)
+#define _IDE_STATUS_REG				IDE_BUS_MEM_MAP_VALUE(0x3C)
+
+
+/*
+ * IDE Control Block Registers
+ */
+#define IDE_DEVICE_CONTROL_REG			IDE_BUS_MEM_MAP_VALUE(0x40)
+#define IDE_ALTERNATE_STATUS_REG		IDE_BUS_MEM_MAP_VALUE(0x40)
+
+
+#define IDE_CD					(0x01)
+#define IDE_IO					(0x02)
+#define IDE_REL					(0x04)
+#define IDE_OVL					(0x02)
+#define IDE_BSY					(0x80)
+#define IDE_DRQ					(0x08)
+#define IDE_SERV				(0x10)
+#define IDE_DMRD				(0x20)
+#define IDE_ERR					(0x01)
+#define IDE_SRST				(0x04)
+
+/*
+ * macro declarations for IDE Controller
+ */
+#define HAL_IDE_DRIVE0_IORDY_SAMPLE_ENABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) |= (0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE0_IORDY_SAMPLE_DISABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE1_IORDY_SAMPLE_ENABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) |= (0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE1_IORDY_SAMPLE_DISABLE() \
+{ \
+    (IDE_PIO_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE0_UDMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 0); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_IDE_DRIVE0_UDMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE1_UDMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 1); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_DRIVE1_UDMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_DRIVE0_DMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 2); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_IDE_DRIVE0_DMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_IDE_DRIVE1_DMA_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 3); \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_IDE_TO_USB_FAST_PATH_ENABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) |= (0x1 << 4); \
+}
+
+#define HAL_IDE_TO_USB_FAST_PATH_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 4); \
+}
+
+#define HAL_IDE_DRIVE1_DMA_DISABLE() \
+{ \
+    (IDE_DMA_UDMA_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_DMA_UDMA_START() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1); \
+}
+
+#define HAL_IDE_DMA_UDMA_STOP() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1); \
+}
+
+#define HAL_IDE_CLEAR_PRD_INTERRUPT_STATUS() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 2); \
+}
+
+#define HAL_IDE_CLEAR_INTRQ_INTERRUPT_STATUS() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 1); \
+}
+
+#define HAL_IDE_HOST_TRANSFER_WRITE_OUT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 3); \
+}
+
+#define HAL_IDE_HOST_TRANSFER_READ_IN() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_IDE_MASK_PRD_INTERRUPT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) |= (0x1 << 6); \
+}
+
+#define HAL_IDE_UNMASK_PRD_INTERRUPT() \
+{ \
+    (IDE_STATUS_CONTROL_REG) &= ~(0x1 << 6); \
+}
+
+#define HAL_IDE_SET_DESCRIPTOR_TABLE_POINTER(dtp) \
+{ \
+    (IDE_BUS_MASTER_DTP_REG) = (dtp); \
+}
+
+#define HAL_IDE_SET_FAST_PATH_ACCESS_WINDOW(fp_access_window) \
+{ \
+    (IDE_FAST_PATH_ACCESS_WINDOW_REG) = (fp_access_window); \
+}
+
+/*
+ * macro declarations for IDE Device
+ */
+#define HAL_IDE_SELECT_DEVICE_0() \
+{ \
+    (_IDE_DEVICE_REG) = 0; \
+}
+
+#define HAL_IDE_SELECT_DEVICE_1() \
+{ \
+    (_IDE_DEVICE_REG) = (0x1 << 4); \
+}
+
+#define HAL_IDE_ENABLE_DEVICE_INTRQ() \
+{ \
+    (IDE_DEVICE_CONTROL_REG) = (0); \
+}
+
+#define HAL_IDE_DISABLE_DEVICE_INTRQ() \
+{ \
+    (IDE_DEVICE_CONTROL_REG) = (0x2); \
+}
+
+
+#endif  // end of #ifndef _STAR_IDE_H_
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_intc.h linux-2.6.35.11-ts7500//include/asm/arch/star_intc.h
--- linux-2.6.35.11/include/asm/arch/star_intc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_intc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,328 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_INTC_H_
+#define	_STAR_INTC_H_
+
+
+//#include <mach/star_sys_memory_map.h>
+#include <mach/star_sys_memory_map.h>
+
+#if defined(__UBOOT__)
+#define	INTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_VIC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	INTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_VIC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	INTC_INTERRUPT_RAW_STATUS_REG		INTC_MEM_MAP_VALUE(0x000)
+#define	INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG	INTC_MEM_MAP_VALUE(0x004)
+#define	INTC_INTERRUPT_MASK_REG			INTC_MEM_MAP_VALUE(0x008)
+#define	INTC_INTERRUPT_MASK_CLEAR_REG		INTC_MEM_MAP_VALUE(0x00C)
+#define	INTC_INTERRUPT_TRIGGER_MODE_REG		INTC_MEM_MAP_VALUE(0x010)
+#define	INTC_INTERRUPT_TRIGGER_LEVEL_REG	INTC_MEM_MAP_VALUE(0x014)
+#define	INTC_FIQ_SELECT_REG			INTC_MEM_MAP_VALUE(0x018)
+#define	INTC_IRQ_STATUS_REG			INTC_MEM_MAP_VALUE(0x01C)
+#define	INTC_FIQ_STATUS_REG			INTC_MEM_MAP_VALUE(0x020)
+#define	INTC_SOFTWARE_INTERRUPT_REG		INTC_MEM_MAP_VALUE(0x024)
+#define	INTC_SOFTWARE_INTERRUPT_CLEAR_REG	INTC_MEM_MAP_VALUE(0x028)
+#define	INTC_SOFTWARE_PRIORITY_MASK_REG		INTC_MEM_MAP_VALUE(0x02C)
+#define	INTC_POWER_MANAGEMENT_INTERRUPT_REG	INTC_MEM_MAP_VALUE(0x034)
+
+#define	INTC_VECTOR_ADDRESS_0_REG		INTC_MEM_MAP_VALUE(0x040)
+#define	INTC_VECTOR_ADDRESS_1_REG		INTC_MEM_MAP_VALUE(0x044)
+#define	INTC_VECTOR_ADDRESS_2_REG		INTC_MEM_MAP_VALUE(0x048)
+#define	INTC_VECTOR_ADDRESS_3_REG		INTC_MEM_MAP_VALUE(0x04C)
+#define	INTC_VECTOR_ADDRESS_4_REG		INTC_MEM_MAP_VALUE(0x050)
+#define	INTC_VECTOR_ADDRESS_5_REG		INTC_MEM_MAP_VALUE(0x054)
+#define	INTC_VECTOR_ADDRESS_6_REG		INTC_MEM_MAP_VALUE(0x058)
+#define	INTC_VECTOR_ADDRESS_7_REG		INTC_MEM_MAP_VALUE(0x05C)
+#define	INTC_VECTOR_ADDRESS_8_REG		INTC_MEM_MAP_VALUE(0x060)
+#define	INTC_VECTOR_ADDRESS_9_REG		INTC_MEM_MAP_VALUE(0x064)
+#define	INTC_VECTOR_ADDRESS_10_REG		INTC_MEM_MAP_VALUE(0x068)
+#define	INTC_VECTOR_ADDRESS_11_REG		INTC_MEM_MAP_VALUE(0x06C)
+#define	INTC_VECTOR_ADDRESS_12_REG		INTC_MEM_MAP_VALUE(0x070)
+#define	INTC_VECTOR_ADDRESS_13_REG		INTC_MEM_MAP_VALUE(0x074)
+#define	INTC_VECTOR_ADDRESS_14_REG		INTC_MEM_MAP_VALUE(0x078)
+#define	INTC_VECTOR_ADDRESS_15_REG		INTC_MEM_MAP_VALUE(0x07C)
+#define	INTC_VECTOR_ADDRESS_16_REG		INTC_MEM_MAP_VALUE(0x080)
+#define	INTC_VECTOR_ADDRESS_17_REG		INTC_MEM_MAP_VALUE(0x084)
+#define	INTC_VECTOR_ADDRESS_18_REG		INTC_MEM_MAP_VALUE(0x088)
+#define	INTC_VECTOR_ADDRESS_19_REG		INTC_MEM_MAP_VALUE(0x08C)
+#define	INTC_VECTOR_ADDRESS_20_REG		INTC_MEM_MAP_VALUE(0x090)
+#define	INTC_VECTOR_ADDRESS_21_REG		INTC_MEM_MAP_VALUE(0x094)
+#define	INTC_VECTOR_ADDRESS_22_REG		INTC_MEM_MAP_VALUE(0x098)
+#define	INTC_VECTOR_ADDRESS_23_REG		INTC_MEM_MAP_VALUE(0x09C)
+#define	INTC_VECTOR_ADDRESS_24_REG		INTC_MEM_MAP_VALUE(0x0A0)
+#define	INTC_VECTOR_ADDRESS_25_REG		INTC_MEM_MAP_VALUE(0x0A4)
+#define	INTC_VECTOR_ADDRESS_26_REG		INTC_MEM_MAP_VALUE(0x0A8)
+#define	INTC_VECTOR_ADDRESS_27_REG		INTC_MEM_MAP_VALUE(0x0AC)
+#define	INTC_VECTOR_ADDRESS_28_REG		INTC_MEM_MAP_VALUE(0x0B0)
+#define	INTC_VECTOR_ADDRESS_29_REG		INTC_MEM_MAP_VALUE(0x0B4)
+#define	INTC_VECTOR_ADDRESS_30_REG		INTC_MEM_MAP_VALUE(0x0B8)
+#define	INTC_VECTOR_ADDRESS_31_REG		INTC_MEM_MAP_VALUE(0x0BC)
+
+#define	INTC_INTERRUPT_PRIORITY_0_REG		INTC_MEM_MAP_VALUE(0x0C0)
+#define	INTC_INTERRUPT_PRIORITY_1_REG		INTC_MEM_MAP_VALUE(0x0C4)
+#define	INTC_INTERRUPT_PRIORITY_2_REG		INTC_MEM_MAP_VALUE(0x0C8)
+#define	INTC_INTERRUPT_PRIORITY_3_REG		INTC_MEM_MAP_VALUE(0x0CC)
+#define	INTC_INTERRUPT_PRIORITY_4_REG		INTC_MEM_MAP_VALUE(0x0D0)
+#define	INTC_INTERRUPT_PRIORITY_5_REG		INTC_MEM_MAP_VALUE(0x0D4)
+#define	INTC_INTERRUPT_PRIORITY_6_REG		INTC_MEM_MAP_VALUE(0x0D8)
+#define	INTC_INTERRUPT_PRIORITY_7_REG		INTC_MEM_MAP_VALUE(0x0DC)
+#define	INTC_INTERRUPT_PRIORITY_8_REG		INTC_MEM_MAP_VALUE(0x0E0)
+#define	INTC_INTERRUPT_PRIORITY_9_REG		INTC_MEM_MAP_VALUE(0x0E4)
+#define	INTC_INTERRUPT_PRIORITY_10_REG		INTC_MEM_MAP_VALUE(0x0E8)
+#define	INTC_INTERRUPT_PRIORITY_11_REG		INTC_MEM_MAP_VALUE(0x0EC)
+#define	INTC_INTERRUPT_PRIORITY_12_REG		INTC_MEM_MAP_VALUE(0x0F0)
+#define	INTC_INTERRUPT_PRIORITY_13_REG		INTC_MEM_MAP_VALUE(0x0F4)
+#define	INTC_INTERRUPT_PRIORITY_14_REG		INTC_MEM_MAP_VALUE(0x0F8)
+#define	INTC_INTERRUPT_PRIORITY_15_REG		INTC_MEM_MAP_VALUE(0x0FC)
+#define	INTC_INTERRUPT_PRIORITY_16_REG		INTC_MEM_MAP_VALUE(0x100)
+#define	INTC_INTERRUPT_PRIORITY_17_REG		INTC_MEM_MAP_VALUE(0x104)
+#define	INTC_INTERRUPT_PRIORITY_18_REG		INTC_MEM_MAP_VALUE(0x108)
+#define	INTC_INTERRUPT_PRIORITY_19_REG		INTC_MEM_MAP_VALUE(0x10C)
+#define	INTC_INTERRUPT_PRIORITY_20_REG		INTC_MEM_MAP_VALUE(0x110)
+#define	INTC_INTERRUPT_PRIORITY_21_REG		INTC_MEM_MAP_VALUE(0x114)
+#define	INTC_INTERRUPT_PRIORITY_22_REG		INTC_MEM_MAP_VALUE(0x118)
+#define	INTC_INTERRUPT_PRIORITY_23_REG		INTC_MEM_MAP_VALUE(0x11C)
+#define	INTC_INTERRUPT_PRIORITY_24_REG		INTC_MEM_MAP_VALUE(0x120)
+#define	INTC_INTERRUPT_PRIORITY_25_REG		INTC_MEM_MAP_VALUE(0x124)
+#define	INTC_INTERRUPT_PRIORITY_26_REG		INTC_MEM_MAP_VALUE(0x128)
+#define	INTC_INTERRUPT_PRIORITY_27_REG		INTC_MEM_MAP_VALUE(0x12C)
+#define	INTC_INTERRUPT_PRIORITY_28_REG		INTC_MEM_MAP_VALUE(0x130)
+#define	INTC_INTERRUPT_PRIORITY_29_REG		INTC_MEM_MAP_VALUE(0x134)
+#define	INTC_INTERRUPT_PRIORITY_30_REG		INTC_MEM_MAP_VALUE(0x138)
+#define	INTC_INTERRUPT_PRIORITY_31_REG		INTC_MEM_MAP_VALUE(0x13C)
+
+#define	INTC_IRQ_VECTOR_ADDRESS_REG		INTC_MEM_MAP_VALUE(0x140)
+
+#define	INTC_VECTOR_INTERRUPT_ENABLE_REG	INTC_MEM_MAP_VALUE(0x144)
+
+
+
+/*
+ * define constants macros
+ */
+#define	INTC_TIMER1_BIT_INDEX			(0)
+#define	INTC_TIMER2_BIT_INDEX			(1)
+
+#define	INTC_CLOCK_SCALE_BIT_INDEX		(2)
+
+#define	INTC_WATCHDOG_TIMER_BIT_INDEX		(3)
+
+#define	INTC_GPIO_EXTERNAL_INT_BIT_INDEX	(4)
+
+#define	INTC_PCI_INTA_BIT_INDEX			(5)
+#define	INTC_PCI_INTB_BIT_INDEX			(6)
+#define	INTC_PCI_BROKEN_BIT_INDEX		(7)
+#define	INTC_PCI_AHB2BRIDGE_BIT_INDEX		(8)
+
+#define	INTC_UART0_BIT_INDEX			(9)
+#define	INTC_UART1_BIT_INDEX			(10)
+
+#define	INTC_GDMAC_TC_BIT_INDEX			(11)
+#define	INTC_GDMAC_ERROR_BIT_INDEX		(12)
+
+#define	INTC_PCMCIA_BRIDGE_BIT_INDEX		(13)
+
+#define	INTC_RTC_BIT_INDEX			(14)
+
+#define	INTC_PCM_BIT_INDEX			(15)
+
+#define	INTC_USB20_DEVICE_BIT_INDEX		(16)
+
+#define	INTC_IDE_BIT_INDEX			(17)
+
+#define	INTC_NIC_STATUS_BIT_INDEX		(18)
+#define	INTC_NIC_TXTC_BIT_INDEX			(19)
+#define	INTC_NIC_RXRC_BIT_INDEX			(20)
+#define	INTC_NIC_TXQE_BIT_INDEX			(21)
+#define	INTC_NIC_RXQF_BIT_INDEX			(22)
+
+#define	INTC_USB11_BIT_INDEX			(23)
+#define	INTC_USB20_BIT_INDEX			(24)
+
+#define	INTC_I2S_BIT_INDEX			(25)
+#define	INTC_SPI_BIT_INDEX			(26)
+#define	INTC_I2C_BIT_INDEX			(27)
+
+#define	INTC_USB_DEVICE_VBUS_BIT_INDEX		(28)
+
+#define	INTC_EXT_INT29_BIT_INDEX		(29)
+#define	INTC_EXT_INT30_BIT_INDEX		(30)
+#define	INTC_HSDMAC_BIT_INDEX			(31)
+
+
+/*
+ * define interrupt types
+ */
+#define	INTC_IRQ_INTERRUPT			(0)
+#define	INTC_FIQ_INTERRUPT			(1)
+
+/*
+ * define interrupt trigger mode
+ */
+#define	INTC_LEVEL_TRIGGER			(0)
+#define	INTC_EDGE_TRIGGER			(1)
+
+/*
+ * define rising/falling edge for edge trigger mode
+ */
+#define	INTC_RISING_EDGE			(0)
+#define	INTC_FALLING_EDGE			(1)
+
+/*
+ * define active High/Low for level trigger mode
+ */
+#define	INTC_ACTIVE_HIGH			(0)
+#define	INTC_ACTIVE_LOW				(1)
+
+/*
+ * macro declarations
+ */
+#define	HAL_INTC_READ_INTERRUPT_RAW_STATUS(int_raw_status) \
+{ \
+    (int_raw_status) = (INTC_INTERRUPT_RAW_STATUS_REG);	\
+}
+
+
+#define	HAL_INTC_CLEAR_EDGE_TRIGGER_INTERRUPT(source_bit_index)	\
+{ \
+    (INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG) = (1	<< source_bit_index); \
+}
+
+
+#define	HAL_INTC_READ_INTERRUPT_MASK(int_mask) \
+{ \
+    (int_mask) = (INTC_INTERRUPT_MASK_REG); \
+}
+
+
+#define	HAL_INTC_WRITE_INTERRUPT_MASK(int_mask)	\
+{ \
+    (INTC_INTERRUPT_MASK_REG) =	(int_mask); \
+}
+
+
+#define	HAL_INTC_DISABLE_INTERRUPT_SOURCE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_MASK_REG) =	(1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_ENABLE_INTERRUPT_SOURCE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_MASK_CLEAR_REG) = (1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_SET_EDGE_TRIGGER_MODE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_MODE_REG) |= (1 << source_bit_index);\
+}
+
+
+#define	HAL_INTC_SET_LEVEL_TRIGGER_MODE(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_MODE_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_SET_RISING_EDGE_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_SET_FALLING_EDGE_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) |= (1 <<	source_bit_index); \
+}
+
+
+#define	HAL_INTC_SET_ACTIVE_HIGH_TRIGGER_LEVEL(source_bit_index) \
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) &= (~(1 << source_bit_index));\
+}
+
+
+#define	HAL_INTC_SET_ACTIVE_LOW_TRIGGER_LEVEL(source_bit_index)	\
+{ \
+    (INTC_INTERRUPT_TRIGGER_LEVEL_REG) |= ((1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_ASSIGN_INTERRUPT_TO_IRQ(source_bit_index) \
+{ \
+    (INTC_FIQ_SELECT_REG) &= (~(1 << source_bit_index)); \
+}
+
+
+#define	HAL_INTC_ASSIGN_INTERRUPT_TO_FIQ(source_bit_index) \
+{ \
+    (INTC_FIQ_SELECT_REG) |= (1	<< source_bit_index); \
+}
+
+
+#define	HAL_INTC_READ_IRQ_STATUS(int_irq_status) \
+{ \
+    (int_irq_status) = (INTC_IRQ_STATUS_REG); \
+}
+
+
+#define	HAL_INTC_READ_FIQ_STATUS(int_fiq_status) \
+{ \
+    (int_fiq_status) = (INTC_FIQ_STATUS_REG); \
+}
+
+
+#define	HAL_INTC_READ_SOFTWARE_INTERRUPT(software_interrupt) \
+{ \
+    (software_interrupt) = (INTC_SOFTWARE_INTERRUPT_REG); \
+}
+
+
+#define	HAL_INTC_ENABLE_SOFTWARE_INTERRUPT(source_bit_index) \
+{ \
+    (INTC_SOFTWARE_INTERRUPT_REG) = (1 << source_bit_index); \
+}
+
+
+#define	HAL_INTC_CLEAR_SOFTWARE_INTERRUPT(source_bit_index) \
+{ \
+    (INTC_SOFTWARE_INTERRUPT_CLEAR_REG)	= (1 <<	source_bit_index); \
+}
+
+
+#define	HAL_INTC_SELECT_INTERRUPT_SOURCE_FOR_SLEEP_WAKEUP(source_bit_index) \
+{ \
+    (INTC_POWER_MANAGEMENT_INTERRUPT_REG) = (1 << source_bit_index); \
+}
+
+#endif	// end of #ifndef _STAR_INTC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_misc.h linux-2.6.35.11-ts7500//include/asm/arch/star_misc.h
--- linux-2.6.35.11/include/asm/arch/star_misc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_misc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,402 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_MISC_H_
+#define	_STAR_MISC_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	MISC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_MISC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	MISC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_MISC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	MISC_MEMORY_REMAP_REG				MISC_MEM_MAP_VALUE(0x00)
+#define	MISC_CHIP_CONFIG_REG				MISC_MEM_MAP_VALUE(0x04)
+#define	MISC_DEBUG_PROBE_DATA_REG			MISC_MEM_MAP_VALUE(0x08)
+#define	MISC_DEBUG_PROBE_SELECTION_REG			MISC_MEM_MAP_VALUE(0x0C)
+#define	MISC_PCI_CONTROL_BROKEN_MASK_REG		MISC_MEM_MAP_VALUE(0x10)
+#define	MISC_PCI_BROKEN_STATUS_REG			MISC_MEM_MAP_VALUE(0x14)
+#define	MISC_PCI_DEVICE_VENDOR_ID_REG			MISC_MEM_MAP_VALUE(0x18)
+#define	MISC_USB_HOST_PHY_CONTROL_TEST_REG		MISC_MEM_MAP_VALUE(0x1C)
+#define	MISC_GPIOA_PIN_ENABLE_REG			MISC_MEM_MAP_VALUE(0x20)
+#define	MISC_GPIOB_PIN_ENABLE_REG			MISC_MEM_MAP_VALUE(0x24)
+#define	MISC_GPIOA_RESISTOR_CONFIG_REG			MISC_MEM_MAP_VALUE(0x28)
+#define	MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG		MISC_MEM_MAP_VALUE(0x2C)
+#define	MISC_FAST_ETHERNET_PHY_CONFIG_REG		MISC_MEM_MAP_VALUE(0x30)
+#define	MISC_SOFTWARE_TEST_1_REG			MISC_MEM_MAP_VALUE(0x38)
+#define	MISC_SOFTWARE_TEST_2_REG			MISC_MEM_MAP_VALUE(0x3C)
+
+#define	MISC_E_FUSE_0_REG				MISC_MEM_MAP_VALUE(0x60)
+#define	MISC_E_FUSE_1_REG				MISC_MEM_MAP_VALUE(0x64)
+
+
+/*
+ * define constants macros
+ */
+#define	MISC_PARALLEL_FLASH_BOOT		(0)
+#define	MISC_SPI_SERIAL_FLASH_BOOT		(1)
+
+#define	MISC_LITTLE_ENDIAN			(0)
+#define	MISC_BIG_ENDIAN				(1)
+
+#define	MISC_FARADAY_ICE			(0)
+#define	MISC_ARM_ICE				(1)
+
+#define	MISC_EXT_INT29_PINS			((0x1 << 0))
+#define	MISC_EXT_INT30_PINS			((0x1 << 1))
+#define	MISC_EXT_INT31_PINS			((0x1 << 2))
+#define	MISC_I2C_PINS				((0x1 << 13) | (0x1 << 14))
+#define	MISC_I2S_PINS				((0x1 << 15) | (0x1 << 16) | (0x1 << 17))
+#define	MISC_PCM_PINS				((0x1 << 18) | (0x1 << 19) | (0x1 << 20) | (0x1 << 21))
+#define	MISC_LED0_PINS				((0x1 << 22))
+#define	MISC_LED1_PINS				((0x1 << 23))
+#define	MISC_LED2_PINS				((0x1 << 24))
+#define	MISC_LED012_PINS			((0x1 << 22) | (0x1 << 23) | (0x1 << 24))
+#define	MISC_WDTIMER_RESET_PINS			((0x1 << 25))
+#define	MISC_SPI_PINS				((0x1 << 26) | (0x1 << 27) | (0x1 << 28) | (0x1 << 29) | (0x1 << 30) | (0x1 << 31))
+#define	MISC_MDC_MDIO_PINS			((0x1 << 0) | (0x1 << 1))
+#define	MISC_NIC_COL_PINS			((0x1 << 2))
+#define	MISC_IDE_PINS				((0xFF << 3))
+#define	MISC_SRAM_BANK1_PINS			((0x1 << 11) | (0x1 << 14))
+#define	MISC_SRAM_BANK2_PINS			((0x1 << 12) | (0x1 << 15))
+#define	MISC_SRAM_BANK3_PINS			((0x1 << 13) | (0x1 << 16))
+#define	MISC_PCMCIA_PINS			((0x1 << 17) | (0x1 << 18) | (0x1 << 19) | (0x1 << 20))
+#define	MISC_UART1_PINS				((0x1 << 21) | (0x1 << 22))
+#define	MISC_PCI_PINS				(((u32)0x1FF << 23))
+
+#define	MISC_UART0_ACT0_Pin			(0x1 << 2)
+#define	MISC_UART1_ACT1_Pin			(0x1 << 3)
+
+#define	MISC_GPIOA_PIN_0			(0)
+#define	MISC_GPIOA_PIN_1			(1)
+#define	MISC_GPIOA_PIN_2			(2)
+#define	MISC_GPIOA_PIN_3			(3)
+#define	MISC_GPIOA_PIN_4			(4)
+#define	MISC_GPIOA_PIN_5			(5)
+#define	MISC_GPIOA_PIN_6			(6)
+#define	MISC_GPIOA_PIN_7			(7)
+#define	MISC_GPIOA_PIN_8			(8)
+#define	MISC_GPIOA_PIN_9			(9)
+#define	MISC_GPIOA_PIN_10			(10)
+
+#define	MISC_GPIOA_75K_RESISTOR_PULL_DOWN	(1)
+#define	MISC_GPIOA_75K_RESISTOR_PULL_UP		(2)
+#define	MISC_GPIOA_75K_RESISTOR_PULL_KEEPER	(3)
+
+#define	MISC_GPIOA_DRIVE_STRENGTH_4MA		(0)
+#define	MISC_GPIOA_DRIVE_STRENGTH_8MA		(1)
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_MISC_ENABLE_SPI_SERIAL_FLASH_BANK_ACCESS() \
+{ \
+    (MISC_CHIP_CONFIG_REG) |= (0x1 << 4); \
+}
+
+#define	HAL_MISC_DISABLE_SPI_SERIAL_FLASH_BANK_ACCESS()	\
+{ \
+    (MISC_CHIP_CONFIG_REG) &= ~(0x1 << 4); \
+}
+
+
+/*
+ * Macro defines for GPIOA and GPIOB Pin Enable	Register
+ */
+#define	HAL_MISC_ENABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT29_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT29_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT30_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT30_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2C_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2C_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2S_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2S_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_PCM_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCM_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED0_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED0_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED2_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED2_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED012_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED012_PINS);	\
+}
+
+#define	HAL_MISC_ENABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_WDTIMER_RESET_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_WDTIMER_RESET_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPI_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPI_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART0_ACT0_Pin); \
+}
+
+#define	HAL_MISC_DISABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART0_ACT0_Pin); \
+}
+
+#define	HAL_MISC_ENABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART1_ACT1_Pin); \
+}
+
+#define	HAL_MISC_DISABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART1_ACT1_Pin); \
+}
+
+#define	HAL_MISC_ENABLE_MDC_MDIO_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_MDC_MDIO_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_MDC_MDIO_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_MDC_MDIO_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_NIC_COL_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_NIC_COL_PINS);	\
+}
+
+#define	HAL_MISC_DISABLE_NIC_COL_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_NIC_COL_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_IDE_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_IDE_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK2_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK2_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK3_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK3_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCMCIA_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCMCIA_PINS);	\
+}
+
+#define	HAL_MISC_ENABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_UART1_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_UART1_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCI_PINS); \
+}
+
+#define	HAL_MISC_DISABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCI_PINS); \
+}
+
+#define	HAL_MISC_ENABLE_ALL_SHARED_GPIO_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0x0); \
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0x0); \
+}
+
+#define	HAL_MISC_DISABLE_ALL_SHARED_GPIO_PINS()	\
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+}
+
+#define	HAL_MISC_CONFIGURE_GPIOA_RESISTOR(pin_index, value) \
+{ \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) &=	~(0x3 << (2 * pin_index)); \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) |=	((value	& 0x3) << (2 * pin_index)); \
+}
+
+#define	HAL_MISC_CONFIGURE_GPIOA_DRIVE_STRENGTH(pin_index, value) \
+{ \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) &= ~(0x1 << pin_index); \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) |= (value <<	pin_index); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE0() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x0); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE1() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x1); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE2() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x2); \
+}
+
+#define	HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE3() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x3); \
+}
+
+
+#endif	// end of #ifndef _STAR_MISC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_nic.h linux-2.6.35.11-ts7500//include/asm/arch/star_nic.h
--- linux-2.6.35.11/include/asm/arch/star_nic.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_nic.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,346 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_NIC_H_
+#define	_STAR_NIC_H_
+
+
+#include <asm/arch/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_NIC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_NIC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	NIC_PHY_CONTROL_REG0			NIC_MEM_MAP_VALUE(0x000)
+#define	NIC_PHY_CONTROL_REG1			NIC_MEM_MAP_VALUE(0x004)
+
+#define	NIC_MAC_CONTROL_REG			NIC_MEM_MAP_VALUE(0x008)
+#define	NIC_FLOW_CONTROL_CONFIG_REG		NIC_MEM_MAP_VALUE(0x00C)
+
+#define	NIC_ARL_CONFIG_REG			NIC_MEM_MAP_VALUE(0x010)
+
+#define	NIC_MY_MAC_HIGH_BYTE_REG		NIC_MEM_MAP_VALUE(0x014)
+#define	NIC_MY_MAC_LOW_BYTE_REG			NIC_MEM_MAP_VALUE(0x018)
+
+#define	NIC_HASH_TABLE_CONTROL_REG		NIC_MEM_MAP_VALUE(0x01C)
+
+#define	NIC_MY_VLANID_CONTROL_REG		NIC_MEM_MAP_VALUE(0x020)
+
+#define	NIC_MY_VLANID_0_1			NIC_MEM_MAP_VALUE(0x024)
+#define	NIC_MY_VLANID_2_3			NIC_MEM_MAP_VALUE(0x028)
+
+#define	NIC_DMA_CONFIG_REG			NIC_MEM_MAP_VALUE(0x030)
+#define	NIC_TX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x034)
+#define	NIC_RX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x038)
+#define	NIC_TX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x03C)
+#define	NIC_RX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x040)
+
+#define	NIC_TX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x044)
+#define	NIC_RX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x048)
+#define	NIC_DELAYED_INT_CONFIG_REG		NIC_MEM_MAP_VALUE(0x04C)
+
+#define	NIC_INT_STATUS_REG			NIC_MEM_MAP_VALUE(0x050)
+#define	NIC_INT_MASK_REG			NIC_MEM_MAP_VALUE(0x054)
+
+#define	NIC_TEST_0_REG				NIC_MEM_MAP_VALUE(0x058)
+#define	NIC_TEST_1_REG				NIC_MEM_MAP_VALUE(0x05C)
+
+#define	NIC_MIB_RX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x100)
+#define	NIC_MIB_RX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x104)
+#define	NIC_MIB_RX_RUNT_BYTE_CNTR		NIC_MEM_MAP_VALUE(0x108)
+#define	NIC_MIB_RX_OSIZE_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x10C)
+
+#define	NIC_MIB_RX_NO_BUF_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x110)
+
+#define	NIC_MIB_RX_CRC_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x114)
+
+#define	NIC_MIB_RX_ARL_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x118)
+
+#define	NIC_MIB_MYVLANID_MISMATCH_DROP_PKT_CNTR	NIC_MEM_MAP_VALUE(0x11C)
+
+#define	NIC_MIB_RX_CHKSUM_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x120)
+
+#define	NIC_MIB_RX_PAUSE_FRAME_PKT_CNTR		NIC_MEM_MAP_VALUE(0x124)
+
+#define	NIC_MIB_TX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x128)
+#define	NIC_MIB_TX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x12C)
+
+#define	NIC_MIB_TX_COLLISION_CNTR		NIC_MEM_MAP_VALUE(0x130)
+#define	NIC_MIB_TX_PAUSE_FRAME_CNTR		NIC_MEM_MAP_VALUE(0x130)
+
+#define	NIC_MIB_TX_FIFO_UNDERRUN_RETX_CNTR	NIC_MEM_MAP_VALUE(0x134)
+
+
+
+
+/*
+ * define constants macros
+ */
+
+#define	NIC_PHY_ADDRESS		1 //the phy addr const	value
+#define	NIC_PHY_ID		0x0243	//the phy id
+
+#define	GW_NIC_MAX_TFD_NUM	(32)
+#define	GW_NIC_MAX_RFD_NUM	(32)
+#define	MAX_BUFFERS		(64)
+
+
+
+#define	MMU_OFF			(0)
+#define	MMU_ON			(1)
+#define	OS_NULL			(0)
+
+
+#define	NET_BUFFER_PACKET_SIZE		(512)
+#define	NET_BUFFER_SHIFT_BIT_NUM	(9)	// 2*n9=512
+
+#define	MAX_PACKET_LEN		(1536)
+
+#define	INTERNAL_LOOPBACK_MODE	(1)
+#define	SOFTWARE_REPEATER_MODE	(2)
+
+#define	TXTC_INT_BIT		(0x08000000)
+#define	TX_INSV_BIT		(0x04000000)
+
+#define	LS_BIT			(0x10000000)
+#define	FS_BIT			(0x20000000)
+#define	EOR_BIT			(0x40000000)
+#define	FS_LS_BIT		(0x30000000)
+#define	C_BIT			(0x80000000)
+#define	FS_LS_C_BIT		(0xB0000000)
+#define	FS_LS_INT_BIT		(0x38000000)
+
+
+
+// HASH	TABLE CONTROL REGISTER
+#define	NIC_HASH_TABLE_BIST_DONE_BIT	(0x1 <<	17)
+#define	NIC_HASH_TABLE_BIST_OK_BIT	(0x1 <<	16)
+#define	NIC_HASH_COMMAND_START_BIT	(0x1 <<	14)
+#define	NIC_HASH_COMMAND_BIT		(0x1 <<	13)
+#define	NIC_HASH_BIT_DATA		(0x1 <<	12)
+#define	NIC_HASH_BIT_ADDRESS_BIT	(0x1ff)
+
+
+#define	NIC_REG_CNT			((0x48 << 2) + 1)
+
+/*
+ * macro access
+ */
+
+#define	GW_NIC_TX_TFD_NEXT(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ (((u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) + 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_TX_TFD_PREVIOUS(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ ((GW_NIC_MAX_TFD_NUM + (u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) - 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_NEXT(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ (((u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) + 1) % GW_NIC_MAX_RFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_PREVIOUS(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ ((GW_NIC_MAX_RFD_NUM + (u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) - 1) % GW_NIC_MAX_RFD_NUM)
+
+
+/*
+ * PHY register	defines
+ */
+#define	PHY_MII_CONTROL_REG_ADDR		0x00
+#define	PHY_MII_STATUS_REG_ADDR			0x01
+#define	PHY_ID1_REG_ADDR			0x02
+#define	PHY_ID2_REG_ADDR			0x03
+#define	PHY_AN_ADVERTISEMENT_REG_ADDR		0x04
+#define	PHY_AN_REAMOTE_CAP_REG_ADDR		0x05
+
+
+#define	PHY_RESERVED1_REG_ADDR			0x10
+#define	PHY_RESERVED2_REG_ADDR			0x11
+#define	PHY_CH_STATUS_OUTPUT_REG_ADDR		0x12
+#define	PHY_RESERVED3_REG_ADDR			0x13
+#define	PHY_RESERVED4_REG_ADDR			0x14
+
+
+#define	PHY_SPEC_CONTROL_REG_ADDR		0x16
+#define	PHY_INTC_CONTROL_STATUS_REG_ADDR	0x17
+
+/*
+ * NIC registers access	macros defines
+ */
+
+//0x004
+#define	HAL_NIC_WRITE_PHY_CONTROL1(config_value) \
+    ((NIC_PHY_CONTROL_REG1) = (config_value))
+
+#define	HAL_NIC_READ_PHY_CONTROL1(config_value)	\
+    ((config_value) = (NIC_PHY_CONTROL_REG1))
+
+//0x008
+#define	HAL_NIC_WRITE_MAC_CONFIGURATION(config_value) \
+    ((NIC_MAC_CONTROL_REG) = (config_value))
+
+#define	HAL_NIC_READ_MAC_CONFIGURATION(config_value) \
+    ((config_value) = (NIC_MAC_CONTROL_REG))
+
+//0x00C
+#define	HAL_NIC_WRITE_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((NIC_FLOW_CONTROL_CONFIG_REG) = (fc_cfg))
+
+#define	HAL_NIC_READ_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((fc_cfg) =	(NIC_FLOW_CONTROL_CONFIG_REG))
+
+//0x010
+#define	HAL_NIC_WRITE_ARL_CONFIGURATION(cfg) \
+    ((NIC_ARL_CONFIG_REG) = (cfg))
+
+#define	HAL_NIC_READ_ARL_CONFIGURATION(cfg) \
+    ((cfg) = (NIC_ARL_CONFIG_REG))
+
+//0x014,
+#define	HAL_NIC_WRITE_MY_MAC_HIGH_BYTE(cfg) \
+    ((NIC_MY_MAC_HIGH_BYTE_REG)	= (cfg & 0x0000FFFF ) )
+
+#define	HAL_NIC_READ_MY_MAC_HIGH_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_HIGH_BYTE_REG & 0x0000FFFF ))
+
+//0x018
+#define	HAL_NIC_WRITE_MY_MAC_LOW_BYTE(cfg) \
+    ((NIC_MY_MAC_LOW_BYTE_REG) = (cfg))
+
+#define	HAL_NIC_READ_MY_MAC_LOW_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_LOW_BYTE_REG))
+
+//0x03C
+#define	HAL_NIC_READ_INTERRUPT_STATUS(int_status) \
+    ((int_status) = (NIC_INT_STATUS_REG))
+
+#define	HAL_NIC_CLEAR_ALL_INTERRUPT_STATUS_SOURCES()\
+    ((NIC_INT_STATUS_REG) = (0xFFFFFFFF))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCES(source) \
+    ((NIC_INT_STATUS_REG) |= (source))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_STATUS_REG) |= (1	<< (source_bit_index)))
+
+//0x040
+#define	HAL_NIC_DISABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0xFFFFFFFF))
+
+#define	HAL_NIC_ENABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0x00000000))
+
+#define	HAL_NIC_DISABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	|= (1 << (source_bit_index)))
+
+#define	HAL_NIC_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	&= ~(1 << (source_bit_index)))
+
+//0x44
+#define	HAL_NIC_WRITE_TEST0_REG(cfg) \
+    ((NIC_TEST_0_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST0_REG(cfg) \
+    ((cfg) = (NIC_TEST_0_REG))
+
+//0x48
+#define	HAL_NIC_WRITE_TEST1_REG(cfg) \
+    ((NIC_TEST_1_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST1_REG(cfg) \
+    ((cfg) = (NIC_TEST_1_REG))
+
+
+
+/*
+ * NIC's DMA macros defines
+ */
+#define	HAL_NIC_TX_DMA_START() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_TX_DMA_STOP() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_READ_TX_DMA_STATE(state) \
+    ((state) = (NIC_TX_DMA_CONTROL_REG))
+
+
+#define	HAL_NIC_RX_DMA_START() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_RX_DMA_STOP() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_WRITE_TXSD(tssd_value) \
+    ((NIC_TX_DESC_PTR_REG) = (tssd_value))
+
+
+#define	HAL_NIC_READ_TXSD(tssd_value) \
+    ((tssd_value) = (NIC_TX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_RXSD(fssd_value) \
+    ((NIC_RX_DESC_PTR_REG) = (fssd_value))
+
+
+#define	HAL_NIC_READ_RXSD(fssd_value) \
+    ((fssd_value) = (NIC_RX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_TX_BASE(ts_base_value) \
+    ((NIC_TX_DESC_BASE_ADDR_REG) = (ts_base_value))
+
+
+#define	HAL_NIC_READ_TX_BASE(ts_base_value) \
+    ((ts_base_value) = (NIC_TX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_RX_BASE(fs_base_value) \
+    ((NIC_RX_DESC_BASE_ADDR_REG) = (fs_base_value))
+
+
+#define	HAL_NIC_READ_RX_BASE(fs_base_value) \
+    ((fs_base_value) = (NIC_RX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config) \
+    ((NIC_DELAYED_INT_CONFIG_REG) = (delayed_interrupt_config))
+
+
+#define	HAL_NIC_READ_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config)	\
+    ((delayed_interrupt_config)	= (NIC_DELAYED_INT_CONFIG_REG))
+
+#endif	// end of #ifndef _STAR_NIC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_pci_bridge.h linux-2.6.35.11-ts7500//include/asm/arch/star_pci_bridge.h
--- linux-2.6.35.11/include/asm/arch/star_pci_bridge.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_pci_bridge.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,132 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_PCI_DRIDGE_H_
+#define	_STAR_PCI_DRIDGE_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#define	PCI_IO_SPACE_BASE_ADDR			(SYSPA_PCI_IO_SPACE_BASE_ADDR)
+#define PCI_IO_SPACE_SIZE			0x08000000 /* 64MB */
+#define PCI_IO_SPACE_START			PCI_IO_SPACE_BASE_ADDR
+#define PCI_IO_SPACE_END			(PCI_IO_SPACE_BASE_ADDR + PCI_IO_SPACE_SIZE - 1)
+#define	PCI_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCI_MEMORY_SPACE_BASE_ADDR)
+#define PCI_MEMORY_SPACE_SIZE			0x10000000 /* 256MB */
+#define PCI_NPREFETCH_MEMORY_SPACE_START	PCI_MEMORY_SPACE_BASE_ADDR
+#define PCI_NPREFETCH_MEMORY_SPACE_SIZE		0x00800000 /* 8MB */
+#define PCI_NPREFETCH_MEMORY_SPACE_END		(PCI_NPREFETCH_MEMORY_SPACE_START + PCI_NPREFETCH_MEMORY_SPACE_SIZE - 1)
+#define PCI_PREFETCH_MEMORY_SPACE_START		(PCI_NPREFETCH_MEMORY_SPACE_START + PCI_NPREFETCH_MEMORY_SPACE_SIZE)
+#define PCI_PREFETCH_MEMORY_SPACE_SIZE		0x00800000 /* 8MB */
+#define PCI_PREFETCH_MEMORY_SPACE_END		(PCI_PREFETCH_MEMORY_SPACE_START + PCI_PREFETCH_MEMORY_SPACE_SIZE - 1)
+
+
+#if defined(__UBOOT__)
+#define	PCIB_MEM_MAP_VALUE(base, reg_offset)	(*((u32 volatile *)(SYSPA_PCI_##base##_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PCIB_MEM_MAP_VALUE(base, reg_offset)	(*((u32 volatile *)(SYSVA_PCI_##base##_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PCI_BRIDGE_CONFIG_DATA			PCIB_MEM_MAP_VALUE(CONFIG_DATA_BASE, 0x2C)
+#define	PCI_BRIDGE_CONFIG_ADDR			PCIB_MEM_MAP_VALUE(CONFIG_ADDR_BASE, 0x28)
+
+#define PCI_BRIDGE_CONFIG_DATA_REG_OFFSET	0x2C
+#define PCI_BRIDGE_CONFIG_ADDR_REG_OFFSET	0x28
+
+/*
+ * define constants macros
+ */
+#define	PCIB_BUS_CLOCK_33M			1
+
+#define	PCIB_BUS_CLOCK_66M			2
+
+#define	PCIB_DEVICE_ID				0x8131
+
+#define	PCIB_VENDOR_ID				0xEEEE
+
+#define	PCIB_CLASS_CODE				0xFF0000
+
+#define	PCIB_REVISION_ID			0x00
+
+#define	PCIB_BAR0_MEMORY_SPACE_BASE		0x20000000
+
+#define	PCIB_BAR1_IO_SPACE_BASE			0x20000000
+
+
+#define	PCI_MEMORY_SPACE_BASE			0xB0000000
+
+#define	PCI_IO_SPACE_BASE			0xA8000000
+
+
+#define	PCI_MAX_BUS_NUM				0x01
+#define	PCI_MAX_DEVICE_NUM			0x14
+#define	PCI_MAX_FUNCTION_NUM			0x01
+#define	PCI_MAX_REG_NUM				0x3C
+
+
+#define	PCI_MAX_DEVICE_TYPE_NUM			0x13
+#define	PCI_MAX_BAR_NUM				0x06
+
+
+#define	PCI_CSH_VENDOR_ID_REG_ADDR		0x00
+#define	PCI_CSH_DEVICE_ID_REG_ADDR		0x02
+#define	PCI_CSH_COMMAND_REG_ADDR		0x04
+#define	PCI_CSH_STATUS_REG_ADDR			0x06
+#define	PCI_CSH_REVISION_CLASS_REG_ADDR		0x08
+#define	PCI_CSH_CACHE_LINE_SIZE_REG_ADDR	0x0C
+#define	PCI_CSH_LATENCY_TIMER_REG_ADDR		0x0D
+#define	PCI_CSH_HEADER_TYPE_REG_ADDR		0x0E
+#define	PCI_CSH_BIST_REG_ADDR			0x0F
+#define	PCI_CSH_BAR_REG_ADDR			0x10
+
+
+#define	PCI_IO_SPACE_SIZE_1M			0x00
+#define	PCI_IO_SPACE_SIZE_2M			0x01
+#define	PCI_IO_SPACE_SIZE_4M			0x02
+#define	PCI_IO_SPACE_SIZE_8M			0x03
+#define	PCI_IO_SPACE_SIZE_16M			0x04
+#define	PCI_IO_SPACE_SIZE_32M			0x05
+#define	PCI_IO_SPACE_SIZE_64M			0x06
+#define	PCI_IO_SPACE_SIZE_128M			0x07
+#define	PCI_IO_SPACE_SIZE_256M			0x08
+#define	PCI_IO_SPACE_SIZE_512M			0x09
+#define	PCI_IO_SPACE_SIZE_1G			0x0A
+#define	PCI_IO_SPACE_SIZE_2G			0x0B
+
+
+#define	PCI_MEMORY_SPACE_TYPE			0
+#define	PCI_IO_SPACE_TYPE			1
+
+#define	PCI_BROKEN_FLAG				1
+#define	PCI_AHB2PCIB_FLAG			2
+
+
+#endif	// end of #ifndef _STAR_PCI_DRIDGE_H_
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_pcmcia_bridge.h linux-2.6.35.11-ts7500//include/asm/arch/star_pcmcia_bridge.h
--- linux-2.6.35.11/include/asm/arch/star_pcmcia_bridge.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_pcmcia_bridge.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,231 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_PCMCIA_DRIDGE_H_
+#define	_STAR_PCMCIA_DRIDGE_H_
+
+/******************************************************************************
+ * MODULE NAME:	   star_pcmcia_bridge.h
+ * PROJECT CODE:   Equuleus
+ * DESCRIPTION:
+ * MAINTAINER:	   Eric	Yang
+ * DATE:	   15 September	2005
+ *
+ * SOURCE CONTROL:
+ *
+ * LICENSE:
+ *     This source code	is copyright (c) 2005 Star Semi	Inc.
+ *     All rights reserved.
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  Eric Yang	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include "star_sys_memory_map.h"
+
+
+#if defined(__UBOOT__)
+#define	PCMCIA_BRIDGE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_PCMCIA_CONTROL_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PCMCIA_BRIDGE_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_PCMCIA_CONTROL_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PCMCIA_CONFIGURATION_REG			PCMCIA_BRIDGE_MEM_MAP_VALUE(0x20)
+#define	PCMCIA_MEMORY_ACCESS_TIMING_PARAM_REG		PCMCIA_BRIDGE_MEM_MAP_VALUE(0x24)
+#define	PCMCIA_IO_ACCESS_TIMING_PARAM_REG		PCMCIA_BRIDGE_MEM_MAP_VALUE(0x28)
+
+
+#define	PCMCIA_ATTRIBUTE_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCMCIA_ATTRIBUTE_MEMORY_BASE_ADDR)
+#define	PCMCIA_COMMOM_MEMORY_SPACE_BASE_ADDR		(SYSPA_PCMCIA_COMMON_MEMORY_BASE_ADDR)
+#define	PCMCIA_IO_SPACE_BASE_ADDR			(SYSPA_PCMCIA_IO_SPACE_BASE_ADDR)
+
+
+
+/*
+ * define constants macros
+ */
+#define	PCMCIA_DATA_BUS_WIDTH_8		(0)
+
+#define	PCMCIA_DATA_BUS_WIDTH_16	(1)
+
+
+/*
+ * Flags for PCMCIA_STATUS
+ */
+#define	FLAG_STATUS_BVD1		0x01
+#define	FLAG_STATUS_STSCHG		0x01
+#define	FLAG_STATUS_BVD2		0x02
+#define	FLAG_STATUS_SPKR		0x02
+#define	FLAG_STATUS_DETECT		0xf3	  /* bit 2=0,3=0 ,0x0c bit 2=1,3=1 */
+#define	FLAG_STATUS_WRPROT		0x10
+#define	FLAG_STATUS_READY		0x20
+#define	FLAG_STATUS_INPACK		0x40
+
+
+/*
+ * Flags for PCMCIA_CSC
+ */
+#define	FLAG_CSC_BVD1			0x01
+#define	FLAG_CSC_BVD2			0x02
+#define	FLAG_CSC_READY			0x04
+#define	FLAG_CSC_INPACK			0x08
+#define	FLAG_CSC_STSCHG			0x10
+#define	FLAG_CSC_CARDINT		0x20
+#define	FLAG_CSC_DETECT			0x40
+#define	FLAG_CSC_SWCDC			0x80
+
+
+/*
+ * Flags for PCMCIA_POWER
+ */
+#define	FLAG_POWER_OFF			0x00	  /* Turn off the socket */
+#define	FLAG_POWER_3V			0x01	  /* 1:Vcc = 3.3v 0:Vcc	= 5.0v */
+#define	FLAG_POWER_SWH			0x02	  /* Direct 5V/3V switch enable	*/
+#define	FLAG_POWER_CTL			0x10	  /* Socket power control */
+#define	FLAG_POWER_AUTO			0x20	  /* Auto power	switch enable */
+#define	FLAG_POWER_OUTENA		0x40	  /* Output enable */
+
+
+/*
+ * Flags for PCMCIA_GBLCTL
+ */
+#define	FLAG_GBLCTL_PWRDOWN		0x01
+#define	FLAG_GBLCTL_WBACK		0x02
+#define	FLAG_GBLCTL_16BITS		0x04
+#define	FLAG_GBLCTL_IOCARD		0x08
+#define	FLAG_GBLCTL_SWCDINT		0x10
+#define	FLAG_GBLCTL_RESET		0x20
+
+
+/*
+ * Flags for PCMCIA_INTCFG
+ */
+#define	FLAG_INTCFG_BDEAD		0x01
+#define	FLAG_INTCFG_BWARN		0x02
+#define	FLAG_INTCFG_READY		0x04
+#define	FLAG_INTCFG_INPACK		0x08
+#define	FLAG_INTCFG_LEVEL		0x10
+#define	FLAG_INTCFG_FEDGE		0x20
+#define	FLAG_INTCFG_REDGE		0x30
+#define	FLAG_INTCFG_DETECT		0x40
+#define	FLAG_INTCFG_STSCHG		0x80
+
+
+/*
+ * Definitions for Card	Status flags for GetStatus
+ */
+#define	STATUS_BATDEAD			0x0001
+#define	STATUS_BATWARN			0x0002
+#define	STATUS_DETECT			0x0004
+#define	STATUS_WRPROT			0x0008
+#define	STATUS_READY			0x0010
+#define	STATUS_INPACK			0x0020
+#define	STATUS_STSCHG			0x0040    /* just for	CSC */
+#define	SOFTWARE_STATUS_DETECT		0x0040    /* just for	CSC */
+
+
+/*
+ * Set Socket configuration flags
+ */
+#define	SS_PWR_AUTO			0x0001
+#define	SS_PWR_SWH			0x0002
+#define	SS_PWR_SEL			0x0004
+#define	SS_POWER_ON			0x0008
+#define	SS_OUTPUT_ENA			0x0010
+#define	SS_IOCARD			0x0020
+#define	SS_RESET			0x0040
+#define	SS_WBACK			0x0080
+#define	SS_16BITS			0x0100
+#define	SS_PWR_DOWN_MODE		0x0200
+#define	SS_SWCDINT			0x0400
+
+
+/*
+ * Set Interrupt Configuration flags
+ */
+#define	INTR_BATDEAD			0x0001
+#define	INTR_BATWARN			0x0002
+#define	INTR_READY			0x0004
+#define	INTR_INPACK			0x0008
+#define	INTR_CARDINT			0x0010
+#define	INTR_DETECT			0x0020
+#define	INTR_STSCHG			0x0040
+
+
+/*
+ * tuple code
+ */
+#define	CISTPL_NULL			0x00
+#define	CISTPL_DEVICE			0x01
+#define	CISTPL_NO_LINK			0x14
+#define	CISTPL_VERS_1			0x15
+#define	CISTPL_CONFIG			0x1a
+#define	CISTPL_CFTABLE_ENTRY		0x1b
+#define	CISTPL_MANFID			0x20
+#define	CISTPL_END			0xff
+
+
+/*
+ * Return codes
+ */
+#define	CS_SUCCESS			0x00
+#define	CS_UNSUPPORTED_FUNCTION		0x15
+#define	CS_NO_MORE_ITEMS		0x1f
+#define	CS_BAD_TUPLE			0x40
+
+
+/*
+ * Attributes for tuple	calls
+ */
+#define	TUPLE_RETURN_LINK		0x01
+#define	TUPLE_RETURN_COMMON		0x02
+
+#define	RETURN_FIRST_TUPLE		0xff
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_PCMCIA_ENABLE_PCMCIA_CONTROLLER() \
+{ \
+    (PCMCIA_CONFIGURATION_REG) |= (0x1 << 1); \
+}
+
+#define	HAL_PCMCIA_DISABLE_PCMCIA_CONTROLLER() \
+{ \
+    (PCMCIA_CONFIGURATION_REG) &= ~(0x1	<< 1); \
+}
+
+
+#endif	// end of #ifndef _STAR_PCMCIA_DRIDGE_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_pcm.h linux-2.6.35.11-ts7500//include/asm/arch/star_pcm.h
--- linux-2.6.35.11/include/asm/arch/star_pcm.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_pcm.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,277 @@
+/******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_PCM_H_
+#define _STAR_PCM_H_
+
+/******************************************************************************
+ * MODULE NAME:    star_pcm.h
+ * PROJECT CODE:   Orion
+ * DESCRIPTION:    
+ * MAINTAINER:     MJLIU
+ * DATE:           15 September 2005
+ *
+ * SOURCE CONTROL: 
+ *
+ * LICENSE:
+ *     This source code is copyright (c) 2005 Star Semi Inc.
+ *     All rights reserved.
+ *
+ * REVISION HISTORY:
+ *     15 September 2005  -  MJLIU	- Initial Version v1.0
+ *
+ *
+ * SOURCE:
+ * ISSUES:
+ * NOTES TO USERS:
+ ******************************************************************************/
+
+#include <mach/star_sys_memory_map.h>
+
+#define PCM_BASE_ADDR                         (SYSVA_PCM_BASE_ADDR)
+#define PCM_MEM_MAP_ADDR(reg_offset)          (PCM_BASE_ADDR + reg_offset)
+#define PCM_MEM_MAP_VALUE(reg_offset)         (*((u32 volatile *)PCM_MEM_MAP_ADDR(reg_offset)))
+
+
+/*
+ * define access macros
+ */
+#define PCM_CONFIGURATION_0_REG               PCM_MEM_MAP_VALUE(0x80)
+#define PCM_CONFIGURATION_1_REG               PCM_MEM_MAP_VALUE(0x84)
+
+#define PCM_CHANNEL_0_CONFIG_REG              PCM_MEM_MAP_VALUE(0x88)
+#define PCM_CHANNEL_1_CONFIG_REG              PCM_MEM_MAP_VALUE(0x8C)
+#define PCM_CHANNEL_2_CONFIG_REG              PCM_MEM_MAP_VALUE(0x90)
+#define PCM_CHANNEL_3_CONFIG_REG              PCM_MEM_MAP_VALUE(0x94)
+
+#define PCM_TX_DATA_31_0_REG                  PCM_MEM_MAP_VALUE(0x98)
+#define PCM_TX_DATA_63_32_REG                 PCM_MEM_MAP_VALUE(0x9C)
+
+#define PCM_RX_DATA_31_0_REG                  PCM_MEM_MAP_VALUE(0xA0)
+#define PCM_RX_DATA_63_32_REG                 PCM_MEM_MAP_VALUE(0xA4)
+
+#define PCM_INTERRUPT_STATUS_REG              PCM_MEM_MAP_VALUE(0xA8)
+#define PCM_INTERRUPT_ENABLE_REG              PCM_MEM_MAP_VALUE(0xAC)
+
+
+
+/*
+ * define constants macros
+ */
+#define CH0_BIT_INDEX                         (0x1)
+#define CH1_BIT_INDEX                         (0x2)
+#define CH2_BIT_INDEX                         (0x4)
+#define CH3_BIT_INDEX                         (0x8)
+
+#define PCM_RXBUF_FULL_FG                     (0x1)
+#define PCM_TXBUF_EMPTY_FG                    (0x2)
+#define PCM_RXBUF_OVERRUN_FG                  (0x4)
+#define PCM_TXBUF_UNDERRUN_FG                 (0x8)
+
+#define PCM_ENABLE_FG                         (0x1 << 23)
+
+#define PCM_IDL_MODE                          (0)
+#define PCM_GCI_MODE                          (1)
+
+#define PCM_DATA_BIT_8                        (0)
+#define PCM_DATA_BIT_16                       (1)
+
+
+/*
+ * Set Commands Variables
+ */
+#define        Software_Reset                               (0x02)
+#define        Hardware_Reset                               (0x04)
+#define        Write_Transmit_Time_Slot                     (0x40)
+#define        Read_Transmit_Time_Slot                      (0x41)
+#define        Write_Receive_Time_Slot                      (0x42)
+#define        Read_Receive_Time_Slot                       (0x43)
+#define        Write_Tx_Rx_CLK_Slot_Tx_CLK_Edge             (0x44)
+#define        Read_Tx_Rx_CLK_Slot_Tx_CLK_Edge              (0x45)
+#define        Write_Device_Configure_Reg                   (0x46)
+#define        Read_Device_Configure_Reg                    (0x47)
+#define        Write_Channel_Enable_Operating_Mode_Reg      (0x4A)
+#define        Read_Channel_Enable_Operating_Mode_Reg       (0x4B)
+#define        Read_Signal_Reg                              (0x4D)
+#define        Input_Data_Reg                               (0x52)
+#define        Output_Data_Reg                              (0x53)
+#define        Input_Direction_Reg                          (0x54)
+#define        Output_Direction_Reg                         (0x55)
+#define        Write_System_State                           (0x56)
+#define        Read_System_State                            (0x57)
+#define        Write_Operating_Functon                      (0x60)
+#define        Read_Operating_Functon                       (0x61)
+#define        Write_System_State_Config                    (0x68)
+#define        Read_System_State_Config                     (0x69)
+#define        Write_Interrupt_Mask_Reg                     (0x6C)
+#define        Read_Interrupt_Mask_Reg                      (0x6D)
+#define        Write_Operating_Condition                    (0x70)
+#define        Write_Loop_Supervision_Parameter             (0xC2)
+#define        Write_DC_Feed_Parameter                      (0xC6)
+#define        Write_Signal_A_B_Parameter                   (0xD2)
+#define        Write_Switching_Reg_Parameter                (0xE4)
+#define        Write_Switching_Reg_Control                  (0xE6)
+
+
+/*
+ * define data structure
+ */
+typedef struct _PCM_CHANNEL_OBJECT_    PCM_CHANNEL_OBJECT_T;
+
+struct _PCM_CHANNEL_OBJECT_
+{
+    u16          channel_0_tx_data;
+    u16          channel_0_rx_data;
+    u32          channel_0_data_width;     /* 0 : 8-bit, 1 : 16-bit */
+
+    u16          channel_1_tx_data;
+    u16          channel_1_rx_data;
+    u32          channel_1_data_width;
+
+    u16          channel_2_tx_data;
+    u16          channel_2_rx_data;
+    u32          channel_2_data_width;
+
+    u16          channel_3_tx_data;
+    u16          channel_3_rx_data;
+    u32          channel_3_data_width;
+    
+    u32          channel_enable_config;    /* bit[0] = 0 : channel 0 disabled
+                                                     [0] = 1 : channel 0 enabled
+                                                  bit[1] = 0 : channel 1 disabled
+                                                     [1] = 1 : channel 1 enabled
+                                                  bit[2] = 0 : channel 2 disabled
+                                                     [2] = 1 : channel 2 enabled
+                                                  bit[3] = 0 : channel 3 disabled
+                                                     [3] = 1 : channel 3 enabled */
+};
+
+
+typedef struct _PCM_OBJECT_    PCM_OBJECT_T;
+
+struct _PCM_OBJECT_
+{
+    u32          config_0;
+    u32          config_1; 
+    
+    u32          channel_0_config;
+    u32          channel_1_config;
+    u32          channel_2_config;
+    u32          channel_3_config;
+    
+    u32          interrupt_config;
+    
+    /* 
+     * For interrupt setting
+     */
+//    INTC_OBJECT_T    intc_obj;
+};
+
+
+
+/*
+ * function declarations
+ */
+void       Hal_Pcm_Initialize(PCM_OBJECT_T *);
+
+                                                                           
+/*
+ * macro declarations
+ */
+#define HAL_PCM_ENABLE_PCM() \
+{ \
+    (PCM_CONFIGURATION_0_REG) |= ((u32)0x1 << 31); \
+}
+
+#define HAL_PCM_DISABLE_PCM() \
+{ \
+    (PCM_CONFIGURATION_0_REG) &= ~((u32)0x1 << 31); \
+}
+
+#define HAL_PCM_ENABLE_DATA_SWAP() \
+{ \
+    (PCM_CONFIGURATION_0_REG) |= (0x1 << 24); \
+}
+
+#define HAL_PCM_DISABLE_DATA_SWAP() \
+{ \
+    (PCM_CONFIGURATION_0_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_PCM_WRITE_TX_DATA_0(tx_data_0) \
+{ \
+    (PCM_TX_DATA_31_0_REG) = tx_data_0; \
+}
+
+#define HAL_PCM_WRITE_TX_DATA_1(tx_data_1) \
+{ \
+    (PCM_TX_DATA_63_32_REG) = tx_data_1; \
+}
+
+#define HAL_PCM_READ_RX_DATA_0(rx_data_0) \
+{ \
+    (rx_data_0) = PCM_RX_DATA_31_0_REG; \
+}
+
+#define HAL_PCM_READ_RX_DATA_1(rx_data_1) \
+{ \
+    (rx_data_1) = PCM_RX_DATA_63_32_REG; \
+}
+
+#define HAL_PCM_READ_INTERRUPT_STATUS(status) \
+{ \
+    (status) = PCM_INTERRUPT_STATUS_REG; \
+}
+
+#define HAL_PCM_CLEAR_INTERRUPT_STATUS(status) \
+{ \
+    (PCM_INTERRUPT_STATUS_REG) = (status & 0xC0); \
+}
+
+#define HAL_PCM_DISABLE_RECEIVE_BUFFER_FULL_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_PCM_DISABLE_TRANSMIT_BUFFER_EMPTY_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_PCM_DISABLE_RECEIVE_BUFFER_OVERRUN_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 2); \
+}
+
+#define HAL_PCM_DISABLE_TRANSMIT_BUFFER_UNDERRUN_INTERRUPT() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) &= ~(0x1 << 3); \
+}
+
+#define HAL_PCM_DISABLE_ALL_INTERRUPT_SOURCES() \
+{ \
+    (PCM_INTERRUPT_ENABLE_REG) = 0; \
+}
+
+#endif  // end of #ifndef _STAR_PCM_H_
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_powermgt.h linux-2.6.35.11-ts7500//include/asm/arch/star_powermgt.h
--- linux-2.6.35.11/include/asm/arch/star_powermgt.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_powermgt.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,616 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_POWERMGT_H_
+#define	_STAR_POWERMGT_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	PWRMGT_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_POWER_MANAGEMENT_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	PWRMGT_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_POWER_MANAGEMENT_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	PWRMGT_CLOCK_GATE_CONTROL0_REG			PWRMGT_MEM_MAP_VALUE(0x00)
+#define	PWRMGT_CLOCK_GATE_CONTROL1_REG			PWRMGT_MEM_MAP_VALUE(0x04)
+#define	PWRMGT_SOFTWARE_RESET_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x08)
+#define	PWRMGT_SYSTEM_CLOCK_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x0C)
+#define	PWRMGT_PLL_POWER_DOWN_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x10)
+#define	PWRMGT_CPU_INITIALIZATION_REG			PWRMGT_MEM_MAP_VALUE(0x14)
+#define	PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x1C)
+#define	PWRMGT_USB_DEVICE_POWERMGT_REG			PWRMGT_MEM_MAP_VALUE(0x20)
+#define	PWRMGT_REGULATOR_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x24)
+#define	PWRMGT_RTC_XTAL_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x28)
+#define	PWRMGT_PLL250_CONTROL_REG			PWRMGT_MEM_MAP_VALUE(0x2C)
+
+
+/*
+ * define constants macros
+ */
+#define	PWRMGT_PCMCIA_SOFTWARE_RESET_BIT_INDEX			(1)
+#define	PWRMGT_IDE_SOFTWARE_RESET_BIT_INDEX			(2)
+#define	PWRMGT_VIC_SOFTWARE_RESET_BIT_INDEX			(3)
+#define	PWRMGT_DMA_SOFTWARE_RESET_BIT_INDEX			(4)
+#define	PWRMGT_NIC_SOFTWARE_RESET_BIT_INDEX			(5)
+#define	PWRMGT_USB_HOST_SOFTWARE_RESET_BIT_INDEX		(6)
+#define	PWRMGT_PCI_BRIDGE_SOFTWARE_RESET_BIT_INDEX		(7)
+#define	PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX			(8)
+#define	PWRMGT_UART0_SOFTWARE_RESET_BIT_INDEX			(9)
+#define	PWRMGT_UART1_SOFTWARE_RESET_BIT_INDEX			(10)
+#define	PWRMGT_TIMER_SOFTWARE_RESET_BIT_INDEX			(11)
+#define	PWRMGT_WDTIMER_SOFTWARE_RESET_BIT_INDEX			(12)
+#define	PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX			(13)
+#define	PWRMGT_USB_DEVICE_SOFTWARE_RESET_BIT_INDEX		(14)
+#define	PWRMGT_FAST_ETHERNET_PHY_SOFTWARE_RESET_BIT_INDEX	(15)
+#define	PWRMGT_HSDMA_SOFTWARE_RESET_BIT_INDEX			(16)
+
+
+#define	PWRMGT_PLL_FREQUENCY_175MHZ			(0 << 0)
+#define	PWRMGT_PLL_FREQUENCY_200MHZ			(1 << 0)
+#define	PWRMGT_PLL_FREQUENCY_225MHZ			(2 << 0)
+#define	PWRMGT_PLL_FREQUENCY_250MHZ			(3 << 0)
+
+#define	PWRMGT_CPUCLK_DIVIDER_BY_1			(0 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_2			(1 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_3			(2 << 2)
+#define	PWRMGT_CPUCLK_DIVIDER_BY_4			(3 << 2)
+
+#define	PWRMGT_HCLK_DIVIDER_BY_1			(0 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_2			(1 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_3			(2 << 4)
+#define	PWRMGT_HCLK_DIVIDER_BY_4			(3 << 4)
+
+#define	PWRMGT_HCLK_SOURCE_FCLK				(0 << 6)
+#define	PWRMGT_HCLK_SOURCE_125MHZ			(1 << 6)
+
+#define	PWRMGT_PCLK_DIVIDER_BY_1			(0 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_2			(1 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_3			(2 << 8)
+#define	PWRMGT_PCLK_DIVIDER_BY_4			(3 << 8)
+
+#define	PWRMGT_PCICLK_DIVIDER_BY_1			(0 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_2			(1 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_3			(2 << 10)
+#define	PWRMGT_PCICLK_DIVIDER_BY_4			(3 << 10)
+
+
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_1		(1)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_2		(2)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_3		(3)
+#define	PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_4		(4)
+
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_1		(1)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_2		(2)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_3		(3)
+#define	PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_4		(4)
+
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_1			(1)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_2			(2)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_3			(3)
+#define	PWRMGT_HCLK_TO_PCLK_RATIO_BY_4			(4)
+
+/*
+ * Macro defines for Clock Gate	Control
+ */
+#define	HAL_PWRMGT_DISABLE_DRAMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x0F << 20); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x0F <<	20); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define	HAL_PWRMGT_ENABLE_PCI_BRIDGE_66M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	28) | (0x1 << 30)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_USB_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0xF << 1); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 28); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 6) | (0x1 << 14); \
+}
+
+#define	HAL_PWRMGT_DISABLE_USB_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 28); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 16); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 4); \
+}
+
+#define	HAL_PWRMGT_DISABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 16); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 8) | (0x1	<< 9); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_DISABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	8) | (0x1 << 9)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_UART0_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 1) |	(0x1 <<	2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 12); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 9); \
+}
+
+#define	HAL_PWRMGT_DISABLE_UART0_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_UART1_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 1) |	(0x1 <<	2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 13); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 10); \
+}
+
+#define	HAL_PWRMGT_DISABLE_UART1_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 13); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1	<< 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	4) | (0x1 << 5)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_GPIO_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 25); \
+}
+
+#define	HAL_PWRMGT_DISABLE_GPIO_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 25); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 21) | (0x1 << 22); \
+}
+
+#define	HAL_PWRMGT_DISABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	21) | (0x1 << 22)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 23); \
+}
+
+#define	HAL_PWRMGT_DISABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 23); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_TIMER_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 17) | (0x1 << 18)	| (0x1 << 19); \
+}
+
+#define	HAL_PWRMGT_DISABLE_TIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	17) | (0x1 << 18) | (0x1 << 19)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1); \
+}
+
+#define	HAL_PWRMGT_DISABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 1); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1	<< 5) |	(0x1 <<	6)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1	<< 10);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define	HAL_PWRMGT_DISABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	1) | (0x1 << 10)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1	<< 6); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define	HAL_PWRMGT_DISABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	1) | (0x1 << 6)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 0) | (0x1	<< 1); \
+}
+
+#define	HAL_PWRMGT_DISABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 <<	0) | (0x1 << 1)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 12); \
+}
+
+#define	HAL_PWRMGT_DISABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1	<< 5); \
+}
+
+#define	HAL_PWRMGT_DISABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 <<	4) | (0x1 << 5)); \
+}
+
+
+#define	HAL_PWRMGT_ENABLE_HSDMA_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 29); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 16); \
+}
+
+#define	HAL_PWRMGT_DISABLE_HSDMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 29); \
+}
+
+
+
+/*
+ * Macro defines for Reset Control
+ */
+#define	HAL_PWRMGT_GLOBAL_SOFTWARE_RESET() \
+{ \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1); \
+}
+
+
+/*
+ * Macro defines for System Clock Control
+ */
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_175MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_200MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x1; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_225MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x2; \
+}
+
+
+#define	HAL_PWRMGT_SET_PLL_FREQUENCY_250MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x3; \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_PLLCLK_TO_CPUCLK_RATIO(ratio)	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	2); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 2); \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_CPUCLK_TO_HCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	4); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 4); \
+}
+
+
+#define	HAL_PWRMGT_HCLK_SOURCE_FCLK() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 <<	6); \
+}
+
+
+#define	HAL_PWRMGT_HCLK_SOURCE_125MHZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 6); \
+}
+
+
+#define	HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_HCLK()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 <<	7); \
+}
+
+
+#define	HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_62_5MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 7); \
+}
+
+
+#define	HAL_PWRMGT_CONFIG_HCLK_TO_PCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	8); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 8); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_8192000HZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 12); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_11289600HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 12); \
+}
+
+
+#define	HAL_PWRMGT_I2S_CLOCK_SOURCE_12288000HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x2 << 12); \
+}
+
+
+#define	HAL_PWRMGT_CONFIGURE_MDC_CLOCK_DIVIDER(divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 <<	14); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 14); \
+}
+
+
+#define	HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(pin_source_select, divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3F << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((pin_source_select & 0xF) << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 20); \
+}
+
+
+/*
+ * Macro defines for PLL Power Down Control
+ */
+#define	HAL_PWRMGT_POWER_DOWN_SYSTEM_XTAL_PAD()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 7)
+
+#define	HAL_PWRMGT_POWER_ON_SYSTEM_XTAL_PAD() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 7)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 0)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 1)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 2)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 2)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 3)
+
+#define	HAL_PWRMGT_POWER_ON_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 3)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 4)
+
+#define	HAL_PWRMGT_POWER_ON_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 4)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X2250() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 5)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X2250()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 6)
+
+#define	HAL_PWRMGT_POWER_ON_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 6)
+
+
+#define	HAL_PWRMGT_POWER_DOWN_ALL_PLL()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0x7F;
+
+#define	HAL_PWRMGT_POWER_ON_ALL_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0;
+
+
+/*
+ * Macro defines for Pad Drive Strength	Control
+ */
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCMCIA_CARDBUS_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCI_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 0); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_MII_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_RGMII_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 2); \
+}
+
+#define	HAL_PWRMGT_ENABLE_MII_PAD_SIGNAL_NOT_BOUNDED() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 3); \
+}
+
+#define	HAL_PWRMGT_DISABLE_MII_PAD_SIGNAL_NOT_BOUNDED()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 3); \
+}
+
+
+/*
+ * Macro defines for USB Device	Power Management
+ */
+#define	HAL_PWRMGT_REMOTE_WAKEUP_USB_HOST() \
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 4); \
+}
+
+#define	HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_EXTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG &= ~(0x1 << 5); \
+}
+
+#define	HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_INTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 5); \
+}
+
+
+/*
+ * Macro defines for Regulator Control
+ */
+
+
+#endif	// end of #ifndef _STAR_POWERMGT_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_rtc.h linux-2.6.35.11-ts7500//include/asm/arch/star_rtc.h
--- linux-2.6.35.11/include/asm/arch/star_rtc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_rtc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_RTC_H_
+#define	_STAR_RTC_H_
+
+#include <mach/star_sys_memory_map.h>
+
+#define	RTC_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_RTC_BASE_ADDR + reg_offset)))
+
+#define	RTC_SECOND_REG				RTC_MEM_MAP_VALUE(0x00)
+#define	RTC_MINUTE_REG				RTC_MEM_MAP_VALUE(0x04)
+#define	RTC_HOUR_REG				RTC_MEM_MAP_VALUE(0x08)
+#define	RTC_DAY_REG				RTC_MEM_MAP_VALUE(0x0C)
+#define	RTC_SECOND_ALARM_REG			RTC_MEM_MAP_VALUE(0x10)
+#define	RTC_MINUTE_ALARM_REG			RTC_MEM_MAP_VALUE(0x14)
+#define	RTC_HOUR_ALARM_REG			RTC_MEM_MAP_VALUE(0x18)
+#define	RTC_RECORD_REG				RTC_MEM_MAP_VALUE(0x1C)
+#define	RTC_CONTROL_REG				RTC_MEM_MAP_VALUE(0x20)
+#define	RTC_INTERRUPT_STATUS_REG		RTC_MEM_MAP_VALUE(0x34)
+
+#define	RTC_ENABLE_BIT				(1 << 0)
+#define	RTC_AUTO_SECOND_ALARM_ENABLE_BIT	(1 << 1)
+#define	RTC_AUTO_MINUTE_ALARM_ENABLE_BIT	(1 << 2)
+#define	RTC_AUTO_HOUR_ALARM_ENABLE_BIT		(1 << 3)
+#define	RTC_AUTO_DAY_ALARM_ENABLE_BIT		(1 << 4)
+#define	RTC_MATCH_ALARM_ENABLE_BIT		(1 << 5)
+#define	RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT	(1 << 6)
+
+#define RTC_AUTO_SECOND_ALARM_INTR_BIT      (1 << 0)
+#define RTC_AUTO_MINUTE_ALARM_INTR_BIT      (1 << 1)
+#define RTC_AUTO_HOUR_ALARM_INTR_BIT        (1 << 2)
+#define RTC_AUTO_DAY_ALARM_INTR_BIT         (1 << 3)
+#define RTC_MATCH_ALARM_INTR_BIT            (1 << 4)
+#define RTC_BATTERY_LOW_VOLTAGE_INTR_BIT    (1 << 5)
+
+#define	HAL_RTC_READ_SECOND(second)         ((second) = (RTC_SECOND_REG) & 0x3F);
+#define	HAL_RTC_READ_MINUTE(minute)         ((minute) = (RTC_MINUTE_REG) & 0x3F);
+#define	HAL_RTC_READ_HOUR(hour)	            ((hour) = (RTC_HOUR_REG) & 0x1F);
+#define	HAL_RTC_READ_DAY(day)               ((day) = (RTC_DAY_REG) & 0xFFFF);
+#define	HAL_RTC_ENABLE()                    ((RTC_CONTROL_REG) |= (RTC_ENABLE_BIT));
+#define	HAL_RTC_DISABLE()                   ((RTC_CONTROL_REG) &= ~(RTC_ENABLE_BIT));
+#define	HAL_RTC_AUTO_SECOND_ALARM_ENABLE()  ((RTC_CONTROL_REG) |= (RTC_AUTO_SECOND_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_SECOND_ALARM_DISABLE() ((RTC_CONTROL_REG) &= ~(RTC_AUTO_SECOND_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_MINUTE_ALARM_ENABLE()  ((RTC_CONTROL_REG) |= (RTC_AUTO_MINUTE_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_MINUTE_ALARM_DISABLE() ((RTC_CONTROL_REG) &= ~(RTC_AUTO_MINUTE_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_HOUR_ALARM_ENABLE()    ((RTC_CONTROL_REG) |= (RTC_AUTO_HOUR_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_HOUR_ALARM_DISABLE()   ((RTC_CONTROL_REG) &= ~(RTC_AUTO_HOUR_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_DAY_ALARM_ENABLE()	    ((RTC_CONTROL_REG) |= (RTC_AUTO_DAY_ALARM_ENABLE_BIT));
+#define	HAL_RTC_AUTO_DAY_ALARM_DISABLE()    ((RTC_CONTROL_REG) &= ~(RTC_AUTO_DAY_ALARM_ENABLE_BIT));
+#define	HAL_RTC_MATCH_ALARM_ENABLE()        ((RTC_CONTROL_REG) |= (RTC_MATCH_ALARM_ENABLE_BIT));
+#define	HAL_RTC_MATCH_ALARM_DISABLE()       ((RTC_CONTROL_REG) &= ~(RTC_MATCH_ALARM_ENABLE_BIT));
+#define	HAL_RTC_BATTERY_LOW_VOLTAGE_INTERRUPT_ENABLE()   ((RTC_CONTROL_REG) |= (RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT));
+#define	HAL_RTC_BATTERY_LOW_VOLTAGE_INTERRUPT_DISABLE()	 ((RTC_CONTROL_REG) &= ~(RTC_BATTERY_LOW_VOLTAGE_ENABLE_BIT));
+#define	HAL_RTC_WRITE_RECORD(record)        ((RTC_RECORD_REG) =	(record));
+#define	HAL_RTC_READ_RECORD(record)         ((record) =	(RTC_RECORD_REG)); 
+#define	HAL_RTC_WRITE_MATCHED_ALARM_SECOND(second)  ((RTC_SECOND_ALARM_REG) = (second &	0x3F));
+#define	HAL_RTC_READ_MATCHED_ALARM_SECOND(second)   ((second) =	(RTC_SECOND_ALARM_REG) & 0x3F);
+#define	HAL_RTC_WRITE_MATCHED_ALARM_MINUTE(minute)  ((RTC_MINUTE_ALARM_REG) = (minute &	0x3F));
+#define	HAL_RTC_READ_MATCHED_ALARM_MINUTE(minute)   ((minute) =	(RTC_MINUTE_ALARM_REG) & 0x3F);
+#define	HAL_RTC_WRITE_MATCHED_ALARM_HOUR(hour)      ((RTC_HOUR_ALARM_REG) = (hour & 0x1F));
+#define	HAL_RTC_READ_MATCHED_ALARM_HOUR(hour)       ((hour) = (RTC_HOUR_ALARM_REG) & 0x1F);
+#define	HAL_RTC_READ_INTERRUPT_STATUS(status)       ((status) =	(RTC_INTERRUPT_STATUS_REG) & 0x3F);
+#define	HAL_RTC_WRITE_INTERRUPT_STATUS(status)      ((RTC_INTERRUPT_STATUS_REG)	= (status) & 0x3F);
+
+#endif
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_smc.h linux-2.6.35.11-ts7500//include/asm/arch/star_smc.h
--- linux-2.6.35.11/include/asm/arch/star_smc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_smc.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_SMC_H_
+#define	_STAR_SMC_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	SMC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSPA_SMC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	SMC_MEM_MAP_VALUE(reg_offset)	(*((u32 volatile *)(SYSVA_SMC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+
+/*
+ * Static Memory Controller Registers
+ */
+#define	SMC_MEM_BANK0_CONFIG_REG	SMC_MEM_MAP_VALUE(0x00)
+#define	SMC_MEM_BANK0_TIMING_REG	SMC_MEM_MAP_VALUE(0x04)
+#define	SMC_MEM_BANK1_CONFIG_REG	SMC_MEM_MAP_VALUE(0x08)
+#define	SMC_MEM_BANK1_TIMING_REG	SMC_MEM_MAP_VALUE(0x0C)
+#define	SMC_MEM_BANK2_CONFIG_REG	SMC_MEM_MAP_VALUE(0x10)
+#define	SMC_MEM_BANK2_TIMING_REG	SMC_MEM_MAP_VALUE(0x14)
+#define	SMC_MEM_BANK3_CONFIG_REG	SMC_MEM_MAP_VALUE(0x18)
+#define	SMC_MEM_BANK3_TIMING_REG	SMC_MEM_MAP_VALUE(0x1C)
+
+/*
+ * macros declarations
+ */
+
+#endif	// end of #ifndef _STAR_SMC_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_spi.h linux-2.6.35.11-ts7500//include/asm/arch/star_spi.h
--- linux-2.6.35.11/include/asm/arch/star_spi.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_spi.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,169 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef _STAR_SPI_H_
+#define _STAR_SPI_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define SPI_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_SPI_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define SPI_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_SPI_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define SPI_CONFIGURATION_REG			SPI_MEM_MAP_VALUE(0x40)
+#define SPI_SERVICE_STATUS_REG			SPI_MEM_MAP_VALUE(0x44)
+#define SPI_BIT_RATE_CONTROL_REG		SPI_MEM_MAP_VALUE(0x48)
+#define SPI_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x4C)
+#define SPI_TRANSMIT_BUFFER_REG			SPI_MEM_MAP_VALUE(0x50)
+#define SPI_RECEIVE_CONTROL_REG			SPI_MEM_MAP_VALUE(0x54)
+#define SPI_RECEIVE_BUFFER_REG			SPI_MEM_MAP_VALUE(0x58)
+#define SPI_FIFO_TRANSMIT_CONFIG_REG		SPI_MEM_MAP_VALUE(0x5C)
+#define SPI_FIFO_TRANSMIT_CONTROL_REG		SPI_MEM_MAP_VALUE(0x60)
+#define SPI_FIFO_RECEIVE_CONFIG_REG		SPI_MEM_MAP_VALUE(0x64)
+#define SPI_INTERRUPT_STATUS_REG		SPI_MEM_MAP_VALUE(0x68)
+#define SPI_INTERRUPT_ENABLE_REG		SPI_MEM_MAP_VALUE(0x6C)
+
+
+/*
+ * define constants macros
+ */
+#define SPI_TX_RX_FIFO_DEPTH			(8)
+
+#define SPI_CH0					(0)
+#define SPI_CH1					(1)
+#define SPI_CH2					(2)
+#define SPI_CH3					(3)
+
+
+#define SPI_RXFIFO_OT_FG			(0x01)
+#define SPI_TXFIFO_UT_FG			(0x02)
+#define SPI_RXBUF_FULL_FG			(0x04)
+#define SPI_TXBUF_EMPTY_FG			(0x08)
+
+#define SPI_RXFIFO_OR_FG			(0x10)
+#define SPI_TXFIFO_UR_FG			(0x20)
+#define SPI_RXBUF_OR_FG				(0x40)
+#define SPI_TXBUF_UR_FG				(0x80)
+
+/*
+ * define Character Length Control
+ */
+#define SPI_LEN_BIT_8				(0)
+#define SPI_LEN_BIT_16				(1)
+#define SPI_LEN_BIT_24				(2)
+#define SPI_LEN_BIT_32				(3)
+
+
+/*
+ * macro declarations
+ */
+#define HAL_SPI_ENABLE_SPI() \
+{ \
+    (SPI_CONFIGURATION_REG) |= ((u_int32)0x1 << 31); \
+}
+
+#define HAL_SPI_DISABLE_SPI() \
+{ \
+    (SPI_CONFIGURATION_REG) &= ~((u_int32)0x1 << 31); \
+}
+
+#define HAL_SPI_ENABLE_DATA_SWAP() \
+{ \
+    (SPI_CONFIGURATION_REG) |= (0x1 << 24); \
+}
+
+#define HAL_SPI_DISABLE_DATA_SWAP() \
+{ \
+    (SPI_CONFIGURATION_REG) &= ~(0x1 << 24); \
+}
+
+#define HAL_SPI_TRANSMIT_DATA(tx_data) \
+{ \
+    (SPI_TRANSMIT_BUFFER_REG) = tx_data; \
+}
+
+#define HAL_SPI_RECEIVE_DATA(rx_data) \
+{ \
+    (rx_data) = SPI_RECEIVE_BUFFER_REG; \
+}
+
+#define HAL_SPI_GET_TRANSMIT_FIFO_WORDS_NUMBER(tx_fifo_words_num) \
+{ \
+    (tx_fifo_words_num) = SPI_FIFO_TRANSMIT_CONFIG_REG & 0xF; \
+}
+
+#define HAL_SPI_GET_RECEIVE_FIFO_WORDS_NUMBER(rx_fifo_words_num) \
+{ \
+    (rx_fifo_words_num) = SPI_FIFO_RECEIVE_CONFIG_REG & 0xF; \
+}
+
+#define HAL_SPI_DISABLE_ALL_INTERRUPT_SOURCES() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) = 0; \
+}
+
+#define HAL_SPI_DISABLE_TX_FIFO_THRESHOLD_INTERRUPT() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) &= ~(0x1 << 1); \
+}
+
+#define HAL_SPI_DISABLE_RX_FIFO_THRESHOLD_INTERRUPT() \
+{ \
+    (SPI_INTERRUPT_ENABLE_REG) &= ~(0x1 << 0); \
+}
+
+#define HAL_SPI_READ_INTERRUPT_STATUS(status) \
+{ \
+    (status) = SPI_INTERRUPT_STATUS_REG; \
+}
+
+#define HAL_SPI_CLEAR_INTERRUPT_STATUS(status) \
+{ \
+    (SPI_INTERRUPT_STATUS_REG) = (status & 0xF0); \
+}
+
+#define HAL_SPI_SET_FIFO_TRANSMIT_DELAY(delay) \
+{ \
+    (SPI_FIFO_TRANSMIT_CONTROL_REG) = (delay & 0x1F); \
+}
+
+#define STR8100_SPI_SERIAL_MODE_GENERAL              0x0
+#define STR8100_SPI_SERIAL_MODE_MICROPROCESSOR       0x1
+ 
+struct str8100_spi_dev_attr
+{ 
+	int spi_serial_mode;
+};
+
+#endif // end of #ifndef _STAR_SPI_H_
+
diff -Nur linux-2.6.35.11/include/asm/arch/star_sys_memory_map.h linux-2.6.35.11-ts7500//include/asm/arch/star_sys_memory_map.h
--- linux-2.6.35.11/include/asm/arch/star_sys_memory_map.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_sys_memory_map.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_SYS_MEMORY_MAP_H_
+#define	_STAR_SYS_MEMORY_MAP_H_
+
+
+#if 0
+#define __UBOOT__
+#else
+#define __LINUX__
+#endif
+
+
+/*
+ * sytem memory	mapping	after reset
+ */
+#define SYSPA_FLASH_SRAM_BANK0_BASE_ADDR	0x10000000
+#define SYSPA_FLASH_SRAM_BANK1_BASE_ADDR	0x11000000
+#define SYSPA_FLASH_SRAM_BANK2_BASE_ADDR	0x12000000
+#define SYSPA_FLASH_SRAM_BANK3_BASE_ADDR	0x13000000
+#define	SYSPA_PCMCIA_ATTRIBUTE_MEMORY_BASE_ADDR	0x14000000
+#define	SYSPA_PCMCIA_COMMON_MEMORY_BASE_ADDR	0x15000000
+#define	SYSPA_PCMCIA_IO_SPACE_BASE_ADDR		0x16000000
+#define	SYSPA_IDE_DEVICE_BASE_ADDR		0x18000000
+#define	SYSPA_SDRAM_MEMORY_BASE_ADDR		0x20000000
+#define	SYSPA_GDMAC_BASE_ADDR			0x60000000
+#define	SYSPA_NIC_BASE_ADDR			0x70000000
+#define	SYSPA_SPI_BASE_ADDR			0x71000000
+#define	SYSPA_PCM_BASE_ADDR			0x71000000
+#define	SYSPA_I2C_BASE_ADDR			0x71000000
+#define	SYSPA_I2S_BASE_ADDR			0x71000000
+#define	SYSPA_DDRC_SDRC_BASE_ADDR		0x72000000
+#define	SYSPA_SMC_BASE_ADDR			0x73000000
+#define	SYSPA_PCMCIA_CONTROL_BASE_ADDR		0x73000000
+#define	SYSPA_IDE_CONTROLLER_BASE_ADDR		0x74000000
+#define	SYSPA_MISC_BASE_ADDR			0x76000000
+#define	SYSPA_POWER_MANAGEMENT_BASE_ADDR	0x77000000
+#define	SYSPA_UART0_BASE_ADDR			0x78000000
+#define	SYSPA_UART1_BASE_ADDR			0x78800000
+#define	SYSPA_TIMER_BASE_ADDR			0x79000000
+#define	SYSPA_WATCHDOG_TIMER_BASE_ADDR		0x7A000000
+#define	SYSPA_RTC_BASE_ADDR			0x7B000000
+#define	SYSPA_GPIOA_BASE_ADDR			0x7C000000
+#define	SYSPA_GPIOB_BASE_ADDR			0x7C800000
+#define	SYSPA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR	0xA0000000
+#define	SYSPA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR	0xA4000000
+#define	SYSPA_PCI_IO_SPACE_BASE_ADDR		0xA8000000
+#define	SYSPA_PCI_MEMORY_SPACE_BASE_ADDR	0xB0000000
+#define	SYSPA_USB11_CONFIG_BASE_ADDR		0xC0000000
+#define	SYSPA_USB11_OPERATION_BASE_ADDR		0xC4000000
+#define	SYSPA_USB20_CONFIG_BASE_ADDR		0xC8000000
+#define	SYSPA_USB20_OPERATION_BASE_ADDR		0xCC000000
+#define	SYSPA_USB20_DEVICE_BASE_ADDR		0xD0000000
+#define	SYSPA_VIC_BASE_ADDR			0xFFFFF000
+
+#if defined(__LINUX__)
+#define	SYSVA_FLASH_BASE_ADDR				0xFF000000
+#define SYSVA_IDE_DEVICE_BASE_ADDR		0xFFF00000
+#define SYSVA_GDMAC_BASE_ADDR			0xFFF01000
+#define SYSVA_NIC_BASE_ADDR			0xFFF02000
+#define SYSVA_SPI_BASE_ADDR			0xFFF03000
+#define SYSVA_PCM_BASE_ADDR			0xFFF04000
+#define SYSVA_I2C_BASE_ADDR			0xFFF05000
+#define SYSVA_I2S_BASE_ADDR			0xFFF06000
+#define SYSVA_DDRC_SDRC_BASE_ADDR		0xFFF07000
+#define SYSVA_SMC_BASE_ADDR			0xFFF08000
+#define SYSVA_PCMCIA_CONTROL_BASE_ADDR		0xFFF09000
+#define SYSVA_IDE_CONTROLLER_BASE_ADDR		0xFFF0A000
+#define SYSVA_MISC_BASE_ADDR			0xFFF0B000
+#define SYSVA_POWER_MANAGEMENT_BASE_ADDR	0xFFF0C000
+#define SYSVA_UART0_BASE_ADDR			0xFFF0D000
+#define SYSVA_UART1_BASE_ADDR			0xFFF0E000
+#define SYSVA_TIMER_BASE_ADDR			0xFFF0F000
+#define SYSVA_WATCHDOG_TIMER_BASE_ADDR		0xFFF10000
+#define SYSVA_RTC_BASE_ADDR			0xFFF11000
+#define SYSVA_GPIOA_BASE_ADDR			0xFFF12000
+#define SYSVA_GPIOB_BASE_ADDR			0xFFF13000
+#define SYSVA_PCI_BRIDGE_CONFIG_DATA_BASE_ADDR	0xFFF14000
+#define SYSVA_PCI_BRIDGE_CONFIG_ADDR_BASE_ADDR	0xFFF15000
+#define SYSVA_USB11_CONFIG_BASE_ADDR		0xFFF16000
+#define SYSVA_USB11_OPERATION_BASE_ADDR		0xFFF17000
+#define SYSVA_USB20_CONFIG_BASE_ADDR		0xFFF18000
+#define SYSVA_USB20_OPERATION_BASE_ADDR		0xFFF19000
+#define SYSVA_USB20_DEVICE_BASE_ADDR		0xFFF1A000
+#define SYSVA_VIC_BASE_ADDR			0xFFF1B000
+#endif //__LINUX__
+
+#endif // end of #ifndef _STAR_SYS_MEMORY_MAP_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_timer.h linux-2.6.35.11-ts7500//include/asm/arch/star_timer.h
--- linux-2.6.35.11/include/asm/arch/star_timer.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_timer.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,312 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_TIMER_H_
+#define	_STAR_TIMER_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	TIMER_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSPA_TIMER_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	TIMER_MEM_MAP_VALUE(reg_offset)		(*((u32 volatile *)(SYSVA_TIMER_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	TIMER1_COUNTER_REG			TIMER_MEM_MAP_VALUE(0x00)
+#define	TIMER1_AUTO_RELOAD_VALUE_REG		TIMER_MEM_MAP_VALUE(0x04)
+#define	TIMER1_MATCH_VALUE1_REG			TIMER_MEM_MAP_VALUE(0x08)
+#define	TIMER1_MATCH_VALUE2_REG			TIMER_MEM_MAP_VALUE(0x0C)
+
+#define	TIMER2_COUNTER_REG			TIMER_MEM_MAP_VALUE(0x10)
+#define	TIMER2_AUTO_RELOAD_VALUE_REG		TIMER_MEM_MAP_VALUE(0x14)
+#define	TIMER2_MATCH_VALUE1_REG			TIMER_MEM_MAP_VALUE(0x18)
+#define	TIMER2_MATCH_VALUE2_REG			TIMER_MEM_MAP_VALUE(0x1C)
+
+#define	TIMER1_TIMER2_CONTROL_REG		TIMER_MEM_MAP_VALUE(0x30)
+#define	TIMER1_TIMER2_INTERRUPT_STATUS_REG	TIMER_MEM_MAP_VALUE(0x34)
+#define	TIMER1_TIMER2_INTERRUPT_MASK_REG	TIMER_MEM_MAP_VALUE(0x38)
+
+#define	TIMER3_COUNTER_LOW_REG			TIMER_MEM_MAP_VALUE(0x40)
+#define	TIMER3_CONTROL_REG			TIMER_MEM_MAP_VALUE(0x44)
+
+
+/*
+ * define constants macros
+ */
+#define	TIMER1_ENABLE_BIT_INDEX			0
+#define	TIMER1_CLOCK_SOURCE_BIT_INDEX		1
+#define	TIMER1_OVERFLOW_ENABLE_BIT_INDEX	2
+
+#define	TIMER2_ENABLE_BIT_INDEX			3
+#define	TIMER2_CLOCK_SOURCE_BIT_INDEX		4
+#define	TIMER2_OVERFLOW_ENABLE_BIT_INDEX	5
+
+#define	TIMER1_UP_DOWN_COUNT_BIT_INDEX		9
+#define	TIMER2_UP_DOWN_COUNT_BIT_INDEX		10
+
+#define	TIMER1_MATCH1_INTERRUPT_BIT_INDEX	0
+#define	TIMER1_MATCH2_INTERRUPT_BIT_INDEX	1
+#define	TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX	2
+
+#define	TIMER2_MATCH1_INTERRUPT_BIT_INDEX	3
+#define	TIMER2_MATCH2_INTERRUPT_BIT_INDEX	4
+#define	TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX	5
+
+#define TIMER3_ENABLE_BIT_INDEX			17
+#define TIMER3_RESET_BIT_INDEX			16
+
+#define	TIMER_CLOCK_SOURCE_PCLK			0
+#define	TIMER_CLOCK_SOURCE_EXT_CLK		1
+
+
+#define	TIMER_OVERFLOW_MODE_DISABLE		0
+#define	TIMER_OVERFLOW_MODE_ENABLE		1
+
+
+#define	TIMER_COUNTER_MODE_UP			0
+#define	TIMER_COUNTER_MODE_DOWN			1
+
+
+#define	MATCH1_MASK_ENABLE			(1 << 0)
+
+#define	MATCH2_MASK_ENABLE			(1 << 1)
+
+#define	OVERFLOW_MASK_ENABLE			(1 << 2)
+
+
+/*
+ * macro declarations
+ */
+#define	HAL_TIMER_ENABLE_TIMER1() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER1() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER2() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER2() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER1_OVERFLOW_MODE()	\
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER1_OVERFLOW_MODE() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER2_OVERFLOW_MODE()	\
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER2_OVERFLOW_MODE() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_OVERFLOW_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER1_DOWNCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER1_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER1_UPCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER1_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER2_DOWNCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) |= (1 << TIMER2_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_SET_TIMER2_UPCOUNT() \
+{ \
+    ((TIMER1_TIMER2_CONTROL_REG) &= ~(1	<< TIMER2_UP_DOWN_COUNT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_READ_INTERRUPT_STATUS(interrupt_status) \
+{ \
+    ((interrupt_status)	= (TIMER1_TIMER2_INTERRUPT_STATUS_REG)); \
+}
+
+
+#define	HAL_TIMER_WRITE_INTERRUPT_STATUS(interrupt_status) \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_STATUS_REG) = (interrupt_status)); \
+}
+
+
+#define	HAL_TIMER_READ_INTERRUPT_MASK(interrupt_mask) \
+{ \
+    ((interrupt_mask) =	(TIMER1_TIMER2_INTERRUPT_MASK_REG)); \
+}
+
+
+#define	HAL_TIMER_WRITE_INTERRUPT_MASK(interrupt_mask) \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	= (interrupt_mask)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_TIMER2_ALL_INTERRUPTS() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	= (0x3F));\
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER1_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER1_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER1_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_MASK_TIMER2_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	|= (1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_MATCH1_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_MATCH1_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_MATCH2_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_MATCH2_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_UNMASK_TIMER2_OVERFLOW_INTERRUPT() \
+{ \
+    ((TIMER1_TIMER2_INTERRUPT_MASK_REG)	&= ~(1 << TIMER2_OVERFLOW_INTERRUPT_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_DISABLE_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = 0); \
+}
+
+
+#define	HAL_TIMER_ENABLE_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = (1 << TIMER3_ENABLE_BIT_INDEX)); \
+}
+
+
+#define	HAL_TIMER_RESET_TIMER3() \
+{ \
+    ((TIMER3_CONTROL_REG) = (1 << TIMER3_RESET_BIT_INDEX)); \
+}
+
+#ifndef __ASSEMBLY__
+static inline unsigned long long HAL_TIMER_GET_TIMER3_COUNTER(void)
+{
+	unsigned long h;
+	unsigned long l;
+
+	h = TIMER3_CONTROL_REG & 0xFFFF;
+	l = TIMER3_COUNTER_LOW_REG;
+
+	return ((((unsigned long long)h) << 32) | l);
+}
+#endif
+
+#endif	// end of #ifndef _STAR_TIMER_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_uart.h linux-2.6.35.11-ts7500//include/asm/arch/star_uart.h
--- linux-2.6.35.11/include/asm/arch/star_uart.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_uart.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,350 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_UART_H_
+#define	_STAR_UART_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#define	UART_MEM_MAP_VALUE_PHY(reg_offset)	(*((u32	volatile *)(SYSPA_UART0_BASE_ADDR + reg_offset)))
+#define	UART_MEM_MAP_VALUE_VIR(reg_offset)	(*((u32	volatile *)(SYSVA_UART0_BASE_ADDR + reg_offset)))
+
+
+#define	UART1_OFFSET		0x800000  //SYS_UART1_BASE_ADDR	= 0x78800000 = (UART1_OFFSET+ SYS_UART0_BASE_ADDR)
+
+#define	__UART_RBR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	__UART_THR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	__UART_DLL(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+
+#define	__UART_IER(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+#define	__UART_DLM(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+
+#define	__UART_IIR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	__UART_FCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	__UART_PSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+
+#define	__UART_LCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x0C)
+#define	__UART_MCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	__UART_LSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x14)
+#define	__UART_SPR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x1C)
+
+#if defined(__UBOOT__)
+#define	_UART_RBR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	_UART_THR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+#define	_UART_DLL(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x00)
+
+#define	_UART_IER(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+#define	_UART_DLM(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x04)
+
+#define	_UART_IIR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	_UART_FCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+#define	_UART_PSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x08)
+
+#define	_UART_LCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x0C)
+#define	_UART_MCR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	_UART_LSR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x14)
+#define	_UART_SPR(idx)		UART_MEM_MAP_VALUE_PHY((UART1_OFFSET * idx) + 0x1C)
+#elif defined(__LINUX__)
+#define	_UART_RBR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+#define	_UART_THR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+#define	_UART_DLL(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x00)
+
+#define	_UART_IER(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x04)
+#define	_UART_DLM(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x04)
+
+#define	_UART_IIR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+#define	_UART_FCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+#define	_UART_PSR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x08)
+
+#define	_UART_LCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x0C)
+#define	_UART_MCR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x10) //UART(n) Control Reg
+#define	_UART_LSR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x14)
+#define	_UART_SPR(idx)		UART_MEM_MAP_VALUE_VIR((UART1_OFFSET * idx) + 0x1C)
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define constants macros
+ */
+#define	UART_INPUT_CLOCK		(13000000)
+
+
+#define	UART_FIFO_DEPTH			16
+
+
+#define	RX_DATA_READY_INT		(1 << 0)
+#define	THR_EMPTY_INT			(1 << 1)
+#define	RX_LINE_STATUS_INT		(1 << 2)
+#define	MODEM_STATUS_INT		(1 << 3)
+
+
+#define	NO_INT_PENDING_MASK		(0x1)
+#define	RX_LINE_STATUS_INT_MASK		(0x6)
+#define	RX_DATA_READY_INT_MASK		(0x4)
+#define	RX_DATA_TIMEOUT_INT_MASK	(0xC)
+#define	THR_EMPTY_INT_MASK		(0x2)
+#define	MODEM_STATUS_CHANGE_MASK	(0x0)
+
+
+/* FCR Register	*/
+#define	FIFO_ENABLE			(1 << 0)
+#define	RX_FIFO_RESET			(1 << 1)
+#define	TX_FIFO_RESET			(1 << 2)
+#define	DMA_MODE			(1 << 3)
+
+
+#define	RX_FIFO_TRIGGER_LEVEL_1		(0 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_4		(1 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_8		(2 << 6)
+#define	RX_FIFO_TRIGGER_LEVEL_14	(3 << 6)
+
+
+#define	TX_FIFO_TRIGGER_LEVEL_1		(0 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_3		(1 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_9		(2 << 4)
+#define	TX_FIFO_TRIGGER_LEVEL_13	(3 << 4)
+
+
+
+/* LCR Register	*/
+#define	WORD_LENGTH_5			(0 << 0)
+#define	WORD_LENGTH_6			(1 << 0)
+#define	WORD_LENGTH_7			(2 << 0)
+#define	WORD_LENGTH_8			(3 << 0)
+
+#define	STOP_BIT_1			(0 << 2)
+#define	STOP_BIT_1_5			(1 << 2)
+#define	STOP_BIT_2			(1 << 2)
+
+#define	PARITY_CHECK_NONE		(0 << 3)
+#define	PARITY_CHECK_EVEN		(3 << 3)
+#define	PARITY_CHECK_ODD		(1 << 3)
+#define	PARITY_CHECK_STICK_ONE		(5 << 3)
+#define	PARITY_CHECK_STICK_ZERO		(7 << 3)
+
+#define	SET_BREAK			(1 << 6)
+
+#define	DLAB_ENABLE			(1 << 7)
+
+/* MCR Register	*/
+//#define UART_MCR_DTR			0x1		/* Data	Terminal Ready */
+//#define UART_MCR_RTS			0x2		/* Request to Send */
+//#define UART_MCR_OUT1			0x4		/* output1 */
+//#define UART_MCR_OUT2			0x8		/* output2 or global interrupt enable */
+#define	UART_MCR_LPBK			0x10		/* loopback mode */
+
+
+/* LSR Register	*/
+#define	_DATA_READY			(1 << 0)
+#define	OVERRUN_ERROR			(1 << 1)
+#define	PARITY_ERROR			(1 << 2)
+#define	FRAMING_ERROR			(1 << 3)
+#define	BREAK_INTERRUPT			(1 << 4)
+#define	THR_EMPTY			(1 << 5)
+#define	TRANSMITTER_EMPTY		(1 << 6)
+#define	FIFO_DATA_ERROR			(1 << 7)
+
+#define	TEST_PARITY_ERROR		(1 << 0)
+#define	TEST_FRAMING_ERROR		(1 << 1)
+#define	TEST_BAUD_GEN			(1 << 2)
+#define	TEST_LOOPBACK_ENABLE		(1 << 3)
+
+
+#define	WORD_FIVE_BITS			5
+#define	WORD_SIX_BITS			6
+#define	WORD_SEVEN_BITS			7
+#define	WORD_EIGHT_BITS			8
+
+#define	NONE_PARITY			1
+#define	EVEN_PARITY			2
+#define	ODD_PARITY			3
+#define	ONE_PARITY			4
+#define	ZERO_PARITY			5
+
+#define	ONE_STOP_BIT			1
+#define	ONE_HALF_STOP_BIT		2
+#define	TWO_STOP_BIT			3
+
+#define	TX_RX_FIFO_DISABLE		0
+#define	TX_RX_FIFO_ENABLE		1
+
+
+/*
+ * macros declarations
+ */
+
+#define	HAL_UART_READ_DATA(idx,data) \
+{ \
+    ((data) = (_UART_RBR(idx)) & 0xFF);	\
+}
+
+
+#define	HAL_UART_WRITE_DATA(idx,data) \
+{ \
+    ((_UART_THR(idx)) =	(data) & 0xFF);	\
+}
+
+
+#define	HAL_UART_ENABLE_INTERRUPT_TYPE(idx,interrupt_type) \
+{ \
+    ((_UART_IER(idx)) |= (interrupt_type & 0xF)); \
+}
+
+
+#define	HAL_UART_DISABLE_INTERRUPT_TYPE(idx,interrupt_type) \
+{ \
+    ((_UART_IER(idx)) &= ~(interrupt_type & 0xF)); \
+}
+
+
+#define	HAL_UART_READ_INTERRUPT_IDENTIFICATION(idx,uart_IIR) \
+{ \
+    ((uart_IIR)	= (_UART_IIR(idx))); \
+}
+
+
+#define	HAL_UART_CHECK_NO_INT_PENDING(idx,uart_IIR) \
+{ \
+    (((uart_IIR) & 0xF)	== (NO_INT_PENDING_MASK)); \
+}
+
+
+#define	HAL_UART_CHECK_RX_LINE_STATUS_INT(idx,uart_IIR)	\
+    (((uart_IIR) & 0xF)	== (RX_LINE_STATUS_INT_MASK))
+
+
+#define	HAL_UART_CHECK_RX_DATA_READY_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (RX_DATA_READY_INT_MASK))
+
+
+#define	HAL_UART_CHECK_RX_DATA_TIMEOUT_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (RX_DATA_TIMEOUT_INT_MASK))
+
+
+#define	HAL_UART_CHECK_THR_EMPTY_INT(idx,uart_IIR) \
+    (((uart_IIR) & 0xF)	== (THR_EMPTY_INT_MASK))
+
+
+#define	HAL_UART_FIFO_ENABLE(idx) \
+{ \
+    ((_UART_FCR(idx)) |= (FIFO_ENABLE)); \
+}
+
+
+#define	HAL_UART_FIFO_DISABLE(idx) \
+{ \
+    ((_UART_FCR(idx)) &= ~(FIFO_ENABLE)); \
+}
+
+
+#define	HAL_UART_RESET_RX_FIFO(idx) \
+{ \
+   ((_UART_FCR(idx)) |=	(RX_FIFO_RESET)); \
+}
+
+
+#define	HAL_UART_RESET_TX_FIFO(idx) \
+{ \
+    ((_UART_FCR(idx)) |= (TX_FIFO_RESET)); \
+}
+
+
+#define	HAL_UART_DLAB_ENABLE(idx) \
+{ \
+    ((_UART_LCR(idx)) |= (DLAB_ENABLE)); \
+}
+
+
+#define	HAL_UART_DLAB_DISABLE(idx) \
+{ \
+    ((_UART_LCR(idx)) &= ~(DLAB_ENABLE)); \
+}
+
+
+#define	HAL_UART_ENABLE_LOOPBACK_MODE(idx) \
+{ \
+    ((_UART_MCR(idx)) |= (UART_MCR_LPBK)); \
+}
+
+
+#define	HAL_UART_DISABLE_LOOPBACK_MODE(idx) \
+{ \
+    ((_UART_MCR(idx)) &= ~(UART_MCR_LPBK)); \
+}
+
+
+#define	HAL_UART_READ_LINE_STATUS(idx,uart_LSR)	\
+{ \
+    ((uart_LSR)	= (_UART_LSR(idx))); \
+}
+
+
+#define	HAL_UART_WRITE_DLL(idx,dll_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_DLL(idx) = (u32)dll_value; \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_WRITE_DLM(idx,dlm_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_DLM(idx) = (u32)dlm_value; \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_WRITE_PSR(idx,psr_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    _UART_PSR(idx) = (u32)(psr_value & 0x3); \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_READ_PSR(idx,psr_value) \
+{ \
+    HAL_UART_DLAB_ENABLE(idx); \
+    (psr_value)	= (u32)((_UART_PSR(idx)) & 0x3); \
+    HAL_UART_DLAB_DISABLE(idx);	\
+}
+
+
+#define	HAL_UART_CHECK_RX_DATA_READY(idx) \
+    (((_UART_LSR(idx)) & _DATA_READY) == (_DATA_READY))
+
+
+#define	HAL_UART_CHECK_TX_FIFO_EMPTY(idx) \
+    (((_UART_LSR(idx)) & THR_EMPTY) == (THR_EMPTY))
+
+
+#define	HAL_UART_CHECK_TRANSMITTER_EMPTY(idx) \
+    (((_UART_LSR(idx)) & TRANSMITTER_EMPTY) == (TRANSMITTER_EMPTY))
+
+
+#endif	// end of #ifndef _STAR_UART_H_
diff -Nur linux-2.6.35.11/include/asm/arch/star_wdtimer.h linux-2.6.35.11-ts7500//include/asm/arch/star_wdtimer.h
--- linux-2.6.35.11/include/asm/arch/star_wdtimer.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/arch/star_wdtimer.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,170 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_WATCHDOG_TIMER_H_
+#define	_STAR_WATCHDOG_TIMER_H_
+
+
+#include <mach/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	WDTIMER_MEM_MAP_VALUE(reg_offset)	(*((u32	volatile *)(SYSPA_WATCHDOG_TIMER_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	WDTIMER_MEM_MAP_VALUE(reg_offset)	(*((u32	volatile *)(SYSVA_WATCHDOG_TIMER_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	WDTIMER_COUNTER_REG			WDTIMER_MEM_MAP_VALUE(0x00)
+#define	WDTIMER_AUTO_RELOAD_REG			WDTIMER_MEM_MAP_VALUE(0x04)
+#define	WDTIMER_COUNTER_RESTART_REG		WDTIMER_MEM_MAP_VALUE(0x08)
+#define	WDTIMER_CONTROL_REG			WDTIMER_MEM_MAP_VALUE(0x0C)
+#define	WDTIMER_STATUS_REG			WDTIMER_MEM_MAP_VALUE(0x10)
+#define	WDTIMER_CLEAR_REG			WDTIMER_MEM_MAP_VALUE(0x14)
+#define	WDTIMER_INTERRUPT_LENGTH_REG		WDTIMER_MEM_MAP_VALUE(0x18)
+
+
+/*
+ * define constants macros
+ */
+#define	WDTIMER_ENABLE_BIT			(1 << 0)
+#define	WDTIMER_SYSTEM_RESET_ENABLE_BIT		(1 << 1)
+#define	WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT	(1 << 2)
+#define	WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT	(1 << 3)
+#define	WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT	(1 << 4)
+
+
+#define	WDTIMER_MAGIC_RESTART_VALUE		(0x5AB9)
+
+
+/*
+ * macros declarations
+ */
+#define	HAL_WDTIMER_READ_COUNTER(counter) \
+{ \
+    ((counter) = (WDTIMER_COUNTER_REG)); \
+}
+
+
+#define	HAL_WDTIMER_WRITE_AUTO_RELOAD_COUNTER(counter) \
+{ \
+    ((WDTIMER_AUTO_RELOAD_REG) = (counter)); \
+}
+
+
+#define	HAL_WDTIMER_READ_AUTO_RELOAD_COUNTER(counter) \
+{ \
+    ((counter) = (WDTIMER_AUTO_RELOAD_REG)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_RESTART_RELOAD() \
+{ \
+    ((WDTIMER_COUNTER_RESTART_REG) = (WDTIMER_MAGIC_RESTART_VALUE)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_SYSTEM_RESET() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_SYSTEM_RESET_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_SYSTEM_RESET() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_SYSTEM_RESET_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_SYSTEM_INTERRUPT() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_SYSTEM_INTERRUPT() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_SYSTEM_INTERRUPT_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_ENABLE_EXTERNAL_SIGNAL() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_DISABLE_EXTERNAL_SIGNAL() \
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_EXTERNAL_SIGNAL_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_CLOCK_SOURCE_PCLK()	\
+{ \
+    ((WDTIMER_CONTROL_REG) &= ~(WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_CLOCK_SOURCE_EXTCLK() \
+{ \
+    ((WDTIMER_CONTROL_REG) |= (WDTIMER_EXTERNAL_CLOCK_ENABLE_BIT)); \
+}
+
+
+#define	HAL_WDTIMER_READ_STATUS(status)	\
+{ \
+    ((status) =	(WDTIMER_STATUS_REG) & 0x00000001); \
+}
+
+
+#define	HAL_WDTIMER_CLEAR_STATUS() \
+{ \
+    ((WDTIMER_CLEAR_REG) = (1)); \
+}
+
+
+#define	HAL_WDTIMER_WRITE_INTERRUPT_LENGTH(length) \
+{ \
+    ((WDTIMER_INTERRUPT_LENGTH_REG) = (length) & 0x000000FF); \
+}
+
+
+#endif	// end of #ifndef _STAR_WATCHDOG_TIMER_H_
diff -Nur linux-2.6.35.11/include/asm/hardware.h linux-2.6.35.11-ts7500//include/asm/hardware.h
--- linux-2.6.35.11/include/asm/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm/hardware.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#endif
diff -Nur linux-2.6.35.11/include/asm-arm/arch-str8100/star_nic.h linux-2.6.35.11-ts7500//include/asm-arm/arch-str8100/star_nic.h
--- linux-2.6.35.11/include/asm-arm/arch-str8100/star_nic.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm-arm/arch-str8100/star_nic.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,346 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks 
+ * 
+ *  This file is free software; you can redistribute it and/or modify 
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation. 
+ *
+ *  This file is distributed in the hope that it will be useful, 
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details. 
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this file; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or 
+ *  visit http://www.gnu.org/licenses/. 
+ *
+ *  This file may also be available under a different license from Cavium. 
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_NIC_H_
+#define	_STAR_NIC_H_
+
+
+#include <asm/arch/star_sys_memory_map.h>
+
+
+#if defined(__UBOOT__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSPA_NIC_BASE_ADDR + reg_offset)))
+#elif defined(__LINUX__)
+#define	NIC_MEM_MAP_VALUE(reg_offset)		(*((u32	volatile *)(SYSVA_NIC_BASE_ADDR + reg_offset)))
+#else
+#error "NO SYSTEM DEFINED"
+#endif
+
+
+/*
+ * define access macros
+ */
+#define	NIC_PHY_CONTROL_REG0			NIC_MEM_MAP_VALUE(0x000)
+#define	NIC_PHY_CONTROL_REG1			NIC_MEM_MAP_VALUE(0x004)
+
+#define	NIC_MAC_CONTROL_REG			NIC_MEM_MAP_VALUE(0x008)
+#define	NIC_FLOW_CONTROL_CONFIG_REG		NIC_MEM_MAP_VALUE(0x00C)
+
+#define	NIC_ARL_CONFIG_REG			NIC_MEM_MAP_VALUE(0x010)
+
+#define	NIC_MY_MAC_HIGH_BYTE_REG		NIC_MEM_MAP_VALUE(0x014)
+#define	NIC_MY_MAC_LOW_BYTE_REG			NIC_MEM_MAP_VALUE(0x018)
+
+#define	NIC_HASH_TABLE_CONTROL_REG		NIC_MEM_MAP_VALUE(0x01C)
+
+#define	NIC_MY_VLANID_CONTROL_REG		NIC_MEM_MAP_VALUE(0x020)
+
+#define	NIC_MY_VLANID_0_1			NIC_MEM_MAP_VALUE(0x024)
+#define	NIC_MY_VLANID_2_3			NIC_MEM_MAP_VALUE(0x028)
+
+#define	NIC_DMA_CONFIG_REG			NIC_MEM_MAP_VALUE(0x030)
+#define	NIC_TX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x034)
+#define	NIC_RX_DMA_CONTROL_REG			NIC_MEM_MAP_VALUE(0x038)
+#define	NIC_TX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x03C)
+#define	NIC_RX_DESC_PTR_REG			NIC_MEM_MAP_VALUE(0x040)
+
+#define	NIC_TX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x044)
+#define	NIC_RX_DESC_BASE_ADDR_REG		NIC_MEM_MAP_VALUE(0x048)
+#define	NIC_DELAYED_INT_CONFIG_REG		NIC_MEM_MAP_VALUE(0x04C)
+
+#define	NIC_INT_STATUS_REG			NIC_MEM_MAP_VALUE(0x050)
+#define	NIC_INT_MASK_REG			NIC_MEM_MAP_VALUE(0x054)
+
+#define	NIC_TEST_0_REG				NIC_MEM_MAP_VALUE(0x058)
+#define	NIC_TEST_1_REG				NIC_MEM_MAP_VALUE(0x05C)
+
+#define	NIC_MIB_RX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x100)
+#define	NIC_MIB_RX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x104)
+#define	NIC_MIB_RX_RUNT_BYTE_CNTR		NIC_MEM_MAP_VALUE(0x108)
+#define	NIC_MIB_RX_OSIZE_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x10C)
+
+#define	NIC_MIB_RX_NO_BUF_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x110)
+
+#define	NIC_MIB_RX_CRC_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x114)
+
+#define	NIC_MIB_RX_ARL_DROP_PKT_CNTR		NIC_MEM_MAP_VALUE(0x118)
+
+#define	NIC_MIB_MYVLANID_MISMATCH_DROP_PKT_CNTR	NIC_MEM_MAP_VALUE(0x11C)
+
+#define	NIC_MIB_RX_CHKSUM_ERR_PKT_CNTR		NIC_MEM_MAP_VALUE(0x120)
+
+#define	NIC_MIB_RX_PAUSE_FRAME_PKT_CNTR		NIC_MEM_MAP_VALUE(0x124)
+
+#define	NIC_MIB_TX_OK_PKT_CNTR			NIC_MEM_MAP_VALUE(0x128)
+#define	NIC_MIB_TX_OK_BYTE_CNTR			NIC_MEM_MAP_VALUE(0x12C)
+
+#define	NIC_MIB_TX_COLLISION_CNTR		NIC_MEM_MAP_VALUE(0x130)
+#define	NIC_MIB_TX_PAUSE_FRAME_CNTR		NIC_MEM_MAP_VALUE(0x130)
+
+#define	NIC_MIB_TX_FIFO_UNDERRUN_RETX_CNTR	NIC_MEM_MAP_VALUE(0x134)
+
+
+
+
+/*
+ * define constants macros
+ */
+
+#define	NIC_PHY_ADDRESS		1 //the phy addr const	value
+#define	NIC_PHY_ID		0x0243	//the phy id
+
+#define	GW_NIC_MAX_TFD_NUM	(32)
+#define	GW_NIC_MAX_RFD_NUM	(32)
+#define	MAX_BUFFERS		(64)
+
+
+
+#define	MMU_OFF			(0)
+#define	MMU_ON			(1)
+#define	OS_NULL			(0)
+
+
+#define	NET_BUFFER_PACKET_SIZE		(512)
+#define	NET_BUFFER_SHIFT_BIT_NUM	(9)	// 2*n9=512
+
+#define	MAX_PACKET_LEN		(1536)
+
+#define	INTERNAL_LOOPBACK_MODE	(1)
+#define	SOFTWARE_REPEATER_MODE	(2)
+
+#define	TXTC_INT_BIT		(0x08000000)
+#define	TX_INSV_BIT		(0x04000000)
+
+#define	LS_BIT			(0x10000000)
+#define	FS_BIT			(0x20000000)
+#define	EOR_BIT			(0x40000000)
+#define	FS_LS_BIT		(0x30000000)
+#define	C_BIT			(0x80000000)
+#define	FS_LS_C_BIT		(0xB0000000)
+#define	FS_LS_INT_BIT		(0x38000000)
+
+
+
+// HASH	TABLE CONTROL REGISTER
+#define	NIC_HASH_TABLE_BIST_DONE_BIT	(0x1 <<	17)
+#define	NIC_HASH_TABLE_BIST_OK_BIT	(0x1 <<	16)
+#define	NIC_HASH_COMMAND_START_BIT	(0x1 <<	14)
+#define	NIC_HASH_COMMAND_BIT		(0x1 <<	13)
+#define	NIC_HASH_BIT_DATA		(0x1 <<	12)
+#define	NIC_HASH_BIT_ADDRESS_BIT	(0x1ff)
+
+
+#define	NIC_REG_CNT			((0x48 << 2) + 1)
+
+/*
+ * macro access
+ */
+
+#define	GW_NIC_TX_TFD_NEXT(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ (((u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) + 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_TX_TFD_PREVIOUS(work_tfd_ptr) \
+    work_tfd_ptr = NIC_TX_TFD_Ring.head	+ ((GW_NIC_MAX_TFD_NUM + (u32)(work_tfd_ptr - NIC_TX_TFD_Ring.head) - 1) % GW_NIC_MAX_TFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_NEXT(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ (((u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) + 1) % GW_NIC_MAX_RFD_NUM)
+
+
+#define	GW_NIC_RX_RFD_PREVIOUS(work_rfd_ptr) \
+    work_rfd_ptr = NIC_RX_RFD_Ring.head	+ ((GW_NIC_MAX_RFD_NUM + (u32)(work_rfd_ptr - NIC_RX_RFD_Ring.head) - 1) % GW_NIC_MAX_RFD_NUM)
+
+
+/*
+ * PHY register	defines
+ */
+#define	PHY_MII_CONTROL_REG_ADDR		0x00
+#define	PHY_MII_STATUS_REG_ADDR			0x01
+#define	PHY_ID1_REG_ADDR			0x02
+#define	PHY_ID2_REG_ADDR			0x03
+#define	PHY_AN_ADVERTISEMENT_REG_ADDR		0x04
+#define	PHY_AN_REAMOTE_CAP_REG_ADDR		0x05
+
+
+#define	PHY_RESERVED1_REG_ADDR			0x10
+#define	PHY_RESERVED2_REG_ADDR			0x11
+#define	PHY_CH_STATUS_OUTPUT_REG_ADDR		0x12
+#define	PHY_RESERVED3_REG_ADDR			0x13
+#define	PHY_RESERVED4_REG_ADDR			0x14
+
+
+#define	PHY_SPEC_CONTROL_REG_ADDR		0x16
+#define	PHY_INTC_CONTROL_STATUS_REG_ADDR	0x17
+
+/*
+ * NIC registers access	macros defines
+ */
+
+//0x004
+#define	HAL_NIC_WRITE_PHY_CONTROL1(config_value) \
+    ((NIC_PHY_CONTROL_REG1) = (config_value))
+
+#define	HAL_NIC_READ_PHY_CONTROL1(config_value)	\
+    ((config_value) = (NIC_PHY_CONTROL_REG1))
+
+//0x008
+#define	HAL_NIC_WRITE_MAC_CONFIGURATION(config_value) \
+    ((NIC_MAC_CONTROL_REG) = (config_value))
+
+#define	HAL_NIC_READ_MAC_CONFIGURATION(config_value) \
+    ((config_value) = (NIC_MAC_CONTROL_REG))
+
+//0x00C
+#define	HAL_NIC_WRITE_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((NIC_FLOW_CONTROL_CONFIG_REG) = (fc_cfg))
+
+#define	HAL_NIC_READ_FLOW_CONTROL_CONFIG(fc_cfg) \
+    ((fc_cfg) =	(NIC_FLOW_CONTROL_CONFIG_REG))
+
+//0x010
+#define	HAL_NIC_WRITE_ARL_CONFIGURATION(cfg) \
+    ((NIC_ARL_CONFIG_REG) = (cfg))
+
+#define	HAL_NIC_READ_ARL_CONFIGURATION(cfg) \
+    ((cfg) = (NIC_ARL_CONFIG_REG))
+
+//0x014,
+#define	HAL_NIC_WRITE_MY_MAC_HIGH_BYTE(cfg) \
+    ((NIC_MY_MAC_HIGH_BYTE_REG)	= (cfg & 0x0000FFFF ) )
+
+#define	HAL_NIC_READ_MY_MAC_HIGH_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_HIGH_BYTE_REG & 0x0000FFFF ))
+
+//0x018
+#define	HAL_NIC_WRITE_MY_MAC_LOW_BYTE(cfg) \
+    ((NIC_MY_MAC_LOW_BYTE_REG) = (cfg))
+
+#define	HAL_NIC_READ_MY_MAC_LOW_BYTE(cfg) \
+    ((cfg) = (NIC_MY_MAC_LOW_BYTE_REG))
+
+//0x03C
+#define	HAL_NIC_READ_INTERRUPT_STATUS(int_status) \
+    ((int_status) = (NIC_INT_STATUS_REG))
+
+#define	HAL_NIC_CLEAR_ALL_INTERRUPT_STATUS_SOURCES()\
+    ((NIC_INT_STATUS_REG) = (0xFFFFFFFF))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCES(source) \
+    ((NIC_INT_STATUS_REG) |= (source))
+
+#define	HAL_NIC_CLEAR_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_STATUS_REG) |= (1	<< (source_bit_index)))
+
+//0x040
+#define	HAL_NIC_DISABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0xFFFFFFFF))
+
+#define	HAL_NIC_ENABLE_ALL_INTERRUPT_STATUS_SOURCES() \
+    ((NIC_INT_MASK_REG)	= (0x00000000))
+
+#define	HAL_NIC_DISABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	|= (1 << (source_bit_index)))
+
+#define	HAL_NIC_ENABLE_INTERRUPT_STATUS_SOURCE_BIT(source_bit_index) \
+    ((NIC_INT_MASK_REG)	&= ~(1 << (source_bit_index)))
+
+//0x44
+#define	HAL_NIC_WRITE_TEST0_REG(cfg) \
+    ((NIC_TEST_0_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST0_REG(cfg) \
+    ((cfg) = (NIC_TEST_0_REG))
+
+//0x48
+#define	HAL_NIC_WRITE_TEST1_REG(cfg) \
+    ((NIC_TEST_1_REG) =	(cfg))
+
+#define	HAL_NIC_READ_TEST1_REG(cfg) \
+    ((cfg) = (NIC_TEST_1_REG))
+
+
+
+/*
+ * NIC's DMA macros defines
+ */
+#define	HAL_NIC_TX_DMA_START() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_TX_DMA_STOP() \
+    ((NIC_TX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_READ_TX_DMA_STATE(state) \
+    ((state) = (NIC_TX_DMA_CONTROL_REG))
+
+
+#define	HAL_NIC_RX_DMA_START() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(1))
+
+
+#define	HAL_NIC_RX_DMA_STOP() \
+    ((NIC_RX_DMA_CONTROL_REG) =	(0))
+
+
+#define	HAL_NIC_WRITE_TXSD(tssd_value) \
+    ((NIC_TX_DESC_PTR_REG) = (tssd_value))
+
+
+#define	HAL_NIC_READ_TXSD(tssd_value) \
+    ((tssd_value) = (NIC_TX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_RXSD(fssd_value) \
+    ((NIC_RX_DESC_PTR_REG) = (fssd_value))
+
+
+#define	HAL_NIC_READ_RXSD(fssd_value) \
+    ((fssd_value) = (NIC_RX_DESC_PTR_REG))
+
+
+#define	HAL_NIC_WRITE_TX_BASE(ts_base_value) \
+    ((NIC_TX_DESC_BASE_ADDR_REG) = (ts_base_value))
+
+
+#define	HAL_NIC_READ_TX_BASE(ts_base_value) \
+    ((ts_base_value) = (NIC_TX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_RX_BASE(fs_base_value) \
+    ((NIC_RX_DESC_BASE_ADDR_REG) = (fs_base_value))
+
+
+#define	HAL_NIC_READ_RX_BASE(fs_base_value) \
+    ((fs_base_value) = (NIC_RX_DESC_BASE_ADDR_REG))
+
+
+#define	HAL_NIC_WRITE_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config) \
+    ((NIC_DELAYED_INT_CONFIG_REG) = (delayed_interrupt_config))
+
+
+#define	HAL_NIC_READ_DELAYED_INTERRUPT_CONFIG(delayed_interrupt_config)	\
+    ((delayed_interrupt_config)	= (NIC_DELAYED_INT_CONFIG_REG))
+
+#endif	// end of #ifndef _STAR_NIC_H_
diff -Nur linux-2.6.35.11/include/asm-arm/hardware.h linux-2.6.35.11-ts7500//include/asm-arm/hardware.h
--- linux-2.6.35.11/include/asm-arm/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm-arm/hardware.h	2011-02-26 20:32:46.000000000 -0500
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#endif
diff -Nur linux-2.6.35.11/include/asm-generic/pci.h linux-2.6.35.11-ts7500//include/asm-generic/pci.h
--- linux-2.6.35.11/include/asm-generic/pci.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/asm-generic/pci.h	2011-02-26 20:32:46.000000000 -0500
@@ -43,6 +43,15 @@
 	return root;
 }
 
+#if defined(CONFIG_ARCH_STR9100) || defined(CONFIG_ARCH_STR8100)
+#define HAVE_ARCH_PCI_MWI
+static inline int pcibios_prep_mwi(struct pci_dev *dev)
+{
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x08);
+	return 0;
+}
+#endif
+
 #ifndef HAVE_ARCH_PCI_GET_LEGACY_IDE_IRQ
 static inline int pci_get_legacy_ide_irq(struct pci_dev *dev, int channel)
 {
diff -Nur linux-2.6.35.11/include/linux/decompress/mm.h linux-2.6.35.11-ts7500//include/linux/decompress/mm.h
--- linux-2.6.35.11/include/linux/decompress/mm.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/linux/decompress/mm.h	2011-02-26 20:32:46.000000000 -0500
@@ -33,7 +33,7 @@
 static void *malloc(int size)
 {
 	void *p;
-
+   
 	if (size < 0)
 		return NULL;
 	if (!malloc_ptr)
@@ -58,6 +58,7 @@
 		malloc_ptr = free_mem_ptr;
 }
 
+
 #define large_malloc(a) malloc(a)
 #define large_free(a) free(a)
 
diff -Nur linux-2.6.35.11/include/linux/i2c.h linux-2.6.35.11-ts7500//include/linux/i2c.h
--- linux-2.6.35.11/include/linux/i2c.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/linux/i2c.h	2011-02-26 20:32:46.000000000 -0500
@@ -334,6 +334,13 @@
 			   unsigned short flags, char read_write,
 			   u8 command, int size, union i2c_smbus_data *data);
 
+/* Eileen , for linux kernel 2.6.24 , 20080413 */
+/* Lifted from 2.6.24-cavium */
+#ifdef CONFIG_ARCH_STR8100
+	/* --- ioctl like call to set div. parameters. */
+	int (*algo_control)(struct i2c_adapter *, unsigned int, unsigned long);
+#endif
+
 	/* To determine what the adapter supports */
 	u32 (*functionality) (struct i2c_adapter *);
 };
diff -Nur linux-2.6.35.11/include/linux/spi/spi.h linux-2.6.35.11-ts7500//include/linux/spi/spi.h
--- linux-2.6.35.11/include/linux/spi/spi.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/linux/spi/spi.h	2011-02-26 20:32:46.000000000 -0500
@@ -432,6 +432,11 @@
 	u16		delay_usecs;
 	u32		speed_hz;
 
+#ifdef CONFIG_ARCH_STR8100
+   unsigned        last_in_message_list;
+#endif
+	
+	
 	struct list_head transfer_list;
 };
 
diff -Nur linux-2.6.35.11/include/linux/sysctl.h linux-2.6.35.11-ts7500//include/linux/sysctl.h
--- linux-2.6.35.11/include/linux/sysctl.h	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//include/linux/sysctl.h	2011-02-26 20:32:46.000000000 -0500
@@ -847,6 +847,9 @@
 	DEV_MAC_HID=5,
 	DEV_SCSI=6,
 	DEV_IPMI=7,
+#ifdef CONFIG_ARCH_STR8100
+	DEV_I2C=8,
+#endif   
 };
 
 /* /proc/sys/dev/cdrom */
@@ -917,6 +920,14 @@
 	DEV_IPMI_POWEROFF_POWERCYCLE=1,
 };
 
+#ifdef CONFIG_ARCH_STR8100
+enum {
+	DEV_I2C_CLOCK=1,
+	DEV_I2C_DEBUG=2,
+	DEV_I2C_END=3
+};
+#endif
+
 /* /proc/sys/abi */
 enum
 {
diff -Nur linux-2.6.35.11/init/do_mounts_rd.c linux-2.6.35.11-ts7500//init/do_mounts_rd.c
--- linux-2.6.35.11/init/do_mounts_rd.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//init/do_mounts_rd.c	2011-02-26 20:32:46.000000000 -0500
@@ -168,6 +168,8 @@
 	char rotator[4] = { '|' , '/' , '-' , '\\' };
 #endif
 
+   printk("rd_load_image()\n");
+
 	out_fd = sys_open("/dev/ram", O_RDWR, 0);
 	if (out_fd < 0)
 		goto out;
@@ -224,7 +226,11 @@
 		goto done;
 	}
 
+#ifdef CONFIG_ARCH_STR8100
+   buf = kmalloc(BLOCK_SIZE<<6, GFP_KERNEL);
+#else
 	buf = kmalloc(BLOCK_SIZE, GFP_KERNEL);
+#endif   
 	if (!buf) {
 		printk(KERN_ERR "RAMDISK: could not allocate buffer\n");
 		goto done;
@@ -232,7 +238,11 @@
 
 	printk(KERN_NOTICE "RAMDISK: Loading %dKiB [%ld disk%s] into ram disk... ",
 		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
+#ifdef CONFIG_ARCH_STR8100
+   for (i = 0, disk = 1; i < (nblocks>>6); i++) {
+#else
 	for (i = 0, disk = 1; i < nblocks; i++) {
+#endif      
 		if (i && (i % devblocks == 0)) {
 			printk("done disk #%d.\n", disk++);
 			rotate = 0;
@@ -248,8 +258,13 @@
 			}
 			printk("Loading disk #%d... ", disk);
 		}
+#ifdef CONFIG_ARCH_STR8100
+      sys_read(in_fd, buf, BLOCK_SIZE<<6);
+ 		sys_write(out_fd, buf, BLOCK_SIZE<<6);
+#else
 		sys_read(in_fd, buf, BLOCK_SIZE);
 		sys_write(out_fd, buf, BLOCK_SIZE);
+#endif      
 #if !defined(CONFIG_S390) && !defined(CONFIG_PPC_ISERIES)
 		if (!(i % 16)) {
 			printk("%c\b", rotator[rotate & 0x3]);
diff -Nur linux-2.6.35.11/init/initramfs.c linux-2.6.35.11-ts7500//init/initramfs.c
--- linux-2.6.35.11/init/initramfs.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//init/initramfs.c	2011-02-26 20:32:46.000000000 -0500
@@ -464,6 +464,7 @@
 		this_header = saved_offset + my_inptr;
 		buf += my_inptr;
 		len -= my_inptr;
+      break;
 	}
 	dir_utime();
 	kfree(name_buf);
diff -Nur linux-2.6.35.11/init/main.c linux-2.6.35.11-ts7500//init/main.c
--- linux-2.6.35.11/init/main.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//init/main.c	2011-02-26 20:32:46.000000000 -0500
@@ -525,6 +525,7 @@
  */
 static void __init mm_init(void)
 {
+   
 	/*
 	 * page_cgroup requires countinous pages as memmap
 	 * and it's bigger than MAX_ORDER unless SPARSEMEM.
@@ -541,12 +542,15 @@
 	char * command_line;
 	extern struct kernel_param __start___param[], __stop___param[];
 
+   printk("start_kernel()\n");
+   
 	smp_setup_processor_id();
 
 	/*
 	 * Need to run as early as possible, to initialize the
 	 * lockdep hash:
 	 */
+ 
 	lockdep_init();
 	debug_objects_early_init();
 
@@ -703,9 +707,7 @@
 
 	acpi_early_init(); /* before LAPIC and SMP init */
 	sfi_init_late();
-
 	ftrace_init();
-
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
@@ -779,9 +781,14 @@
 static void __init do_initcalls(void)
 {
 	initcall_t *fn;
+	int i;
 
 	for (fn = __early_initcall_end; fn < __initcall_end; fn++)
+   {             
+    //  printk("Calling do_one_initcall(0x%08lX)\n", *fn);
+                 
 		do_one_initcall(*fn);
+   }
 
 	/* Make sure there is no pending stuff from the initcall sequence */
 	flush_scheduled_work();
@@ -837,7 +844,7 @@
 
 	current->signal->flags |= SIGNAL_UNKILLABLE;
 
-	if (ramdisk_execute_command) {
+	if (ramdisk_execute_command) {	   
 		run_init_process(ramdisk_execute_command);
 		printk(KERN_WARNING "Failed to execute %s\n",
 				ramdisk_execute_command);
@@ -849,8 +856,8 @@
 	 * The Bourne shell can be used instead of init if we are
 	 * trying to recover a really broken machine.
 	 */
-	if (execute_command) {
-		run_init_process(execute_command);
+	if (execute_command) {	   	   
+		run_init_process(execute_command);		
 		printk(KERN_WARNING "Failed to execute %s.  Attempting "
 					"defaults...\n", execute_command);
 	}
diff -Nur linux-2.6.35.11/kernel/hrtimer.c linux-2.6.35.11-ts7500//kernel/hrtimer.c
--- linux-2.6.35.11/kernel/hrtimer.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//kernel/hrtimer.c	2011-02-26 20:32:46.000000000 -0500
@@ -328,14 +328,13 @@
 	 */
 	if (res.tv64 < 0 || res.tv64 < lhs.tv64 || res.tv64 < rhs.tv64)
 		res = ktime_set(KTIME_SEC_MAX, 0);
-
+ 
 	return res;
 }
 
 EXPORT_SYMBOL_GPL(ktime_add_safe);
 
 #ifdef CONFIG_DEBUG_OBJECTS_TIMERS
-
 static struct debug_obj_descr hrtimer_debug_descr;
 
 /*
@@ -466,7 +465,6 @@
 
 /* High resolution timer related functions */
 #ifdef CONFIG_HIGH_RES_TIMERS
-
 /*
  * High resolution timer enabled ?
  */
@@ -715,6 +713,8 @@
 	struct hrtimer_cpu_base *base = &per_cpu(hrtimer_bases, cpu);
 	unsigned long flags;
 
+	printk("hrtimer_switch_to_hres()\n");
+	
 	if (base->hres_active)
 		return 1;
 
@@ -851,7 +851,7 @@
 	int leftmost = 1;
 
 	debug_activate(timer);
-
+	
 	/*
 	 * Find the right place in the rbtree:
 	 */
@@ -885,7 +885,7 @@
 	 * state of a possibly running callback.
 	 */
 	timer->state |= HRTIMER_STATE_ENQUEUED;
-
+			
 	return leftmost;
 }
 
@@ -969,9 +969,10 @@
 	struct hrtimer_clock_base *base, *new_base;
 	unsigned long flags;
 	int ret, leftmost;
-
+	
 	base = lock_hrtimer_base(timer, &flags);
 
+		
 	/* Remove an active timer from the queue: */
 	ret = remove_hrtimer(timer, base);
 
@@ -1008,7 +1009,7 @@
 		hrtimer_enqueue_reprogram(timer, new_base, wakeup);
 
 	unlock_hrtimer_base(timer, &flags);
-
+		
 	return ret;
 }
 
@@ -1184,7 +1185,7 @@
  */
 void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
 		  enum hrtimer_mode mode)
-{
+{   
 	debug_init(timer, clock_id, mode);
 	__hrtimer_init(timer, clock_id, mode);
 }
@@ -1216,6 +1217,8 @@
 	enum hrtimer_restart (*fn)(struct hrtimer *);
 	int restart;
 
+	//printk("__run_hrtimer %lld\n", timer->_expires.tv64);
+	
 	WARN_ON(!irqs_disabled());
 
 	debug_deactivate(timer);
@@ -1452,26 +1455,41 @@
 	struct hrtimer_clock_base *base;
 	int index, gettime = 1;
 
+	
 	if (hrtimer_hres_active())
 		return;
 
+	
 	for (index = 0; index < HRTIMER_MAX_CLOCK_BASES; index++) {
 		base = &cpu_base->clock_base[index];
 
+		//printk("0\n");
+		
 		if (!base->first)
 			continue;
 
+		//printk("1\n");
+		
 		if (gettime) {
+		  // printk("2\n");
 			hrtimer_get_softirq_time(cpu_base);
+			//printk("3\n");
 			gettime = 0;
 		}
 
+		//printk("4\n");
+		
 		raw_spin_lock(&cpu_base->lock);
 
+		//printk("5\n");
+		
 		while ((node = base->first)) {
 			struct hrtimer *timer;
-
+			 			
 			timer = rb_entry(node, struct hrtimer, node);
+			
+			//printk("timer %lld\n", timer->_expires.tv64);
+			
 			if (base->softirq_time.tv64 <=
 					hrtimer_get_expires_tv64(timer))
 				break;
@@ -1507,22 +1525,28 @@
 
 static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)
 {
-	hrtimer_init_sleeper(t, current);
-
+   //printk("do_nanosleep()\n");
+   
+	hrtimer_init_sleeper(t, current);	
+	
+	//printk("1\n");
+	
 	do {
 		set_current_state(TASK_INTERRUPTIBLE);
 		hrtimer_start_expires(&t->timer, mode);
 		if (!hrtimer_active(&t->timer))
 			t->task = NULL;
-
+				
 		if (likely(t->task))
 			schedule();
-
+		
 		hrtimer_cancel(&t->timer);
 		mode = HRTIMER_MODE_ABS;
-
+			
 	} while (t->task && !signal_pending(current));
 
+	//printk("done\n");
+	
 	__set_current_state(TASK_RUNNING);
 
 	return t->task == NULL;
diff -Nur linux-2.6.35.11/kernel/itimer.c linux-2.6.35.11-ts7500//kernel/itimer.c
--- linux-2.6.35.11/kernel/itimer.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//kernel/itimer.c	2011-02-26 20:32:46.000000000 -0500
@@ -220,6 +220,7 @@
 		if (expires.tv64 != 0) {
 			tsk->signal->it_real_incr =
 				timeval_to_ktime(value->it_interval);
+								
 			hrtimer_start(timer, expires, HRTIMER_MODE_REL);
 		} else
 			tsk->signal->it_real_incr.tv64 = 0;
@@ -255,6 +256,7 @@
 {
 	struct itimerval it_new, it_old;
 
+		
 #if BITS_PER_LONG < 64
 	if (seconds > INT_MAX)
 		seconds = INT_MAX;
diff -Nur linux-2.6.35.11/kernel/sysctl_binary.c linux-2.6.35.11-ts7500//kernel/sysctl_binary.c
--- linux-2.6.35.11/kernel/sysctl_binary.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//kernel/sysctl_binary.c	2011-02-26 20:32:46.000000000 -0500
@@ -828,6 +828,13 @@
 	{}
 };
 
+#ifdef CONFIG_ARCH_STR8100
+static struct trans_ctl_table trans_i2c_table[] = {
+	{DEV_I2C_CLOCK, "str8100_clock"},
+	{DEV_I2C_DEBUG, "str8100_debug"}
+};
+#endif
+
 static const struct bin_table bin_mac_hid_files[] = {
 	/* DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES unused */
 	/* DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES unused */
@@ -857,6 +864,9 @@
 	{ CTL_DIR,	DEV_MAC_HID,	"mac_hid",	bin_mac_hid_files },
 	{ CTL_DIR,	DEV_SCSI,	"scsi",		bin_scsi_table },
 	{ CTL_DIR,	DEV_IPMI,	"ipmi",		bin_ipmi_table },
+#ifdef CONFIG_ARCH_STR8100
+	{ DEV_I2C, "i2c",	trans_i2c_table },
+#endif	
 	{}
 };
 
diff -Nur linux-2.6.35.11/kernel/time/tick-oneshot.c linux-2.6.35.11-ts7500//kernel/time/tick-oneshot.c
--- linux-2.6.35.11/kernel/time/tick-oneshot.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//kernel/time/tick-oneshot.c	2011-02-26 20:32:46.000000000 -0500
@@ -132,6 +132,8 @@
 	struct tick_device *td = &__get_cpu_var(tick_cpu_device);
 	struct clock_event_device *dev = td->evtdev;
 
+	printk("tick_switch_to_oneshot()\n");
+	
 	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||
 		    !tick_device_is_functional(dev)) {
 
diff -Nur linux-2.6.35.11/kernel/timer.c linux-2.6.35.11-ts7500//kernel/timer.c
--- linux-2.6.35.11/kernel/timer.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//kernel/timer.c	2011-02-26 20:32:46.000000000 -0500
@@ -590,7 +590,7 @@
 void init_timer_key(struct timer_list *timer,
 		    const char *name,
 		    struct lock_class_key *key)
-{
+{     
 	debug_init(timer);
 	__init_timer(timer, name, key);
 }
@@ -795,7 +795,7 @@
  * active timer returns 1.)
  */
 int mod_timer(struct timer_list *timer, unsigned long expires)
-{
+{      
 	/*
 	 * This is a common optimization triggered by the
 	 * networking code - if the timer is re-modified
@@ -847,7 +847,10 @@
  * timer tick.
  */
 void add_timer(struct timer_list *timer)
-{
+{        
+   
+   //printk("add_timer 0x%08lX %lu\n", timer->function, timer->expires - jiffies);
+   
 	BUG_ON(timer_pending(timer));
 	mod_timer(timer, timer->expires);
 }
@@ -864,7 +867,7 @@
 {
 	struct tvec_base *base = per_cpu(tvec_bases, cpu);
 	unsigned long flags;
-
+			
 	timer_stats_timer_set_start_info(timer);
 	BUG_ON(timer_pending(timer) || !timer->function);
 	spin_lock_irqsave(&base->lock, flags);
@@ -1069,7 +1072,7 @@
 static inline void __run_timers(struct tvec_base *base)
 {
 	struct timer_list *timer;
-
+			
 	spin_lock_irq(&base->lock);
 	while (time_after_eq(jiffies, base->timer_jiffies)) {
 		struct list_head work_list;
@@ -1423,7 +1426,7 @@
 {
 	struct timer_list timer;
 	unsigned long expire;
-
+	
 	switch (timeout)
 	{
 	case MAX_SCHEDULE_TIMEOUT:
@@ -1720,7 +1723,8 @@
 {
 	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
 				(void *)(long)smp_processor_id());
-
+		
+	
 	init_timer_stats();
 
 	BUG_ON(err != NOTIFY_OK);
@@ -1734,8 +1738,10 @@
  */
 void msleep(unsigned int msecs)
 {
-	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
-
+	unsigned long timeout = msecs_to_jiffies(msecs) + 1;	
+	
+	//printk("msleep %d\n", msecs);
+	
 	while (timeout)
 		timeout = schedule_timeout_uninterruptible(timeout);
 }
@@ -1749,7 +1755,9 @@
 unsigned long msleep_interruptible(unsigned int msecs)
 {
 	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
-
+		
+	//printk("msleep_interruptible %d\n", msecs);
+	
 	while (timeout && !signal_pending(current))
 		timeout = schedule_timeout_interruptible(timeout);
 	return jiffies_to_msecs(timeout);
diff -Nur linux-2.6.35.11/lib/decompress_inflate.c linux-2.6.35.11-ts7500//lib/decompress_inflate.c
--- linux-2.6.35.11/lib/decompress_inflate.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//lib/decompress_inflate.c	2011-02-26 20:32:46.000000000 -0500
@@ -25,6 +25,8 @@
 
 #include <linux/decompress/mm.h>
 
+
+
 #define GZIP_IOBUF_SIZE (16*1024)
 
 static int nofill(void *buffer, unsigned int len)
@@ -32,6 +34,7 @@
 	return -1;
 }
 
+
 /* Included from initramfs et al code */
 STATIC int INIT gunzip(unsigned char *buf, int len,
 		       int(*fill)(void*, unsigned int),
@@ -39,6 +42,7 @@
 		       unsigned char *out_buf,
 		       int *pos,
 		       void(*error_fn)(char *x)) {
+                
 	u8 *zbuf;
 	struct z_stream_s *strm;
 	int rc;
@@ -51,6 +55,7 @@
 		out_buf = malloc(out_len);
 	} else {
 		out_len = 0x7fffffff; /* no limit */
+      
 	}
 	if (!out_buf) {
 		error("Out of memory while allocating output buffer");
@@ -69,6 +74,7 @@
 	}
 
 	strm = malloc(sizeof(*strm));
+   
 	if (strm == NULL) {
 		error("Out of memory while allocating z_stream");
 		goto gunzip_nomem3;
@@ -143,7 +149,7 @@
 			strm->next_out = out_buf;
 			strm->avail_out = out_len;
 		}
-
+      
 		/* after Z_FINISH, only Z_STREAM_END is "we unpacked it all" */
 		if (rc == Z_STREAM_END) {
 			rc = 0;
@@ -169,7 +175,7 @@
 gunzip_nomem2:
 	if (flush)
 		free(out_buf);
-gunzip_nomem1:
+gunzip_nomem1:   
 	return rc; /* returns Z_OK (0) if successful */
 }
 
diff -Nur linux-2.6.35.11/lib/inflate.c linux-2.6.35.11-ts7500//lib/inflate.c
--- linux-2.6.35.11/lib/inflate.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//lib/inflate.c	2011-02-26 20:32:46.000000000 -0500
@@ -243,6 +243,7 @@
 {
        void *p;
 
+      
        if (size < 0)
 		error("Malloc error");
        if (!malloc_ptr)
@@ -268,6 +269,7 @@
 }
 #else
 #define malloc(a) kmalloc(a, GFP_KERNEL)
+
 #define free(a) kfree(a)
 #endif
 
diff -Nur linux-2.6.35.11/lib/kobject.c linux-2.6.35.11-ts7500//lib/kobject.c
--- linux-2.6.35.11/lib/kobject.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//lib/kobject.c	2011-02-26 20:32:46.000000000 -0500
@@ -795,10 +795,15 @@
 	struct kset *kset;
 	int retval;
 
+   //printk("kset_create(%s), calling kzalloc()\n", name);
+   
 	kset = kzalloc(sizeof(*kset), GFP_KERNEL);
+   //printk("Got kset = 0x%08lX\n", kset);
 	if (!kset)
 		return NULL;
+   //printk("kset_create(%s) calling kobject_set_name()\n", name);
 	retval = kobject_set_name(&kset->kobj, name);
+   //printk("Got retval = %d\n", retval);
 	if (retval) {
 		kfree(kset);
 		return NULL;
@@ -838,14 +843,19 @@
 	struct kset *kset;
 	int error;
 
+  // printk("kset_create_and_add(%s), calling kset_create()\n", name);
+   
 	kset = kset_create(name, uevent_ops, parent_kobj);
+   //printk("got kset = 0x%08lX\n", kset);
 	if (!kset)
 		return NULL;
 	error = kset_register(kset);
+  // printk("Got error = %d\n", error);
 	if (error) {
 		kfree(kset);
 		return NULL;
 	}
+   //printk("kset_create_and_add(%s) is done\n", name);
 	return kset;
 }
 EXPORT_SYMBOL_GPL(kset_create_and_add);
diff -Nur linux-2.6.35.11/Makefile linux-2.6.35.11-ts7500//Makefile
--- linux-2.6.35.11/Makefile	2011-02-26 20:41:39.000000000 -0500
+++ linux-2.6.35.11-ts7500//Makefile	2011-02-26 23:20:21.000000000 -0500
@@ -532,7 +532,7 @@
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os
 else
-KBUILD_CFLAGS	+= -O2
+KBUILD_CFLAGS	+= -O3
 endif
 
 include $(srctree)/arch/$(SRCARCH)/Makefile
diff -Nur linux-2.6.35.11/mm/backing-dev.c linux-2.6.35.11-ts7500//mm/backing-dev.c
--- linux-2.6.35.11/mm/backing-dev.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//mm/backing-dev.c	2011-02-26 20:32:46.000000000 -0500
@@ -661,6 +661,7 @@
 {
 	int i, err;
 
+//printk("bdi_init(), Calling spin_lock_init()\n");
 	bdi->dev = NULL;
 
 	bdi->min_ratio = 0;
@@ -672,6 +673,7 @@
 	INIT_LIST_HEAD(&bdi->wb_list);
 	INIT_LIST_HEAD(&bdi->work_list);
 
+//printk("Calling bdi_wb_init()\n");
 	bdi_wb_init(&bdi->wb, bdi);
 
 	for (i = 0; i < NR_BDI_STAT_ITEMS; i++) {
@@ -680,6 +682,7 @@
 			goto err;
 	}
 
+//printk("Calling prop_local_init_percpu()\n");
 	bdi->dirty_exceeded = 0;
 	err = prop_local_init_percpu(&bdi->completions);
 
diff -Nur linux-2.6.35.11/mm/shmem.c linux-2.6.35.11-ts7500//mm/shmem.c
--- linux-2.6.35.11/mm/shmem.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//mm/shmem.c	2011-02-26 20:32:46.000000000 -0500
@@ -2526,21 +2526,27 @@
 int __init init_tmpfs(void)
 {
 	int error;
+//printk("Calling bdi_init()\n");
+
 
 	error = bdi_init(&shmem_backing_dev_info);
 	if (error)
 		goto out4;
 
+//printk("Calling init_inodecache()\n");   
 	error = init_inodecache();
 	if (error)
 		goto out3;
 
+//printk("Calling register_filesystem()\n");
 	error = register_filesystem(&tmpfs_fs_type);
 	if (error) {
 		printk(KERN_ERR "Could not register tmpfs\n");
 		goto out2;
 	}
 
+//printk("Calling vfs_kern_mount()\n");
+
 	shm_mnt = vfs_kern_mount(&tmpfs_fs_type, MS_NOUSER,
 				tmpfs_fs_type.name, NULL);
 	if (IS_ERR(shm_mnt)) {
@@ -2548,6 +2554,9 @@
 		printk(KERN_ERR "Could not kern_mount tmpfs\n");
 		goto out1;
 	}
+   //printf("init_tmpfs() done OK\n");
+   printk("init_tmpfs() done OK\n");
+   
 	return 0;
 
 out1:
@@ -2559,6 +2568,9 @@
 out4:
 	shm_mnt = ERR_PTR(error);
 	return error;
+   
+
+
 }
 
 #ifdef CONFIG_CGROUP_MEM_RES_CTLR
@@ -2621,8 +2633,11 @@
 
 int __init init_tmpfs(void)
 {
+//printk("Calling register_filesystem()\n");
+
 	BUG_ON(register_filesystem(&tmpfs_fs_type) != 0);
 
+//printk("Calling kern_mount()\n");
 	shm_mnt = kern_mount(&tmpfs_fs_type);
 	BUG_ON(IS_ERR(shm_mnt));
 
diff -Nur linux-2.6.35.11/mm/swap.c linux-2.6.35.11-ts7500//mm/swap.c
--- linux-2.6.35.11/mm/swap.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//mm/swap.c	2011-02-26 20:32:46.000000000 -0500
@@ -500,6 +500,8 @@
 {
 	unsigned long megs = totalram_pages >> (20 - PAGE_SHIFT);
 
+   //printk("swap_setup(), calling bdi_init()\n");
+   
 #ifdef CONFIG_SWAP
 	bdi_init(swapper_space.backing_dev_info);
 #endif
diff -Nur linux-2.6.35.11/net/bridge/Kconfig linux-2.6.35.11-ts7500//net/bridge/Kconfig
--- linux-2.6.35.11/net/bridge/Kconfig	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//net/bridge/Kconfig	2011-02-26 20:32:46.000000000 -0500
@@ -32,6 +32,17 @@
 
 	  If unsure, say N.
 
+if BRIDGE
+config BRIDGE_ID_POLICY_MINIMUM
+	bool "Bridge ID select policy - minimum"
+	default n
+	help
+	  The policy to choose bridge ID. If you say Y, the bridge would choose 
+	  the minimum bridge port ID as it's ID. This feature will affect PCI 
+	  fastpath function of Star's STR9100 series.
+	  
+endif     
+     
 config BRIDGE_IGMP_SNOOPING
 	bool "IGMP/MLD snooping"
 	depends on BRIDGE
diff -Nur linux-2.6.35.11/net/core/net_namespace.c linux-2.6.35.11-ts7500//net/core/net_namespace.c
--- linux-2.6.35.11/net/core/net_namespace.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//net/core/net_namespace.c	2011-02-26 20:32:46.000000000 -0500
@@ -346,6 +346,7 @@
 	struct net_generic *ng;
 
 #ifdef CONFIG_NET_NS
+  	printk(KERN_INFO "net_namespace: %zd bytes\n", sizeof(struct net));
 	net_cachep = kmem_cache_create("net_namespace", sizeof(struct net),
 					SMP_CACHE_BYTES,
 					SLAB_PANIC, NULL);
diff -Nur linux-2.6.35.11/security/min_addr.c linux-2.6.35.11-ts7500//security/min_addr.c
--- linux-2.6.35.11/security/min_addr.c	2011-02-06 14:04:07.000000000 -0500
+++ linux-2.6.35.11-ts7500//security/min_addr.c	2011-02-26 20:32:46.000000000 -0500
@@ -14,6 +14,7 @@
  */
 static void update_mmap_min_addr(void)
 {
+   
 #ifdef CONFIG_LSM_MMAP_MIN_ADDR
 	if (dac_mmap_min_addr > CONFIG_LSM_MMAP_MIN_ADDR)
 		mmap_min_addr = dac_mmap_min_addr;
@@ -22,6 +23,7 @@
 #else
 	mmap_min_addr = dac_mmap_min_addr;
 #endif
+
 }
 
 /*
@@ -45,8 +47,9 @@
 
 static int __init init_mmap_min_addr(void)
 {
+         
 	update_mmap_min_addr();
-
+	
 	return 0;
 }
 pure_initcall(init_mmap_min_addr);
